<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>.NET 注册 COM 组件</title>
      <link href="/2024/06/13/net-expose-components/"/>
      <url>/2024/06/13/net-expose-components/</url>
      
        <content type="html"><![CDATA[<h2 id="生成密钥文件"><a href="#生成密钥文件" class="headerlink" title="生成密钥文件"></a>生成密钥文件</h2><p>提前准备好一个密钥文件，因为将注册为 COM 组件时要求提供签名。<br>打开 Visual Studio 命令行工具，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sn -k xxx.snk</span><br></pre></td></tr></table></figure><p>得到文件后放到工程目录下即可。</p><h2 id="NET-Framework-工程设置"><a href="#NET-Framework-工程设置" class="headerlink" title=".NET Framework 工程设置"></a>.NET Framework 工程设置</h2><p>传统风格的工程文件和新的 SDK style 稍微有些区别，所以分开说。</p><h3 id="传统风格工程"><a href="#传统风格工程" class="headerlink" title="传统风格工程"></a>传统风格工程</h3><p><strong>默认 COM 可见性</strong><br>打开工程设置窗口，点击程序集设置</p><p><img src="/images/net-expose-components/01.webp"><br><img src="/images/net-expose-components/02.webp"></p><p>这里不建议勾选，因为 .NET 默认会将程序集中所有访问权限为<code>public</code>的类都对外公开，这当然是不合适的。<br>所以这里默认没有勾选，实际上，这里的选项会影响<code>AssemblyInfo.cs</code>文件中<code>ComVisible</code>属性值。</p><p><img src="/images/net-expose-components/03.webp"></p><p><code>为 COM 互操作注册</code>选项决定在编译后是否自动注册 DLL，根据自身需要设置。<br><img src="/images/net-expose-components/04.webp"><br>对应的工程属性为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RegisterForComInterop</span>&gt;</span>true<span class="tag">&lt;/<span class="name">RegisterForComInterop</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><strong>设置签名文件</strong></p><p><img src="/images/net-expose-components/05.webp"></p><p>对应的工程属性为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SignAssembly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SignAssembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span>xxx.snk<span class="tag">&lt;/<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写一个测试接口和其实现即可，注意要在实现类上设置<code>[ComVisible(true)]</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassLibrary2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICalc</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ComVisible(true)</span>]</span><br><span class="line">    [<span class="meta">Guid(<span class="string">&quot;365BBAE2-A911-4078-952A-9B5734538C35&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ClassInterface(ClassInterfaceType.None)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Calc</span> : <span class="title">ICalc</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动注册-COM-组件"><a href="#手动注册-COM-组件" class="headerlink" title="手动注册 COM 组件"></a>手动注册 COM 组件</h4><p>如果设置了<code>RegisterForComInterop</code>属性的话会在编译后自动注册，否则就需要手动注册。<br>而用 .NET Framework 开发的 COM 组件不能用传统的<code>regsvr32</code>去注册，要用运行时自带的<code>RegAsm.exe</code>工具注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe ClassLibrary2.dll /tlb:ClassLibrary2.tlb /codebase</span><br></pre></td></tr></table></figure><p>注意我这里用的是 x64 架构注册，注册 COM 组件时要确认架构一致性。<br>卸载的话使用<code>/u</code>选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe ClassLibrary2.dll /u</span><br></pre></td></tr></table></figure><p>我们可以用 <a href="https://www.nirsoft.net/utils/registered_dll_view.html">RegDllView</a> 软件查看系统 COM 注册情况。</p><p><img src="/images/net-expose-components/06.webp"></p><h4 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h4><p>COM 组件的好处是语言无关性，我们可以编写一个 VBScript 脚本测试接口：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> obj</span><br><span class="line"><span class="keyword">Set</span> obj = <span class="built_in">CreateObject</span>(<span class="string">&quot;ClassLibrary2.Calc&quot;</span>)</span><br><span class="line"><span class="keyword">Dim</span> result</span><br><span class="line">result = obj.Add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">MsgBox <span class="string">&quot;The result is: &quot;</span> &amp; result</span><br></pre></td></tr></table></figure><p>结果正确<br><img src="/images/net-expose-components/07.webp"></p><h3 id="NET-Sdk-风格工程"><a href="#NET-Sdk-风格工程" class="headerlink" title="NET.Sdk 风格工程"></a>NET.Sdk 风格工程</h3><p>.NET Sdk 风格的工程文件因为没有界面，所以需要手动编辑</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">SignAssembly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SignAssembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span>xxx.snk<span class="tag">&lt;/<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RegisterForComInterop</span>&gt;</span>true<span class="tag">&lt;/<span class="name">RegisterForComInterop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Platforms</span>&gt;</span>AnyCPU;x64<span class="tag">&lt;/<span class="name">Platforms</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 .NET Sdk 风格工程没有<code>AssemblyInfo.cs</code>文件设置程序集属性，这导致项目默认会将所有<code>public</code>的类都公开。<br>这就需要我们手动将程序集属性<code>ComVisible</code>设置为<code>false</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AssemblyAttribute</span> <span class="attr">Include</span>=<span class="string">&quot;System.Runtime.InteropServices.ComVisibleAttribute&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_Parameter1</span>&gt;</span>false<span class="tag">&lt;/<span class="name">_Parameter1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AssemblyAttribute</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同于传统风格工程文件是将属性写在代码中，Sdk 风格将属性配置在工程文件中。</p><h2 id="NET-工程设置"><a href="#NET-工程设置" class="headerlink" title=".NET 工程设置"></a>.NET 工程设置</h2><p>对于新的 .NET 框架，使用<code>EnableComHosting</code>属性决定是否生成 COM Host（一个用于注册的本机 DLL 文件）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Library<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFrameworks</span>&gt;</span>net8<span class="tag">&lt;/<span class="name">TargetFrameworks</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>disable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Nullable</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">Nullable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LangVersion</span>&gt;</span>12<span class="tag">&lt;/<span class="name">LangVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SignAssembly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SignAssembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span>xxx.snk<span class="tag">&lt;/<span class="name">AssemblyOriginatorKeyFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EnableComHosting</span>&gt;</span>true<span class="tag">&lt;/<span class="name">EnableComHosting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Platforms</span>&gt;</span>AnyCPU;x64<span class="tag">&lt;/<span class="name">Platforms</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当<code>EnableComHosting</code>属性为<code>true</code>时，编译后会多出一个<code>[ProjectName].comhost.dll</code>文件。</p><p><img src="/images/net-expose-components/08.webp"></p><p>这不是 .NET 程序集，而是一个本机的 DLL 文件。</p><p><img src="/images/net-expose-components/09.webp"></p><p>而这个 DLL 文件导出了注册 COM 需要的几个标准方法，用 C++ 开发过 COM 组件的一定都明白了。</p><p><img src="/images/net-expose-components/10.webp"></p><p>可以看出 .NET 不同于 .NET Framework 框架的处理方式。所以这里不再需要用<code>RegAsm.exe</code>去注册了，直接原生注册即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 ClassLibrary2.comhost.dll</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 /u ClassLibrary2.comhost.dll</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/native-interop/expose-components-to-com">向 COM 公开 .NET Core 组件</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/assembly/set-attributes-project-file">在项目文件中设置程序集属性</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 如何搜索设备驱动</title>
      <link href="/2024/05/28/windows-drivers/"/>
      <url>/2024/05/28/windows-drivers/</url>
      
        <content type="html"><![CDATA[<p>驱动由一个<code>.inf</code>文件和若干其他文件组成，搜索驱动的过程本质上就是查找<code>.inf</code>文件。然后通过文件中提供的信息查找二进制文件并进行注册安装。所以<code>.inf</code>文件就类似于一个安装脚本，包含着驱动的安装逻辑。</p><h2 id="搜索驱动"><a href="#搜索驱动" class="headerlink" title="搜索驱动"></a>搜索驱动</h2><p>当系统检测到新设备时会发生什么事呢？<br>首先 Windows 会从注册表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DevicePath</span><br></pre></td></tr></table></figure><p>所指向的目录下遍历<code>.inf</code>文件，这个值默认是<code>%SystemRoot%\inf</code>。支持多个目录，每个目录之间用分号隔开。<br>匹配到驱动后会从 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/driver-store">DriverStore</a> 文件夹，也就是<code>%SystemRoot%\System32\DriverStore\FileRepository</code>下查找驱动文件并安装。</p><p><br>如果是手动从其他目录安装的驱动，那么系统会将驱动文件复制到 DriverStore 文件夹下，以便下次使用。<br>所以这个目录会随着时间的推移而膨胀，因为其中包含着曾经使用过的所有驱动。</p><h2 id="工具、网站"><a href="#工具、网站" class="headerlink" title="工具、网站"></a>工具、网站</h2><p>几个驱动下载网站，支持用硬件ID搜索驱动，比如<code>VEN_15AD&amp;DEV_0740</code>。</p><p><a href="https://catalog.update.microsoft.com/">https://catalog.update.microsoft.com</a><br><a href="https://driverslab.ru/">https://driverslab.ru</a><br><a href="https://devicehunt.com/">https://devicehunt.com</a><br><a href="https://deviceinbox.com/">https://deviceinbox.com</a><br><a href="https://www.devicekb.com/">https://www.devicekb.com</a><br><a href="https://download-drivers.net/">https://download-drivers.net</a></p><p><br>软件：<br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/pnputil">PnPUtil</a><br><a href="https://github.com/lostindark/DriverStoreExplorer">Driver Store Explorer</a><br><a href="https://www.nirsoft.net/utils/device_manager_view.html">DevManView</a></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/how-windows-selects-a-driver-for-a-device">Windows 如何为设备选择驱动程序包</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/preloading-driver-packages">预加载驱动程序包</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/overview-of-device-and-driver-installation">设备安装概述</a><br><a href="https://www.cnblogs.com/foohack/p/3437983.html">windows设备驱动安装指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装 .NET Framework 报 0x800B0109 等错误的解决方法</title>
      <link href="/2024/05/26/net-0x800b0109-0x80096005/"/>
      <url>/2024/05/26/net-0x800b0109-0x80096005/</url>
      
        <content type="html"><![CDATA[<p>在 Windows Thin PC 上安装 .NET Framework 4.8 时报错。</p><h2 id="错误-0x800B0109"><a href="#错误-0x800B0109" class="headerlink" title="错误 0x800B0109"></a>错误 0x800B0109</h2><p>错误消息：已处理证书链，但是在不受信任提供程序信任的根证书中终止。</p><p><img src="/images/net-0x800b0109-0x80096005/01.webp"></p><p>看上去和数字证书有关。</p><p><img src="/images/net-0x800b0109-0x80096005/02.webp"></p><p>因为 Windows 7 SP1 (x86) 系统在未安装系统所需补丁的情况下不带此证书，而 Windows 7 SP1 (x64) 系统的最新版带有此证书。<br>网上找到解决方法说要将 <a href="http://download.microsoft.com/download/2/4/8/248D8A62-FCCD-475C-85E7-6ED59520FC0F/MicrosoftRootCertificateAuthority2011.cer">MicrosoftRootCertificateAuthority2011.cer</a> 这个证书添加到<code>受信任的根证书颁发机构</code>中。</p><h2 id="错误-0x80096005"><a href="#错误-0x80096005" class="headerlink" title="错误 0x80096005"></a>错误 0x80096005</h2><p>此时又出现新的错误：时间戳签名和&#x2F;或证书无法验证或已损坏。</p><p><img src="/images/net-0x800b0109-0x80096005/03.webp"></p><p>解决方法：安装 <a href="http://support.microsoft.com/kb/KB2813430">KB2813430</a> 补丁。</p><h2 id="绕过-0x800B0109"><a href="#绕过-0x800B0109" class="headerlink" title="绕过 0x800B0109"></a>绕过 0x800B0109</h2><p>有人说只用只用安装 <a href="http://support.microsoft.com/kb/KB2813430">KB2813430</a> 补丁就能解决了，并不用导入证书。<br>我在一个优化了服务程序的系统上测试结果的确是这样。怀疑是禁用某个服务导致安装程序跳过证书验证了。<br>经过反复试验后发现，同时禁用掉<code>Software Protection</code>和<code>DNS Client</code>服务的确可以顺利安装 .NET Framework 4.8。<br>禁用服务前：</p><p><img src="/images/net-0x800b0109-0x80096005/04.webp"></p><p>禁用服务后：</p><p><img src="/images/net-0x800b0109-0x80096005/05.webp"></p><p>虽然证书仍然显示异常，但是确实可以安装成功。至于背后的原理我也没有再深究了，也不建议这样绕过。<br>正常的办法就是按照前面说的两步解决：安装根证书和打补丁。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://help.seewo.com/easinote/JBXIKMagzq">解决安装 .NET Framework 组件时会遇到的若干问题</a><br><a href="https://blog.csdn.net/richardfjf/article/details/108112229">安装net-framework4.8弹出“已处理证书链,但是在不受信任提供程序信任的根证书中终止”错误的解决方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作 Windows 应答文件</title>
      <link href="/2024/05/25/windows-unattend/"/>
      <url>/2024/05/25/windows-unattend/</url>
      
        <content type="html"><![CDATA[<p>在 Windows 安装过程中，有很多设置页面需要人工输入，为了实现自动化安装，微软提供了 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/wsim/answer-files-overview">应答文件</a> 机制。有了应答文件就可以全程无人值守安装。</p><p><br>本篇教程以 <a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/">cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso</a> 为样本，并以无人值守安装为目的制作最小的应答文件。</p><h2 id="安装-Windows-ADK"><a href="#安装-Windows-ADK" class="headerlink" title="安装 Windows ADK"></a>安装 Windows ADK</h2><p>制作应答文件需要用到 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/get-started/adk-install">Windows ADK</a> 工具包中的 Windows 系统映像管理器(SIM) 。<br>直链：<a href="https://download.microsoft.com/download/6/1/f/61fcd094-9641-439c-adb5-6e9fe2760856/adk/adksetup.exe">Windows ADK 10.1.25398.1</a></p><p><br>仅安装<code>部署工具</code>即可，其中包含了<code>Windows 系统映像管理器</code>。软件操作很简单，这里不展开说了，网上有很多教程。</p><h2 id="配置阶段"><a href="#配置阶段" class="headerlink" title="配置阶段"></a>配置阶段</h2><p>Windows 在整个安装过程中分为不同的阶段，依次为：</p><ol><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/windowspe">windowsPE</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/offlineservicing">offlineServicing</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/generalize">generalize</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/specialize">specialize</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/auditsystem">auditSystem</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/audituser">auditUser</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/oobesystem">oobeSystem</a></li></ol><p><br>绝大多数时候也就只用到<code>windowsPE</code>、<code>specialize</code>和<code>oobeSystem</code>这三个配置阶段。</p><h3 id="windowsPE"><a href="#windowsPE" class="headerlink" title="windowsPE"></a>windowsPE</h3><p>这是 Windows 安装过程的第一个阶段。主要用于启动安装程序，对硬盘格式化等操作。</p><h4 id="跳过语言设置"><a href="#跳过语言设置" class="headerlink" title="跳过语言设置"></a>跳过语言设置</h4><p><img src="/images/windows-unattend/01.webp"></p><p>为了跳过这个页面，我们在该阶段添加 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe">Microsoft-Windows-International-Core-WinPE</a> 组件。<br>设置 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe-inputlocale">InputLocale</a>、<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe-systemlocale">SystemLocale</a>、<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe-uilanguage">UILanguage</a>、<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe-userlocale">UserLocale</a> 这四个值为<code>zh-CN</code>，表示用简体中文。</p><p><img src="/images/windows-unattend/02.webp"></p><h4 id="跳过许可条款"><a href="#跳过许可条款" class="headerlink" title="跳过许可条款"></a>跳过许可条款</h4><p>接着便是<code>软件许可条款</code>页面。<br><img src="/images/windows-unattend/03.webp"></p><p>为了跳过这个页面，我们在该阶段添加 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup">Microsoft-Windows-Setup</a> 组件。<br>将 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-userdata">UserData</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-userdata-accepteula">AcceptEula</a> 设置为<code>true</code>。</p><p><img src="/images/windows-unattend/04.webp"></p><h4 id="选择系统"><a href="#选择系统" class="headerlink" title="选择系统"></a>选择系统</h4><p>如果镜像文件中包含多个系统版本的话就会弹出这个页面。</p><p><img src="/images/windows-unattend/05.webp"></p><p>为了跳过这个页面，我们在该阶段添加 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup">Microsoft-Windows-Setup</a> 组件。<br>将 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-imageinstall">ImageInstall</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-imageinstall-osimage">OSImage</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-imageinstall-osimage-installfrom">InstallFrom</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-imageinstall-osimage-installfrom-metadata">MetaData</a> 键值设置为<code>/IMAGE/INDEX</code>和<code>1</code>。<br>其中<code>1</code>表示安装列表中第一个操作系统，在这里也就是<code>Windows 7 简易版</code>。</p><p><img src="/images/windows-unattend/06.webp"></p><h4 id="安装位置"><a href="#安装位置" class="headerlink" title="安装位置"></a>安装位置</h4><p>选择系统安装在哪个硬盘的哪个分区上。<br>考虑到每个用户的硬件环境不同，需求不同，建议交给用户自己选择。否则容易对硬盘格式化造成硬盘数据丢失。</p><p><img src="/images/windows-unattend/07.webp"></p><p>硬盘的无人值守设置参考 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-setup-imageinstall-osimage-installto">InstallTo</a> 配置。</p><p><br>至此 windowsPE 阶段就算配置完成了，系统开始安装：</p><p><img src="/images/windows-unattend/08.webp"></p><p>安装完成后会自动重启电脑，进入下一个阶段。</p><h3 id="oobeSystem"><a href="#oobeSystem" class="headerlink" title="oobeSystem"></a>oobeSystem</h3><p>重启后来到的第一个设置页面，要求我们创建用户。</p><p><img src="/images/windows-unattend/09.webp"><br><img src="/images/windows-unattend/10.webp"></p><p>输入产品密钥<br><img src="/images/windows-unattend/11.webp"></p><p>更新设置<br><img src="/images/windows-unattend/12.webp"></p><p>时间设置<br><img src="/images/windows-unattend/13.webp"></p><p>网络设置<br><img src="/images/windows-unattend/14.webp"></p><p>以上这些设置可以统一用 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/automate-oobe">SkipMachineOOBE</a> 属性跳过<br>添加 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup">Microsoft-Windows-Shell-Setup</a> 组件，将 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup-oobe">OOBE</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/automate-oobe">SkipMachineOOBE</a> 设置为<code>true</code>。</p><p><img src="/images/windows-unattend/15.webp"></p><p>注意，微软并不推荐使用<code>SkipMachineOOBE</code>，但是不用的话则会强制要求用户创建一个新用户才能进行下一步。<br>不过对于用户来说可以绕过：<a href="https://zhuanlan.zhihu.com/p/468116082">Windows系统安装后，跳过创建用户的向导，直接使用administrator账户</a></p><p><br>事情还没完，因为前面跳过了创建用户的操作，Windows 内置用户<code>Administrator</code>又默认是禁用的，导致无法顺利进入桌面。</p><p><img src="/images/windows-unattend/16.webp"></p><p>所以要在应答文件中设置启用<code>Administrator</code>用户并自动登录。<br>添加 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup">Microsoft-Windows-Shell-Setup</a> 组件。<br>将 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup-autologon">AutoLogon</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup-autologon-enabled">Enabled</a> 设置为<code>true</code>。</p><p>将 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup-autologon">AutoLogon</a>&#x2F;<a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-shell-setup-autologon-username">Username</a> 设置为<code>Administrator</code>。</p><p><img src="/images/windows-unattend/17.webp"></p><h2 id="使用应答文件"><a href="#使用应答文件" class="headerlink" title="使用应答文件"></a>使用应答文件</h2><p>经过上面的分析，最终得到一个最小的应答文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">unattend</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:unattend&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> <span class="attr">pass</span>=<span class="string">&quot;windowsPE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-International-Core-WinPE&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;x86&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">InputLocale</span>&gt;</span>zh-CN<span class="tag">&lt;/<span class="name">InputLocale</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SystemLocale</span>&gt;</span>zh-CN<span class="tag">&lt;/<span class="name">SystemLocale</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">UILanguage</span>&gt;</span>zh-CN<span class="tag">&lt;/<span class="name">UILanguage</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">UserLocale</span>&gt;</span>zh-CN<span class="tag">&lt;/<span class="name">UserLocale</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Setup&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;x86&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">UserData</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AcceptEula</span>&gt;</span>true<span class="tag">&lt;/<span class="name">AcceptEula</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">UserData</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> <span class="attr">pass</span>=<span class="string">&quot;oobeSystem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Shell-Setup&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;x86&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OOBE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SkipMachineOOBE</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SkipMachineOOBE</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">OOBE</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AutoLogon</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Username</span>&gt;</span>Administrator<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">AutoLogon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">unattend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这个应答文件仅会出现两次交互，<code>选择系统版本</code>和<code>安装磁盘位置</code>。<br>最后将这个 xml 文件命名为<code>autounattend.xml</code>，放到 ISO 根目录下即可。</p><p><img src="/images/windows-unattend/18.webp"></p><h2 id="从第三方-WinPE-安装"><a href="#从第三方-WinPE-安装" class="headerlink" title="从第三方 WinPE 安装"></a>从第三方 WinPE 安装</h2><p>实际上，如今用微软官方 ISO 去安装的方式已经不多见了。主流的方式是用第三方 PE 系统，因为有桌面，有丰富的工具，比如 <a href="https://www.wepe.com.cn/">微PE工具箱</a> 之类的系统。<br>从第三方 PE 去安装意味着应答文件中 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/windowspe">windowsPE</a> 阶段的设置都是无意义的。<br>所以从第三方 PE 安装的话，则最小应答文件是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">unattend</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:unattend&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> <span class="attr">pass</span>=<span class="string">&quot;specialize&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Security-SPP-UX&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;x86&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SkipAutoActivation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SkipAutoActivation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> <span class="attr">pass</span>=<span class="string">&quot;oobeSystem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Shell-Setup&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;x86&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OOBE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SkipMachineOOBE</span>&gt;</span>true<span class="tag">&lt;/<span class="name">SkipMachineOOBE</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">OOBE</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AutoLogon</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Username</span>&gt;</span>Administrator<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">AutoLogon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">unattend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里在 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/specialize">specialize</a> 阶段添加了 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-security-spp-ux">Microsoft-Windows-Security-SPP-UX</a> 组件。<br>属性 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/unattend/microsoft-windows-security-spp-ux-skipautoactivation">SkipAutoActivation</a> 值设置为<code>true</code>，表示跳过激活，否则安装会失败。</p><p><br>使用方法：将应答文件放在 <code>C:\Windows\Panther\unattend.xml</code>即可。<br>或者用 WinNTSetup 之类的工具安装，可以指定应答文件。</p><p><img src="/images/windows-unattend/19.webp"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>应答文件与系统版本是有关的，如果应答文件中存在不支持的参数，映像管理工具会警告：</p><p><img src="/images/windows-unattend/20.webp"></p><p>如果试图用错误的应答文件安装会导致失败：</p><p><img src="/images/windows-unattend/21.webp"></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://blog.csdn.net/Junson142099/article/details/109308109">使用Windows Sysprep来封装系统</a><br><a href="https://www.doc88.com/p-9992000210930.html">Windows7 无人值守技术</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/wsim/answer-files-overview">应答文件概述</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/automate-windows-setup">自动化 Windows 安装</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/customize/desktop/wsim/best-practices-for-authoring-answer-files">有关创建应答文件的最佳做法</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/windows-setup-automation-overview#implicit-answer-file-search-order">应答文件搜索顺序</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 系统封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程获取 Windows 内置帐户名称</title>
      <link href="/2024/05/18/get-builtin-account/"/>
      <url>/2024/05/18/get-builtin-account/</url>
      
        <content type="html"><![CDATA[<p>Windows 系统存在两个常用的内置账户：<code>Administrator</code>和<code>Guest</code>。<br>而这两个帐户名称是可以在组策略中修改的<br><img src="/images/get-builtin-account/01.webp"></p><p><br>而一些关于帐户的 API 函数都要求提供帐户名，比如 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netusergetinfo">NetUserGetInfo</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netusersetinfo">NetUserSetInfo</a>。<br>要操作系统内置帐户的时候不应该假设管理员是<code>Administrator</code>，游客是<code>Guest</code>，而应该调用相关函数获取。</p><p><br>微软预定义了很多 SID，结合这些 SID，再通过 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lookupaccountsidw">LookupAccountSid</a> 函数即可获取帐户名和域名称。<br>预定义 SID 需要通过 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/securitybaseapi/nf-securitybaseapi-createwellknownsid">CreateWellKnownSid</a> 函数创建，它的第一个参数指向 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ne-winnt-well_known_sid_type">WELL_KNOWN_SID_TYPE</a> 枚举类型，这就是预定义的 SID 类型标识符。<br>其中内置管理员帐户对应的值是<code>WinAccountAdministratorSid</code>，来宾帐户对应的值是<code>WinAccountGuestSid</code>。</p><p><br>当我尝试这样调用时，总是返回错误码 87</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD cbSid = <span class="number">0</span>;</span><br><span class="line">BOOL bSuccess = <span class="built_in">CreateWellKnownSid</span>(WinAccountGuestSid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;cbSid);</span><br><span class="line">DWORD dwErr = <span class="built_in">GetLastError</span>(); <span class="comment">// 错误 87</span></span><br></pre></td></tr></table></figure><p>我在这里卡了几个小时，最终发现第2个参数不能为空，必须填写本机域 SID。<br>我们只需要将计算机名称传递给 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lookupaccountnamew">LookupAccountName</a> 函数即可查询到其 SID。<br>得到了内置帐户 SID 后就可以通过 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lookupaccountsidw">LookupAccountSid</a> 取到帐户名了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>获取系统内置帐户名的流程如下：</p><ol><li>用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getcomputernameexw">GetComputerNameEx</a> 获取计算机名称。</li><li>用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lookupaccountnamew">LookupAccountName</a> 查询域 SID。</li><li>用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/securitybaseapi/nf-securitybaseapi-createwellknownsid">CreateWellKnownSid</a> 创建帐户 SID。</li><li>用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lookupaccountsidw">LookupAccountSid</a> 查询帐户名称。</li></ol><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-server/identity/ad-ds/manage/understand-security-identifiers">安全标识符</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程方式开启 Windows 共享文件夹</title>
      <link href="/2024/05/13/windows-share-folder/"/>
      <url>/2024/05/13/windows-share-folder/</url>
      
        <content type="html"><![CDATA[<p>每次在一个新系统上想开启共享时总是要进行这样那样的设置，很繁琐。要么就直接在网上找一键共享的批处理脚本或工具。<br>而大多数脚本或工具基本已经无法在 XP 系统上工作了。于是决定自己写一个。</p><h2 id="开启防火墙规则"><a href="#开启防火墙规则" class="headerlink" title="开启防火墙规则"></a>开启防火墙规则</h2><p>新安装好系统时，防火墙默认是开启的，且没有启用<code>文件和打印机共享</code>规则。<br><img src="/images/windows-share-folder/01.webp"><br>在 XP 系统上可以用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/netfw/nf-netfw-inetfwopenports-item">INetFwOpenPorts::Item</a> 方法检索 139 和 445 端口并启用它。<br>而此时会踩到第一个坑，因为这个方法本质上是访问注册表 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile\GloballyOpenPorts\List</code> 中的值，而在一个刚装好的新系统上这个注册表键还不存在，这样就会导致调用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/netfw/nf-netfw-inetfwopenports-item">INetFwOpenPorts::Item</a> 会返回 <code>HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND)</code> 错误。</p><p><br>所以正确做法是直接向注册表写入值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile\GloballyOpenPorts\List]</span><br><span class="line">&quot;139:TCP&quot;=&quot;139:TCP:LocalSubNet:Enabled:@xpsp2res.dll,-22004&quot;</span><br><span class="line">&quot;445:TCP&quot;=&quot;445:TCP:LocalSubNet:Enabled:@xpsp2res.dll,-22005&quot;</span><br></pre></td></tr></table></figure><p>立即生效，不用重启：<br><img src="/images/windows-share-folder/02.webp"></p><h2 id="免密码访问"><a href="#免密码访问" class="headerlink" title="免密码访问"></a>免密码访问</h2><p>防火墙问题解决后，访问会要求输入用户名和密码：<br><img src="/images/windows-share-folder/03.webp"><br>这是因为<code>Guest</code>账户未启用或密码不为空。可以用命令解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user guest /active:yes</span><br><span class="line">net user guest &quot;&quot;</span><br></pre></td></tr></table></figure><p>编程的话用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netusersetinfo">NetUserSetInfo</a> 函数设置。</p><h2 id="拒绝从网络访问这台计算机"><a href="#拒绝从网络访问这台计算机" class="headerlink" title="拒绝从网络访问这台计算机"></a>拒绝从网络访问这台计算机</h2><p><img src="/images/windows-share-folder/04.webp"><br>这是因为安全策略<code>拒绝从网络访问这台计算机</code>中默认包含了<code>Guest</code>用户，需要名单中移除。<br><img src="/images/windows-share-folder/05.webp"></p><p>TODO:</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLog 快速入门</title>
      <link href="/2024/04/25/nlog-tutorial/"/>
      <url>/2024/04/25/nlog-tutorial/</url>
      
        <content type="html"><![CDATA[<p>使用 NLog 需要先进行配置。可以通过文件配置或代码配置。大多数时候都是通过文件来配置。</p><h2 id="配置文件搜索顺序"><a href="#配置文件搜索顺序" class="headerlink" title="配置文件搜索顺序"></a>配置文件搜索顺序</h2><p>程序启动时会依次搜索以下文件，直到搜索到为止：</p><ol><li>标准应用程序配置文件 app.config（例如 <code>myapp.exe.config</code>）。</li><li>应用程序目录中的 <code>myapp.exe.nlog</code>。</li><li>应用程序目录中的 <code>NLog.config</code>。</li><li><code>NLog.dll.nlog</code> 位于 NLog.dll 所在目录中（仅当 NLog 未安装在 GAC 中时）。</li></ol><p><br>从这个顺序可以看出，当有多个项目时可以为每个 exe 独立配置规则，也可以共用一个规则。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在工程目录下创建一个 <code>NLog.config</code> 文件，在 Visual Studio 中选中该文件将属性<code>复制到输出目录</code>改为<code>始终复制</code>或<code>如果较新则复制</code>。<br>一个简单的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nlog</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 日志输出到哪些地方 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name 是目标名称，后面规则中会用到。type 决定了输出位置。其他属性根据 type 有所不同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;logfile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;File&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;basedir&#125;/file.log&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;dbg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Debugger&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 日志输出规则 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- minlevel 是命中级别，该级别及以上才会命中。writeTo 是写入哪个目标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">minlevel</span>=<span class="string">&quot;Info&quot;</span> <span class="attr">writeTo</span>=<span class="string">&quot;logfile&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">minlevel</span>=<span class="string">&quot;Debug&quot;</span> <span class="attr">writeTo</span>=<span class="string">&quot;dbg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nlog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NLog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WinFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Logger s_logger = LogManager.GetCurrentClassLogger();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            s_logger.Info(<span class="string">&quot;hello info&quot;</span>);</span><br><span class="line">            s_logger.Debug(<span class="string">&quot;Hello debug&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Application.EnableVisualStyles();</span><br><span class="line">            Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">            Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024-04-25 23:22:03.6134|INFO|WinFormsApp1.Program|hello info</span><br><span class="line">2024-04-25 23:22:03.6344|DEBUG|WinFormsApp1.Program|Hello debug</span><br></pre></td></tr></table></figure><p>日志文件输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-25 23:22:03.6134|INFO|WinFormsApp1.Program|hello info</span><br></pre></td></tr></table></figure><h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h2><p>targets 部分定义日志目标。每个目标都由一个 target 元素表示。每个目标需要两个属性：</p><ul><li>name：目标名称，在 logger 中需要用到。</li><li>type：目标类型，表示日志将写到哪里。</li></ul><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><table><thead><tr><th>目标</th><th>说明</th><th>文档</th></tr></thead><tbody><tr><td>Chainsaw</td><td>将日志消息发送到 Log4J XML Viewer 应用程序的远程实例。</td><td><a href="https://github.com/NLog/NLog/wiki/Chainsaw-target">Wiki</a></td></tr><tr><td>ColoredConsole</td><td>使用可自定义的颜色将日志消息写入控制台。</td><td><a href="https://github.com/NLog/NLog/wiki/ColoredConsole-target">Wiki</a></td></tr><tr><td>Console</td><td>将日志消息写入控制台。</td><td><a href="https://github.com/NLog/NLog/wiki/Console-target">Wiki</a></td></tr><tr><td>Database</td><td>使用ADO.NET提供程序将日志消息写入数据库。数据库操作总是在事务之外执行。</td><td><a href="https://github.com/NLog/NLog/wiki/Database-target">Wiki</a></td></tr><tr><td>DebugSystem</td><td>通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.diagnostics.debug.writeline">Debug.WriteLine</a> 发送日志消息。</td><td><a href="https://github.com/NLog/NLog/wiki/DebugSystem-target">Wiki</a></td></tr><tr><td>Debug</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Debug-target">Wiki</a></td></tr><tr><td>Debugger</td><td>将日志消息写入附加的托管调试器。</td><td><a href="https://github.com/NLog/NLog/wiki/Debugger-target">Wiki</a></td></tr><tr><td>EventLog</td><td>将日志消息写入Windows事件日志。</td><td><a href="https://github.com/NLog/NLog/wiki/EventLog-target">Wiki</a></td></tr><tr><td>File</td><td>将日志消息写入一个或多个文件。</td><td><a href="https://github.com/NLog/NLog/wiki/File-target">Wiki</a></td></tr><tr><td>LogReceiverService</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/LogReceiverService-target">Wiki</a></td></tr><tr><td>Mail</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Mail-target">Wiki</a></td></tr><tr><td>Memory</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Memory-target">Wiki</a></td></tr><tr><td>MethodCall</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/MethodCall-target">Wiki</a></td></tr><tr><td>Network</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Network-target">Wiki</a></td></tr><tr><td>NLogViewer</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/NLogViewer-target">Wiki</a></td></tr><tr><td>Null</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Null-target">Wiki</a></td></tr><tr><td>OutputDebugString</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/OutputDebugString-target">Wiki</a></td></tr><tr><td>PerfCounter</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/PerfCounter-target">Wiki</a></td></tr><tr><td>Trace</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/Trace-target">Wiki</a></td></tr><tr><td>WebService</td><td></td><td><a href="https://github.com/NLog/NLog/wiki/WebService-target">Wiki</a></td></tr></tbody></table><p><br>每个 target 都有自己的配置属性，查看官方 Wiki 即可。其中用的最多的当然还是 <a href="https://github.com/NLog/NLog/wiki/File-target">File target</a> 了。<br>注意，某些 target 还需要按照依赖包才会生效。</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><code>laytou</code> 属性默认值是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;longdate&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message:withexception=true&#125;</span><br></pre></td></tr></table></figure><p>输出的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-27 13:40:17.5794|TRACE|WindowsFormsApp.Program|start</span><br></pre></td></tr></table></figure><p>简单说，<code>layout</code>就是由一系列的内置变量组合而成的。</p><table><thead><tr><th>变量</th><th>示例</th><th>说明</th><th>文档</th></tr></thead><tbody><tr><td>${shortdate}</td><td>2024-04-27</td><td>当前日期</td><td><a href="https://github.com/NLog/NLog/wiki/ShortDate-Layout-Renderer">Wiki</a></td></tr><tr><td>${time}</td><td>14:08:04.4274</td><td>当前时间</td><td><a href="https://github.com/NLog/NLog/wiki/Time-Layout-Renderer">Wiki</a></td></tr><tr><td>${date}</td><td>2024&#x2F;04&#x2F;27 14:04:02.735</td><td>当前日期时间（短）</td><td><a href="https://github.com/NLog/NLog/wiki/Date-layout-renderer">Wiki</a></td></tr><tr><td>${longdate}</td><td>2024-04-27 13:49:06.1412</td><td>当前日期时间（长）</td><td><a href="https://github.com/NLog/NLog/wiki/Longdate-Layout-Renderer">Wiki</a></td></tr><tr><td>${ticks}</td><td>638498236261006047</td><td>当前日期和时间的刻度值</td><td><a href="https://github.com/NLog/NLog/wiki/Ticks-Layout-Renderer">Wiki</a></td></tr><tr><td>${level}</td><td>TRACE</td><td>日志级别</td><td><a href="https://github.com/NLog/NLog/wiki/Level-layout-renderer">Wiki</a></td></tr><tr><td>${logger}</td><td>WindowsFormsApp.Program</td><td>记录器名称</td><td><a href="https://github.com/NLog/NLog/wiki/Logger-Layout-Renderer">Wiki</a></td></tr><tr><td>${message}</td><td></td><td>日志内容</td><td><a href="https://github.com/NLog/NLog/wiki/Message-Layout-Renderer">Wiki</a></td></tr><tr><td>${callsite}</td><td>WindowsFormsApp.Program.Main</td><td>调用站点。可包含函数名、源文件等信息</td><td><a href="https://github.com/NLog/NLog/wiki/Callsite-layout-renderer">Wiki</a></td></tr><tr><td>${appdomain}</td><td>0001:WindowsFormsApp.exe</td><td>应用程序域</td><td><a href="https://github.com/NLog/NLog/wiki/AppDomain-Layout-Renderer">Wiki</a></td></tr><tr><td>${appsetting}</td><td></td><td>应用程序设置配置</td><td><a href="https://github.com/NLog/NLog/wiki/AppSetting-Layout-Renderer">Wiki</a></td></tr><tr><td>${assembly-version}</td><td>1.0.0.0</td><td>程序集版本</td><td><a href="https://github.com/NLog/NLog/wiki/AssemblyVersion-Layout-Renderer">Wiki</a></td></tr><tr><td>${gc}</td><td>1291536</td><td>垃圾收集器的信息</td><td><a href="https://github.com/NLog/NLog/wiki/Gc-layout-renderer">Wiki</a></td></tr><tr><td>${hostname}</td><td>DESKTOP-XXXX</td><td>计算机名</td><td><a href="https://github.com/NLog/NLog/wiki/HostName-Layout-Renderer">Wiki</a></td></tr><tr><td>${machinename</td><td>DESKTOP-XXXX</td><td>运行进程的计算机名</td><td><a href="https://github.com/NLog/NLog/wiki/Machinename-Layout-Renderer">Wiki</a></td></tr><tr><td>${local-ip}</td><td>169.254.227.96</td><td>本地IP地址</td><td><a href="https://github.com/NLog/NLog/wiki/Local-IP-Address-Layout-Renderer">Wiki</a></td></tr><tr><td>${processid}</td><td>14476</td><td>进程ID</td><td><a href="https://github.com/NLog/NLog/wiki/ProcessId-Layout-Renderer">Wiki</a></td></tr><tr><td>${processname}</td><td>WindowsFormsApp</td><td>进程名称</td><td><a href="https://github.com/NLog/NLog/wiki/Processname-Layout-Renderer">Wiki</a></td></tr><tr><td>${processdir}</td><td>D:\MyApp</td><td>进程目录</td><td><a href="https://github.com/NLog/NLog/wiki/ProcessDir-Layout-Renderer">Wiki</a></td></tr><tr><td>${processinfo}</td><td></td><td>进程信息。默认显示进程ID</td><td><a href="https://github.com/NLog/NLog/wiki/ProcessInfo-Layout-Renderer">Wiki</a></td></tr><tr><td>${processtime}</td><td>00:00:04.836</td><td>进程启动以来的时间</td><td><a href="https://github.com/NLog/NLog/wiki/ProcessTime-Layout-Renderer">Wiki</a></td></tr><tr><td>${threadname}</td><td></td><td>线程名称</td><td><a href="https://github.com/NLog/NLog/wiki/ThreadName-Layout-Renderer">Wiki</a></td></tr><tr><td>${threadid}</td><td></td><td>线程ID</td><td><a href="https://github.com/NLog/NLog/wiki/ThreadId-Layout-Renderer">Wiki</a></td></tr><tr><td>${basedir}</td><td>D:\MyApp</td><td>应用程序的位置</td><td><a href="https://github.com/NLog/NLog/wiki/Basedir-layout-renderer">Wiki</a></td></tr><tr><td>${currentdir}</td><td>D:\MyApp</td><td>工作路径</td><td><a href="https://github.com/NLog/NLog/wiki/CurrentDir-Layout-Renderer">Wiki</a></td></tr><tr><td>${specialfolder}</td><td></td><td>系统特殊文件夹路径</td><td><a href="https://github.com/NLog/NLog/wiki/Special-Folder-Layout-Renderer">Wiki</a></td></tr><tr><td>${tempdir}</td><td></td><td>系统临时目录</td><td><a href="https://github.com/NLog/NLog/wiki/TempDir-Layout-Renderer">Wiki</a></td></tr><tr><td>${environment}</td><td></td><td>环境变量</td><td><a href="https://github.com/NLog/NLog/wiki/Environment-layout-renderer">Wiki</a></td></tr><tr><td>${registry}</td><td></td><td>注册表值</td><td><a href="https://github.com/NLog/NLog/wiki/Registry-Layout-Renderer">Wiki</a></td></tr><tr><td>${pad}</td><td></td><td>将填充应用于另一个布局输出</td><td><a href="https://github.com/NLog/NLog/wiki/Pad-Layout-Renderer">Wiki</a></td></tr></tbody></table><p><br>常用的一般就是进程、线程信息了。还有其他一些高级用法可以参考官方文档。<br>另外注意，某些变量需要依赖扩展包，否则不会生效。</p><p><br>我个人喜欢的一个布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;longdate&#125; [$&#123;level:uppercase=true:padding=5&#125;] [$&#123;threadid&#125;] [$&#123;logger&#125;] $&#123;message&#125;</span><br></pre></td></tr></table></figure><p>在默认的布局上对齐日志级别以及加入线程ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-27 15:03:14.0145 [TRACE] [1] [WindowsFormsApp.Program] Hello</span><br></pre></td></tr></table></figure><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>rules 部分控制什么级别的日志输出到什么 target。一些例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nlog</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 匹配任何名称的记录器，Info 级及以上日志输出到 logfile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">minlevel</span>=<span class="string">&quot;Info&quot;</span> <span class="attr">writeTo</span>=<span class="string">&quot;logfile&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Trace 日志输出到 logfile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;Trace&quot;</span>  <span class="attr">writeTo</span>=<span class="string">&quot;logfile&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 禁用的记录器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;mylog&quot;</span> <span class="attr">levels</span>=<span class="string">&quot;Warn,Error&quot;</span> <span class="attr">enabled</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nlog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>NLog 会自上而下去尝试匹配每个 logger，匹配到了就打印日志到 target，除非遇到了 final 属性，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">minlevel</span>=<span class="string">&quot;Trace&quot;</span> <span class="attr">writeTo</span>=<span class="string">&quot;logfile&quot;</span> <span class="attr">final</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">minlevel</span>=<span class="string">&quot;Trace&quot;</span>  <span class="attr">writeTo</span>=<span class="string">&quot;dbgSys&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>final</code>属性会阻止 NLog 继续向下匹配，所以这个例子只会将日志输出到 logfile target。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>匹配记录器对象的记录器名称，可以包含通配符（<code>*</code>和<code>?</code>）。<br>创建 NLog 记录器对象时，必须提供类似 <code>NLog.LogManager.GetLogger(&quot;logger name&quot;)</code> 的记录器名称。还可以使用 <code>NLog.LogManager.GetCurrentClassLogger()</code> 从类上下文中提取记录器名称。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> logger = LogManager.GetCurrentClassLogger();</span><br><span class="line">        <span class="comment">// 等于 var logger = LogManager.GetLogger(typeof(Program).FullName);</span></span><br><span class="line"></span><br><span class="line">        Application.EnableVisualStyles();</span><br><span class="line">        Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">        Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录器级别过滤器"><a href="#记录器级别过滤器" class="headerlink" title="记录器级别过滤器"></a>记录器级别过滤器</h3><p>如果规则包含多个级别声明属性（ level 、 levels 、 minlevel 和 maxlevel ），则仅包含第一个级别声明使用属性或集合，其余的将被忽略。<br>级别声明属性按以下顺序处理：</p><ol><li>levels</li><li>level</li><li>minlevel 和 maxlevel （它们具有相同的优先级）</li></ol><p><br>注意这里是我测试过的排序，与官方文档中的优先级不同（NLog v5.2.8）。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://github.com/NLog/NLog/wiki/Tutorial/">Tutorial</a><br><a href="https://github.com/NLog/NLog/wiki/Configuration-file/">Configuration file</a><br><a href="https://github.com/NLog/NLog/wiki/Configure-from-code">Configure from code</a><br><a href="https://github.com/NLog/NLog/wiki/Layouts">Layouts</a><br><a href="https://www.cnblogs.com/shieryoufeng/p/17788734.html">Nlog笔记</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> NLog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET 项目 SDK 介绍</title>
      <link href="/2024/04/21/msbuild-project-sdk/"/>
      <url>/2024/04/21/msbuild-project-sdk/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>.NET 项目基于 MSBuild 格式。 项目文件的根元素是 Project 元素。 Project 元素有一个可选的 Sdk 属性，该属性指定要使用的 SDK（和版本）。 若要使用 .NET 工具并构建你的代码，请将 Sdk 属性设置为可用 SDK 表中的其中一个 ID。</p><h2 id="引用-Sdk"><a href="#引用-Sdk" class="headerlink" title="引用 Sdk"></a>引用 Sdk</h2><p>常见的引用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这等价于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Sdk</span> <span class="attr">Name</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MSBuild 会在顶部和底部导入<code>Sdk.props</code>和<code>Sdk.targets</code>，实际在背后文件是这样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;Sdk.props&quot;</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;Sdk.targets&quot;</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/sdk/Sdk.props">Sdk.props</a> 和 <a href="https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/sdk/Sdk.NuGet.targets">Sdk.targets</a> 文件位于计算机中的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%ProgramFiles%\dotnet\sdk\[version]\Sdks\Microsoft.NET.Sdk\Sdk</span><br></pre></td></tr></table></figure><p>SDK 有哪些可用值可以参考<a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/overview#available-sdks">官方文档</a></p><h2 id="Sdk-props"><a href="#Sdk-props" class="headerlink" title="Sdk.props"></a>Sdk.props</h2><p><a href="https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/sdk/Sdk.props">Sdk.props</a> 是项目导入的第一个文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">***********************************************************************************************</span></span><br><span class="line"><span class="comment">Sdk.props</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have</span></span><br><span class="line"><span class="comment">          created a backup copy.  Incorrect changes to this file will make it</span></span><br><span class="line"><span class="comment">          impossible to load or build your projects from the command-line or the IDE.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Copyright (c) .NET Foundation. All rights reserved.</span></span><br><span class="line"><span class="comment">***********************************************************************************************</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">_AfterSdkPublishDependsOn</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(_IsAspNetCoreProject)&#x27; == &#x27;true&#x27;&quot;</span>&gt;</span>AfterPublish<span class="tag">&lt;/<span class="name">_AfterSdkPublishDependsOn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">_AfterSdkPublishDependsOn</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(_IsAspNetCoreProject)&#x27; != &#x27;true&#x27;&quot;</span>&gt;</span>Publish<span class="tag">&lt;/<span class="name">_AfterSdkPublishDependsOn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;AfterSdkPublish&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;$(_AfterSdkPublishDependsOn)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Indicate to other targets that Microsoft.NET.Sdk is being used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      This must be set here (as early as possible, before Microsoft.Common.props)</span></span><br><span class="line"><span class="comment">      so that everything that follows can depend on it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In particular, Directory.Build.props and nuget package props need to be able</span></span><br><span class="line"><span class="comment">      to use this flag and they are imported by Microsoft.Common.props.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UsingMicrosoftNETSdk</span>&gt;</span>true<span class="tag">&lt;/<span class="name">UsingMicrosoftNETSdk</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Indicate whether the set of SDK defaults that makes SDK style project concise are being used.</span></span><br><span class="line"><span class="comment">      For example: globbing, importing msbuild common targets.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Similar to the property above, it must be set here.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UsingNETSdkDefaults</span>&gt;</span>true<span class="tag">&lt;/<span class="name">UsingNETSdkDefaults</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomAfterDirectoryBuildProps</span>&gt;</span>$(CustomAfterDirectoryBuildProps);$(MSBuildThisFileDirectory)UseArtifactsOutputPath.props<span class="tag">&lt;/<span class="name">CustomAfterDirectoryBuildProps</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(MSBuildProjectFullPath)&#x27; == &#x27;$(ProjectToOverrideProjectExtensionsPath)&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MSBuildProjectExtensionsPath</span>&gt;</span>$(ProjectExtensionsPathForSpecifiedProject)<span class="tag">&lt;/<span class="name">MSBuildProjectExtensionsPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(AlternateCommonProps)&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(AlternateCommonProps)&#x27; != &#x27;&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(AlternateCommonProps)&#x27; == &#x27;&#x27;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.props&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有个 <a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/customize-net-builds#replace-common-props-file">AlternateCommonProps</a> 属性值得留意一下，它可以用来替换接下来即将导入的 <a href="https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.props">Microsoft.Common.props</a> 文件，不过一般情况下用不到。</p><h2 id="Microsoft-Common-props"><a href="#Microsoft-Common-props" class="headerlink" title="Microsoft.Common.props"></a>Microsoft.Common.props</h2><p><a href="https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.props">Microsoft.Common.props</a> 是第二个导入的文件，包含了一些初始化导入和钩子。<br>比如：</p><ul><li><code>Directory.Build.props</code>文件就是在这里导入的。</li><li><code>&lt;ImportDirectoryBuildProps&gt;</code>属性可以决定是否导入<code>Directory.Build.props</code>。</li><li><code>&lt;CustomBeforeDirectoryBuildProps&gt;</code>在<code>Directory.Build.props</code>之前导入。</li><li><code>&lt;CustomAfterDirectoryBuildProps&gt;</code>在<code>Directory.Build.props</code>之后导入。</li><li>设置了中间目录<code>&lt;BaseIntermediateOutputPath&gt;</code>。</li></ul><p><br>从这个文件中可以看出，如果我们需要禁止导入<code>Directory.Build.props</code>文件或设置中间目录，就必须在<code>Microsoft.Common.props</code>导入前就设置好，那么引用 Sdk 时必须显示导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImportDirectoryBuildProps</span>&gt;</span>false<span class="tag">&lt;/<span class="name">ImportDirectoryBuildProps</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BaseIntermediateOutputPath</span>&gt;</span>obj2\<span class="tag">&lt;/<span class="name">BaseIntermediateOutputPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;Sdk.props&quot;</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;Sdk.targets&quot;</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="预处理项目文件"><a href="#预处理项目文件" class="headerlink" title="预处理项目文件"></a>预处理项目文件</h2><p>使用<code>dotnet msbuild -preprocess</code>命令，可以看到 MSBuild 在包含 SDK 及其目标之后所显示的完全扩展的项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet msbuild -preprocess:output.xml</span><br></pre></td></tr></table></figure><p>我们便可以分析输出的 xml 文件，大概是一个几千行的项目文件，自上而下导入了各种 .props 和 .targets 文件，这有利于我们快速排查问题。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/overview/">.NET 项目 SDK</a><br><a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/how-to-use-project-sdk/">使用 MSBuild 项目 SDK</a><br><a href="https://github.com/dotnet/msbuild/issues/2767">Document the import order of the common msbuild extension points.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MSBuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET DLL 的入口点</title>
      <link href="/2024/04/20/net-dll-entrypoint/"/>
      <url>/2024/04/20/net-dll-entrypoint/</url>
      
        <content type="html"><![CDATA[<p>在用开发 DLL 模块时，DLL 往往需要知道自身何时被加载，以便初始化资源。<br>在非托管 DLL 开发中，是有 <a href="https://learn.microsoft.com/zh-cn/windows/win32/dlls/dllmain">DllMain</a> 入口点函数的，在这里可以处理初始化、卸载等操作。<br>而在 .NET 中，DLL 和 EXE 都被称作为 <a href="https://learn.microsoft.com/zh-cn/dotnet/standard/assembly/">程序集</a>，程序集之间可以相互调用，无论是 EXE 或 DLL，这是与 Win32 开发中很大的一个不同之处。<br>而 DLL 程序集是没有入口点(<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.entrypoint">EntryPoint</a>)属性的。<br><br>那么如何解决 DLL 的初始化问题呢？<br>可以提供一个静态初始化方法，要求使用者必须先调用该方法进行 DLL 的初始化。但是这种解决方案一点都不酷。</p><p>在 .NET 程序集中，EXE 是有入口点(<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.entrypoint">EntryPoint</a>)属性的，那么我们可以将工程改为 EXE，并将文件后缀名改为 <code>.dll</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>WinExe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetExt</span>&gt;</span>.dll<span class="tag">&lt;/<span class="name">TargetExt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 EXE 的入口处调用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.appdomain.executeassembly">AppDomain.ExecuteAssembly</a> 方法进行 DLL 的初始化即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppDomain.CurrentDomain.ExecuteAssembly(<span class="string">&quot;MyDll.dll&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="模块初始化器"><a href="#模块初始化器" class="headerlink" title="模块初始化器"></a>模块初始化器</h2><p>从 .NET 5 开始，提供了 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.moduleinitializerattribute">ModuleInitializerAttribute</a> 属性来标注模块的初始化方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyInitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ModuleInitializer</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在加载模块时执行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，无需显式调用初始化方法，初始化操作会在DLL被加载时自动执行。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://stackoverflow.com/questions/9577567/">Can a C# .dll assembly contain an entry point?</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/module-initializers">Module Initializers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Directory.Build.targets 无法覆盖 OutputPath 属性</title>
      <link href="/2024/04/18/msbuild-outputpath/"/>
      <url>/2024/04/18/msbuild-outputpath/</url>
      
        <content type="html"><![CDATA[<p>在管理多个工程时，通常需要根据工程的属性并按照指定的规则来决定二进制文件的输出位置。第一直觉是在<code>Directory.Build.targets</code>文件中设置<code>OutputPath</code>属性。<br>然而实测发现<code>Directory.Build.targets</code>文件中的<code>OutputPath</code>并未生效。<br>Google 一番后找到两种解决办法。</p><h2 id="BeforeTargetFrameworkInferenceTargets-属性"><a href="#BeforeTargetFrameworkInferenceTargets-属性" class="headerlink" title="BeforeTargetFrameworkInferenceTargets 属性"></a>BeforeTargetFrameworkInferenceTargets 属性</h2><p>这个属性出现在 <a href="https://github.com/dotnet/sdk/blob/14b117b7088653b694e16ac2071fcbf634a2a9ab/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.TargetFrameworkInference.targets#L47">Microsoft.NET.TargetFrameworkInference.targets</a> 文件中，并没有官方的文档。<br>我们可以在<code>Directory.Build.props</code>中设置它：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BeforeTargetFrameworkInferenceTargets</span>&gt;</span>$(MSBuildThisFileDirectory)OutputBuild.props<span class="tag">&lt;/<span class="name">BeforeTargetFrameworkInferenceTargets</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<code>OutputBuild.props</code>中覆盖<code>OutputPath</code>，这里是可以使用自定义属性的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputPath</span>&gt;</span>bin\$(Foo)<span class="tag">&lt;/<span class="name">OutputPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="props-和-targets-文件之前和之后"><a href="#props-和-targets-文件之前和之后" class="headerlink" title=".props 和 .targets 文件之前和之后"></a>.props 和 .targets 文件之前和之后</h2><p>比起没有文档的<code>BeforeTargetFrameworkInferenceTargets</code>属性，MSBuild 提供了一系列”钩子”属性，可以在<code>Microsoft.Common.Props</code>或<code>Microsoft.Common.Targets</code>文件的前后执行。</p><ul><li>CustomBeforeMicrosoftCommonProps</li><li>CustomBeforeMicrosoftCommonTargets</li><li>CustomAfterMicrosoftCommonProps</li><li>CustomAfterMicrosoftCommonTargets</li><li>CustomBeforeMicrosoftCSharpTargets</li><li>CustomBeforeMicrosoftVisualBasicTargets</li><li>CustomAfterMicrosoftCSharpTargets</li><li>CustomAfterMicrosoftVisualBasicTargets</li></ul><p><br>从名字上看，我们只关心前面四个。测试一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomBeforeMicrosoftCommonProps</span>&gt;</span>$(MSBuildThisFileDirectory)BeforeMicrosoftCommon.props<span class="tag">&lt;/<span class="name">CustomBeforeMicrosoftCommonProps</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomAfterMicrosoftCommonProps</span>&gt;</span>$(MSBuildThisFileDirectory)AfterMicrosoftCommon.props<span class="tag">&lt;/<span class="name">CustomAfterMicrosoftCommonProps</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomBeforeMicrosoftCommonTargets</span>&gt;</span>$(MSBuildThisFileDirectory)BeforeMicrosoftCommon.targets<span class="tag">&lt;/<span class="name">CustomBeforeMicrosoftCommonTargets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomAfterMicrosoftCommonTargets</span>&gt;</span>$(MSBuildThisFileDirectory)AfterMicrosoftCommon.targets<span class="tag">&lt;/<span class="name">CustomAfterMicrosoftCommonTargets</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这四个文件的载入顺序是：</p><ol><li>CustomBeforeMicrosoftCommonProps。可覆盖<code>OutputPath</code>属性，但不可以使用工程的自定义属性。</li><li>CustomAfterMicrosoftCommonProps。可覆盖<code>OutputPath</code>属性，但不可以使用工程的自定义属性。</li><li>CustomBeforeMicrosoftCommonTargets。可使用工程的自定义属性。</li><li>CustomAfterMicrosoftCommonTargets。无法覆盖<code>OutputPath</code>属性。</li></ol><p><br>所以，我们有机会在<code>CustomBeforeMicrosoftCommonTargets</code>中覆盖<code>OutputPath</code>属性。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://github.com/dotnet/msbuild/discussions/7669">setting OutputPath in a Directory.Build.targets</a><br><a href="https://nietras.com/2022/01/24/bendingdotnet-improved-common-flat-build-output/">Bending .NET - Improved Common Flat Build Output</a><br><a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/customize-net-builds">自定义所有 .NET 生成</a><br><a href="https://github.com/dotnet/msbuild/issues/2767">Document the import order of the common msbuild extension points.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> MSBuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET 获取 EXE 所在目录的方法</title>
      <link href="/2024/04/15/net-get-exedir/"/>
      <url>/2024/04/15/net-get-exedir/</url>
      
        <content type="html"><![CDATA[<p>获取 EXE 所在目录可以先获取 EXE 完整路径，再提取出目录。不过本文不讲，因为有内置方法可以直接获取目录。<br>.NET 中有5种方式获取 EXE 目录，先看看例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug.WriteLine(<span class="string">&quot;Directory.GetCurrentDirectory(): &quot;</span> + Directory.GetCurrentDirectory());</span><br><span class="line">Debug.WriteLine(<span class="string">&quot;Environment.CurrentDirectory: &quot;</span> + Environment.CurrentDirectory);</span><br><span class="line">Debug.WriteLine(<span class="string">&quot;AppDomain.CurrentDomain.BaseDirectory:&quot;</span> + AppDomain.CurrentDomain.BaseDirectory);</span><br><span class="line">Debug.WriteLine(<span class="string">&quot;AppDomain.CurrentDomain.SetupInformation.ApplicationBase: &quot;</span> + AppDomain.CurrentDomain.SetupInformation.ApplicationBase);</span><br><span class="line">Debug.WriteLine(<span class="string">&quot;Application.StartupPath: &quot;</span> + Application.StartupPath);</span><br></pre></td></tr></table></figure><p>双击方式启动 EXE，得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Directory.GetCurrentDirectory(): C:\dir</span><br><span class="line">Environment.CurrentDirectory: C:\dir</span><br><span class="line">AppDomain.CurrentDomain.BaseDirectory:C:\dir\</span><br><span class="line">AppDomain.CurrentDomain.SetupInformation.ApplicationBase:C:\dir\</span><br><span class="line">Application.StartupPath: C:\dir</span><br></pre></td></tr></table></figure><p>再将起始位置切换到其他目录，用 CMD 方式启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:</span><br><span class="line">C:\dir\demo.exe</span><br></pre></td></tr></table></figure><p>这样启动，工作目录就是<code>C:\</code>，得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Directory.GetCurrentDirectory(): C:\ </span><br><span class="line">Environment.CurrentDirectory: C:\ </span><br><span class="line">AppDomain.CurrentDomain.BaseDirectory: c:\dir\ </span><br><span class="line">AppDomain.CurrentDomain.SetupInformation.ApplicationBase: c:\dir\ </span><br><span class="line">Application.StartupPath: c:\dir </span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.io.directory.getcurrentdirectory">Directory.GetCurrentDirectory</a> 和 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.environment.currentdirectory">Environment.CurrentDirectory</a> 返回的是工作目录，不符合预期。<br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.startuppath">Application.StartupPath</a> 是 WinForms 程序特定属性，不是最优选择。<br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.appdomainsetup.applicationbase">AppDomainSetup.ApplicationBase</a> 属性可修改，不可靠。<br>最后就只剩下 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.appdomain.basedirectory">AppDomain.CurrentDomain.BaseDirectory</a> 了，是一个只读属性，不依赖 WinForms，推荐使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET 中的未处理异常</title>
      <link href="/2024/04/14/net-unhandledexception/"/>
      <url>/2024/04/14/net-unhandledexception/</url>
      
        <content type="html"><![CDATA[<p>在 .NET 中，如果主线程发生了一个异常而未被<code>try/catch</code>捕获的话则会弹出一个错误对话框，报告该异常的信息：<br><img src="/images/net-unhandledexception/01.webp"><br>用户可以点击<code>详细信息</code>按钮，将其中的内容提供给开发者，帮助开发者排查问题。同时允许用户继续运行程序。</p><h2 id="未处理异常事件"><a href="#未处理异常事件" class="headerlink" title="未处理异常事件"></a>未处理异常事件</h2><p>在 .NET 中，有两个事件可以处理未处理异常：</p><ol><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.threadexception">Application.ThreadException</a>。仅适用于 WinForms 程序，只能处理主线程异常，且程序可以继续运行。</li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.appdomain.unhandledexception">AppDomain.UnhandledException</a>。</li></ol><p><br>两者的区别很明显，ThreadException 是 WinForms 程序特定的，只处理 UI 线程的异常，并且程序允许不退出。<br>而 UnhandledException 是真正意义上的未处理异常处理事件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">STAThread</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ThreadException += ApplicationOnThreadException;</span><br><span class="line">        AppDomain.CurrentDomain.UnhandledException += CurrentDomainOnUnhandledException;</span><br><span class="line"></span><br><span class="line">        Application.EnableVisualStyles();</span><br><span class="line">        Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDomainOnUnhandledException</span>(<span class="params"><span class="built_in">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;UnhandledException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ApplicationOnThreadException</span>(<span class="params"><span class="built_in">object</span> sender, ThreadExceptionEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;ThreadException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置异常处理模式"><a href="#设置异常处理模式" class="headerlink" title="设置异常处理模式"></a>设置异常处理模式</h2><p>通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.setunhandledexceptionmode">Application.SetUnhandledExceptionMode</a> 方法指定异常处理模式。<br>参数是一个 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.unhandledexceptionmode">UnhandledExceptionMode</a> 类型。</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>Automatic</td><td>将所有异常都传送到 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.threadexception">ThreadException</a> 处理程序，除非应用程序的配置文件指定了其他位置。</td></tr><tr><td>ThrowException</td><td>从不将异常传送到 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.threadexception">ThreadException</a> 处理程序。 忽略应用程序配置文件。</td></tr><tr><td>CatchException</td><td>始终将异常传送到 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.application.threadexception">ThreadException</a> 处理程序。 忽略应用程序配置文件。</td></tr></tbody></table><p><br>简单说，<strong>处理模式就是决定主线程异常要不要交给 UnhandledException 事件处理</strong>。</p><h3 id="通过配置文件指定异常处理模式"><a href="#通过配置文件指定异常处理模式" class="headerlink" title="通过配置文件指定异常处理模式"></a>通过配置文件指定异常处理模式</h3><p>这些选项都提到了应用程序配置文件，用文件是这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.windows.forms</span> <span class="attr">jitDebugging</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置等同于在程序中使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.SetUnhandledExceptionMode(UnhandledExceptionMode.ThrowException);</span><br></pre></td></tr></table></figure><p><strong>不过这个配置文件选项只有在没有指定 ThreadException 处理程序时有效</strong>。<br>看一个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123; </span><br><span class="line">    Application.SetUnhandledExceptionMode(UnhandledExceptionMode.Automatic); <span class="comment">// Automatic 是默认值</span></span><br><span class="line">    AppDomain.CurrentDomain.UnhandledException += CurrentDomainOnUnhandledException;</span><br><span class="line"></span><br><span class="line">    Application.EnableVisualStyles();</span><br><span class="line">    Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDomainOnUnhandledException</span>(<span class="params"><span class="built_in">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;UnhandledException&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Automatic 的作用，未处理异常应该在 ThreadException 中处理，但由于配置了<code>&lt;system.windows.forms jitDebugging=&quot;true&quot;/&gt;</code>，导致异常交给了 UnhandledException 来处理。<br>如果想忽略配置文件的设置，应该将模式改为<code>UnhandledExceptionMode.CatchException</code>。<br>对于这个文件配置，了解一下即可，几乎不会用到。</p><h2 id="legacyUnhandledExceptionPolicy"><a href="#legacyUnhandledExceptionPolicy" class="headerlink" title="legacyUnhandledExceptionPolicy"></a>legacyUnhandledExceptionPolicy</h2><p><code>legacyUnhandledExceptionPolicy</code>配置可以防止工作线程未处理异常后强制退出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">runtime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legacyUnhandledExceptionPolicy</span> <span class="attr">enabled</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ThreadException 这个名字有点迷惑，实际它就是主线程异常处理事件。</li><li>对于异常处理模式，Automatic 是默认值，不需要显示指定。CatchException 和 Automatic 作用相同，只是忽略配置文件，而配置文件基本不会用到，所以当我们要显示指定处理模式时，基本就是设置为 ThrowException。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://stackoverflow.com/questions/2014562">Application.ThreadException 和 AppDomain.CurrentDomain.UnhandledException 之间有什么区别？</a><br><a href="https://stackoverflow.com/questions/545760/">当 UnhandledExceptionMode 设置为 UnhandledExceptionMode.Automatic 时，哪个 .config 元素会影响异常处理？</a><br><a href="https://blog.walterlv.com/post/prevent-app-crash-by-background-thread.html">配置 legacyUnhandledExceptionPolicy 防止后台线程抛出的异常让程序崩溃退出</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VC 运行时安装包</title>
      <link href="/2024/04/14/vc-redist/"/>
      <url>/2024/04/14/vc-redist/</url>
      
        <content type="html"><![CDATA[<h2 id="VS2015-VS2022-VC17"><a href="#VS2015-VS2022-VC17" class="headerlink" title="VS2015 - VS2022 (VC17)"></a>VS2015 - VS2022 (VC17)</h2><p>从某个版本开始，运行时包开始共用了，不像以前每个版本都需要对应一个包。</p><table><thead><tr><th>版本</th><th>x86</th><th>x64</th><th>arm64</th></tr></thead><tbody><tr><td>最新</td><td><a href="https://aka.ms/vs/17/release/vc_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://aka.ms/vs/17/release/vc_redist.x64.exe">VC_redist.x64.exe</a></td><td><a href="https://aka.ms/vs/17/release/vc_redist.arm64.exe">VC_redist.arm64.exe</a></td></tr><tr><td>14.38.33135.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/71c6392f-8df5-4b61-8d50-dba6a525fb9d/510FC8C2112E2BC544FB29A72191EABCC68D3A5A7468D35D7694493BC8593A79/VC_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/c7707d68-d6ce-4479-973e-e2a3dc4341fe/1AD7988C17663CC742B01BEF1A6DF2ED1741173009579AD50A94434E54F56073/VC_redist.x64.exe">VC_redist.x64.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/71c6392f-8df5-4b61-8d50-dba6a525fb9d/9378E04AE461E29CE5E46787D20F81700C80AD305B9417710D147C1D7FF0C970/VC_redist.arm64.exe">VC_redist.arm64.exe</a></td></tr></tbody></table><h2 id="VS2019-VC16"><a href="#VS2019-VC16" class="headerlink" title="VS2019 (VC16)"></a>VS2019 (VC16)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>最新</td><td><a href="https://aka.ms/vs/16/release/vc_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://aka.ms/vs/16/release/vc_redist.x64.exe">VC_redist.x64.exe</a></td></tr><tr><td>14.29.30153.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/9613cb5b-2786-49cd-8d90-73abd90aa50a/29F649C08928B31E6BB11D449626DA14B5E99B5303FE2B68AFA63732EF29C946/VC_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/9613cb5b-2786-49cd-8d90-73abd90aa50a/CEE28F29F904524B7F645BCEC3DFDFE38F8269B001144CD909F5D9232890D33B/VC_redist.x64.exe">VC_redist.x64.exe</a></td></tr></tbody></table><h2 id="VS2017-VC15"><a href="#VS2017-VC15" class="headerlink" title="VS2017 (VC15)"></a>VS2017 (VC15)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>最新</td><td><a href="https://aka.ms/vs/15/release/vc_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://aka.ms/vs/15/release/vc_redist.x64.exe">VC_redist.x64.exe</a></td></tr><tr><td>14.16.27033.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/2b5bcd2f-0dbc-4b83-90a3-3b1c5ae77e62/0252474394129dbab6ff9ce24f1c6a3c/vc_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/4100b84d-1b4d-487d-9f89-1354a7138c8f/5B0CBB977F2F5253B1EBE5C9D30EDBDA35DBD68FB70DE7AF5FAAC6423DB575B5/VC_redist.x64.exe">VC_redist.x64.exe</a></td></tr><tr><td>14.12.25810.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/100349138/88b50ce70017bf10f2d56d60fcba6ab1/VC_redist.x86.exe">VC_redist.x86.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/100349091/2cd2dba5748dc95950a5c42c2d2d78e4/VC_redist.x64.exe">VC_redist.x64.exe</a></td></tr></tbody></table><h2 id="VS2015-VC14"><a href="#VS2015-VC14" class="headerlink" title="VS2015 (VC14)"></a>VS2015 (VC14)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>14.0.23026.0</td><td><a href="https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x86.exe">vcredist_x86.exe</a></td><td><a href="https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe">vcredist_x64.exe</a></td></tr></tbody></table><p><br><a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">Visual C++ Redistributable for Visual Studio 2015</a></p><h2 id="VS2013-VC12"><a href="#VS2013-VC12" class="headerlink" title="VS2013 (VC12)"></a>VS2013 (VC12)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>最新</td><td><a href="https://aka.ms/highdpimfc2013x86chs">vc_redist.x86.exe</a></td><td><a href="https://aka.ms/highdpimfc2013x64chs">vc_redist.x64.exe</a></td></tr><tr><td>12.0.40664.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/10912113/5da66ddebb0ad32ebd4b922fd82e8e25/vcredist_x86.exe">vcredist_x86.exe</a></td><td><a href="https://download.visualstudio.microsoft.com/download/pr/10912041/cee5d6bca2ddbcd039da727bf4acb48a/vcredist_x64.exe">vcredist_x64.exe</a></td></tr></tbody></table><p><br>从 <a href="https://support.microsoft.com/zh-cn/topic/update-for-visual-c-2013-redistributable-package-d8ccd6a5-4e26-c290-517b-8da6cfdf4f10">Update for Visual C++ 2013 Redistributable Package</a> 下载其他语言、架构的包。</p><h2 id="VS2012-Update4-VC11"><a href="#VS2012-Update4-VC11" class="headerlink" title="VS2012 Update4 (VC11)"></a>VS2012 Update4 (VC11)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>11.0.61030.0</td><td><a href="https://download.microsoft.com/download/1/6/B/16B06F60-3B20-4FF2-B699-5E9B7962F9AE/VSU_4/vcredist_x86.exe">vcredist_x86.exe</a></td><td><a href="https://download.microsoft.com/download/1/6/B/16B06F60-3B20-4FF2-B699-5E9B7962F9AE/VSU_4/vcredist_x64.exe">vcredist_x64.exe</a></td></tr></tbody></table><p><br>从 <a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=30679">Visual C++ Redistributable for Visual Studio 2012 Update 4</a> 下载其他语言、架构的包。</p><h2 id="VS2010-SP1-VC10"><a href="#VS2010-SP1-VC10" class="headerlink" title="VS2010 SP1 (VC10)"></a>VS2010 SP1 (VC10)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>10.0.40219.325</td><td><a href="https://download.microsoft.com/download/1/6/5/165255E7-1014-4D0A-B094-B6A430A6BFFC/vcredist_x86.exe">vcredist_x86.exe</a></td><td><a href="https://download.microsoft.com/download/1/6/5/165255E7-1014-4D0A-B094-B6A430A6BFFC/vcredist_x64.exe">vcredist_x64.exe</a></td></tr></tbody></table><p><br>从 <a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=26999">Microsoft Visual C++ 2010 Service Pack 1 Redistributable Package MFC 安全更新</a> 下载其他语言、架构的包。</p><h2 id="VS2008-SP1-VC9"><a href="#VS2008-SP1-VC9" class="headerlink" title="VS2008 SP1 (VC9)"></a>VS2008 SP1 (VC9)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>9.0.30729.5677</td><td><a href="https://download.microsoft.com/download/5/D/8/5D8C65CB-C849-4025-8E95-C3966CAFD8AE/vcredist_x86.exe">vcredist_x86.exe</a></td><td><a href="https://download.microsoft.com/download/5/D/8/5D8C65CB-C849-4025-8E95-C3966CAFD8AE/vcredist_x64.exe">vcredist_x64.exe</a></td></tr></tbody></table><p><br>从 <a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=26368">Microsoft Visual C++ 2008 Service Pack 1 Redistributable Package MFC 安全更新</a> 下载其他语言、架构的包。</p><h2 id="VS2005-SP1-VC8"><a href="#VS2005-SP1-VC8" class="headerlink" title="VS2005 SP1 (VC8)"></a>VS2005 SP1 (VC8)</h2><table><thead><tr><th>版本</th><th>x86</th><th>x64</th></tr></thead><tbody><tr><td>8.0.50727.6195</td><td><a href="https://download.microsoft.com/download/4/A/2/4A22001F-FA3B-4C13-BF4E-42EC249D51C4/vcredist_x86.EXE">vcredist_x86.exe</a></td><td><a href="https://download.microsoft.com/download/8/B/4/8B42259F-5D70-43F4-AC2E-4B208FD8D66A/vcredist_x64.EXE">vcredist_x64.exe</a></td></tr></tbody></table><p><br>从 <a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=26347">Microsoft Visual C++ 2005 Service Pack 1 Redistributable Package MFC 安全更新</a> 下载其他语言、架构的包。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist">Microsoft Visual C++ 可再发行程序包最新支持的下载</a><br><a href="https://www.itechtics.com/microsoft-visual-c-redistributable-versions-direct-download-links/">Download Microsoft Visual C++ Redistributables (All Versions)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinDbg 配置调试服务器</title>
      <link href="/2024/04/11/windbg-remote/"/>
      <url>/2024/04/11/windbg-remote/</url>
      
        <content type="html"><![CDATA[<p>WinDbg 支持远程调试，支持协议：命名管道 (NPIPE)、TCP、COM 端口、安全管道 (SPIPE) 和安全套接字层 (SSL)。<br>如今绝大多数只会用到 COM 和 TCP 通信。走 COM 协议一般是用来调试系统内核，而应用层软件调试基本就是用 TCP。</p><h2 id="用-WinDbg-exe-建立服务器"><a href="#用-WinDbg-exe-建立服务器" class="headerlink" title="用 WinDbg.exe 建立服务器"></a>用 WinDbg.exe 建立服务器</h2><h3 id="启动调试服务器"><a href="#启动调试服务器" class="headerlink" title="启动调试服务器"></a>启动调试服务器</h3><ul><li><p>通过命令行参数启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windbg.exe -server tcp:port=5000</span><br></pre></td></tr></table></figure></li><li><p>通过调试命令启动<br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debuggercmds/-server--create-debugging-server-">.server</a> 用于启动一个调试服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.server tcp:port=5000</span><br></pre></td></tr></table></figure></li></ul><h3 id="连接调试服务器"><a href="#连接调试服务器" class="headerlink" title="连接调试服务器"></a>连接调试服务器</h3><ul><li><p>通过命令行参数连接<br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debuggercmds/-remote--create-remote-exe-server-">.remote</a> 用于连接调试服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windbg.exe -remote tcp:server=192.168.175.134,port=5000</span><br></pre></td></tr></table></figure></li><li><p>通过 WinDbg 图形界面操作<br>按下<code>Ctrl + R</code>打开<code>Connect to Remote Debugger Session</code>窗口并输入调试服务器地址：<br><img src="/images/windbg-remote/01.webp"><br>输入服务器地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp:server=192.168.175.134,port=5000</span><br></pre></td></tr></table></figure></li></ul><h2 id="用-dbgsrv-exe-建立调试服务器"><a href="#用-dbgsrv-exe-建立调试服务器" class="headerlink" title="用 dbgsrv.exe 建立调试服务器"></a>用 dbgsrv.exe 建立调试服务器</h2><p>与 windbg 作为调试服务器的区别是无界面，全程在客户端即可操作。但是要求双方的 windbg 版本一致，否则附加进程列表显示为空。<br>通过命令行参数启动服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbgsrv.exe -t tcp:port=5000</span><br></pre></td></tr></table></figure><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><ul><li><p>客户端通过<code>-premote</code>来连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windbg.exe -premote tcp:server=192.168.175.134,port=5000</span><br></pre></td></tr></table></figure></li><li><p>通过 WinDbg 图形界面操作<br>打开<code>File</code>菜单，选择<code>Connect to Remote Stub...</code>。<br><img src="/images/windbg-remote/02.webp"><br>输入服务器地址，和前面一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp:server=192.168.175.134,port=5000</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>windbg 和 dbgsrv 都可以作为调试服务器，但有些区别：</p><ul><li>windbg 会出现图形界面，双方均可输入调试命令并且操作是同步的。而 dbgsrv 仅在后台工作，调试完全在控制端进行。</li><li>windbg 作为服务器时，符号文件缓存在被控端本地。而用 dbgsrv 时符号文件在控制端。</li><li>windbg 作为服务器时，不要求双方 windbg 的版本一致。而用 dbgsrv 时则要求 windbg 版本一致，否则无法附加程序。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/activating-a-debugging-server">激活调试服务器</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/windbg-command-line-options">WinDbg 命令行选项</a><br><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/dbgsrv-command-line-options">DbgSrv 命令行选项</a><br><a href="https://www.cnblogs.com/kekec/archive/2012/12/02/2798020.html">windbg调试命令</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> WinDbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinDbg 配置符号路径</title>
      <link href="/2024/04/10/windbg-symbols/"/>
      <url>/2024/04/10/windbg-symbols/</url>
      
        <content type="html"><![CDATA[<h2 id="配置符号路径"><a href="#配置符号路径" class="headerlink" title="配置符号路径"></a>配置符号路径</h2><p>使用 WinDbg 的第一件事就是配置符号文件路径，通常有以下方法：</p><ol><li><p>通过 WinDbg 菜单设置<br>打开<code>File</code>菜单，点击<code>Symbol File Path ...</code>打开配置窗口（快捷键为 Ctrl + S）。输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRV*C:\\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure></li><li><p>设置系统环境变量<br>比起在 WinDbg 中设置，我更喜欢用设置环境变量的方式，因为很多开发工具或调试软件都会读取<code>_NT_SYMBOL_PATH</code>环境变量的内容作为符号搜索路径。<br>新建一个<code>_NT_SYMBOL_PATH.reg</code>文件，内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment]</span><br><span class="line">&quot;_NT_SYMBOL_PATH&quot;=&quot;SRV*C:\\Symbols*http://msdl.microsoft.com/download/symbols&quot;</span><br></pre></td></tr></table></figure><p>双击该文件导入到注册表即可。如果未生效的话就注销一下系统重新登录。</p></li><li><p>通过启动参数<br>启动参数<code>-y</code>可以指定符号路径，仅本次运行生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windbg -y &quot;SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols&quot; notepad.exe</span><br></pre></td></tr></table></figure></li><li><p>通过命令设置<br>在 WinDbg 调试过程中用命令设置符号路径，仅本次运行生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure></li></ol><h2 id="符号相关命令"><a href="#符号相关命令" class="headerlink" title="符号相关命令"></a>符号相关命令</h2><ul><li><p>开启符号文件加载信息的详细输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!sym noisy</span><br></pre></td></tr></table></figure></li><li><p>显示当前符号搜索路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath</span><br></pre></td></tr></table></figure></li><li><p>设置符号搜索路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath C:\Symbols</span><br></pre></td></tr></table></figure></li><li><p>追加符号搜索路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath+ C:\Symbols2</span><br></pre></td></tr></table></figure></li><li><p>自动将符号路径设置为 Microsoft 符号服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.symfix C:\Symbols</span><br></pre></td></tr></table></figure><p>这条指令将符号路径设置为<code>SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols</code>。简化了<code>.sympath</code>命令。</p></li><li><p>重新加载符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.reload</span><br></pre></td></tr></table></figure><p>这条命令并不会真正的重新加载符号，只是把已加载模块的符号信息清除，在具体执行需要解析符号的命令时，才真正加载符号。</p></li><li><p>强制重新加载符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.reload /f</span><br></pre></td></tr></table></figure></li><li><p>重新加载某个模块的符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.reload ntdll.dll</span><br></pre></td></tr></table></figure></li><li><p>打印指定模块的符号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!chksym ntdll.dll</span><br></pre></td></tr></table></figure></li></ul><h2 id="离线符号包"><a href="#离线符号包" class="headerlink" title="离线符号包"></a>离线符号包</h2><p>微软曾经推出过符号离线安装包，不过后来没有再提供了，所以只有一些老系统有安装包。新的符号必须在线下载。<br><a href="http://download.microsoft.com/download/d/3/0/d30e32d8-418a-469d-b600-f32ce3edf42d/WindowsXP-KB936929-SP3-x86-ENU.exe">WindowsXP-KB936929-SP3-x86-ENU.exe</a><br><a href="http://download.microsoft.com/download/e/d/9/ed9b7861-4e43-4c62-a007-4e93aa109602/WindowsXP-KB936929-SP3-x86-CHS.exe">WindowsXP-KB936929-SP3-x86-CHS.exe</a><br><a href="http://download.microsoft.com/download/2/2/a/22a44f8b-2f1b-46a9-940a-cf4099fd1de9/WindowsXP-KB936929-SP3-x86-CHT.exe">WindowsXP-KB936929-SP3-x86-CHT.exe</a><br><a href="http://download.microsoft.com/download/2/9/0/29008fe5-f699-47d5-ab32-91bae6c548bf/WindowsXP-KB936929-SP3-x86-CHH.exe">WindowsXP-KB936929-SP3-x86-CHH.exe</a><br><a href="https://download.microsoft.com/download/7/F/B/7FBF7E6A-D0DE-442A-A683-4F9885A96FC9/Windows_Win7.7600.16385.090713-1255.X86FRE.Symbols.msi">Windows_Win7.7600.16385.090713-1255.X86FRE.Symbols.msi</a><br><a href="https://download.microsoft.com/download/7/F/B/7FBF7E6A-D0DE-442A-A683-4F9885A96FC9/Windows_Win7.7600.16385.090713-1255.X86CHK.Symbols.msi">Windows_Win7.7600.16385.090713-1255.X86CHK.Symbols.msi</a><br><a href="https://download.microsoft.com/download/F/1/1/F11206A1-C532-4C9E-86FF-1261A693AA53/Windows_Win7.7600.16385.090713-1255.X64FRE.Symbols.msi">Windows_Win7.7600.16385.090713-1255.X64FRE.Symbols.msi</a><br><a href="https://download.microsoft.com/download/F/1/1/F11206A1-C532-4C9E-86FF-1261A693AA53/Windows_Win7.7600.16385.090713-1255.X64CHK.Symbols.msi">Windows_Win7.7600.16385.090713-1255.X64CHK.Symbols.msi</a><br><a href="http://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/Windows_Win7SP1.7601.17514.101119-1850.X86FRE.Symbols.msi">Windows_Win7SP1.7601.17514.101119-1850.X86FRE.Symbols.msi</a><br><a href="https://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/Windows_Win7SP1.7601.17514.101119-1850.X86CHK.Symbols.msi">Windows_Win7SP1.7601.17514.101119-1850.X86CHK.Symbols.msi</a><br><a href="https://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/Windows_Win7SP1.7601.17514.101119-1850.AMD64FRE.Symbols.msi">Windows_Win7SP1.7601.17514.101119-1850.AMD64FRE.Symbols.msi</a><br><a href="https://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/Windows_Win7SP1.7601.17514.101119-1850.AMD64CHK.Symbols.msi">Windows_Win7SP1.7601.17514.101119-1850.AMD64CHK.Symbols.msi</a></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://bbs.kanxue.com/thread-251052.htm">关于WinDbg的符号文件设置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件调试 </tag>
            
            <tag> WinDbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>塞尔达传说：旷野之息数据整理</title>
      <link href="/2024/01/28/botw-hack/"/>
      <url>/2024/01/28/botw-hack/</url>
      
        <content type="html"><![CDATA[<p>大部分数据来自网络，亲测可用。<br><br>游戏信息：<br>TID：01007EF00011E000<br>BID：8E9978D50BDD20B4</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><table><thead><tr><th>数据</th><th>地址</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>生命</td><td>[[main+2CA1A78]+80]+848</td><td>uint</td><td>1颗心&#x3D;4</td></tr><tr><td>精力</td><td>[[main+2C9FD70]+38]+2AC</td><td>float</td><td>一圈精力&#x3D;1000</td></tr><tr><td>精力上限</td><td>[[main+2C9FD70]+38]+2B0</td><td>float</td><td></td></tr><tr><td>计算坠落伤害的 Y 坐标</td><td>[[main+2CA1140]+60]+20D0</td><td>float</td><td>为 0 时可以免坠落伤害</td></tr><tr><td>大师之剑冷却时间</td><td>[[main+2CA1140]+60]+1E24</td><td>float</td><td>为 0 时可用</td></tr></tbody></table><h2 id="希卡之石技能"><a href="#希卡之石技能" class="headerlink" title="希卡之石技能"></a>希卡之石技能</h2><table><thead><tr><th>数据</th><th>地址</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>圆形炸弹冷却时间</td><td>[[main+2CA3AD8]+30]+80</td><td>float</td><td>为 181（0x43350000）时可用。冷却从 0 开始递增</td></tr><tr><td>方形炸弹冷却时间</td><td>[[main+2CA3AD8]+30]+98</td><td>float</td><td>为 181（0x43350000）时可用。冷却从 0 开始递增</td></tr><tr><td>静止器状态Flag</td><td>[[main+2CA3AD8]+30]+140</td><td>byte</td><td></td></tr><tr><td>静止器冷却时间</td><td>[[main+2CA3AD8]+30]+144</td><td>float</td><td>为 0 时可用</td></tr><tr><td>静止器目标倒计时</td><td>[[main+2CA3AD8]+30]+148</td><td>float</td><td>为 0 时目标物体恢复</td></tr></tbody></table><h2 id="英杰技能"><a href="#英杰技能" class="headerlink" title="英杰技能"></a>英杰技能</h2><table><thead><tr><th>数据</th><th>地址</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>英杰力巴尔的勇猛冷却时间</td><td>[[main+2CA1140]+60]+1DF4</td><td>float</td><td>为 0 时可用</td></tr><tr><td>英杰达乌尔波扎的愤怒冷却时间</td><td>[[main+2CA1140]+60]+1E00</td><td>float</td><td>为 0 时可用</td></tr><tr><td>英杰达尔克尔的守护冷却时间</td><td>[[main+2CA1140]+60]+1E0C</td><td>float</td><td>为 0 时可用</td></tr><tr><td>英杰达米法的祈福冷却时间</td><td>[[main+2CA1140]+60]+1E18</td><td>float</td><td>为 0 时可用</td></tr></tbody></table><h2 id="料理"><a href="#料理" class="headerlink" title="料理"></a>料理</h2><h3 id="移动力提升倒计时"><a href="#移动力提升倒计时" class="headerlink" title="移动力提升倒计时"></a>移动力提升倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1ED8</span><br><span class="line">[[main+2CA1140]+60]+1EE4</span><br><span class="line">[[main+2CA1140]+60]+1EF0</span><br></pre></td></tr></table></figure><h3 id="攻击提升倒计时"><a href="#攻击提升倒计时" class="headerlink" title="攻击提升倒计时"></a>攻击提升倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F14</span><br></pre></td></tr></table></figure><h3 id="防御提升倒计时"><a href="#防御提升倒计时" class="headerlink" title="防御提升倒计时"></a>防御提升倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F20</span><br></pre></td></tr></table></figure><h3 id="耐热防护倒计时"><a href="#耐热防护倒计时" class="headerlink" title="耐热防护倒计时"></a>耐热防护倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F2C</span><br></pre></td></tr></table></figure><h3 id="耐寒防护倒计时"><a href="#耐寒防护倒计时" class="headerlink" title="耐寒防护倒计时"></a>耐寒防护倒计时</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F38    f32，耐寒防护剩余时间，每秒=30</span><br><span class="line">[[main+2CA1140]+60]+2010    u32，耐寒防护等级</span><br></pre></td></tr></table></figure><h3 id="火焰防护倒计时"><a href="#火焰防护倒计时" class="headerlink" title="火焰防护倒计时"></a>火焰防护倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F44</span><br></pre></td></tr></table></figure><h3 id="电麻防护倒计时"><a href="#电麻防护倒计时" class="headerlink" title="电麻防护倒计时"></a>电麻防护倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F5C</span><br></pre></td></tr></table></figure><h3 id="安静性提升倒计时"><a href="#安静性提升倒计时" class="headerlink" title="安静性提升倒计时"></a>安静性提升倒计时</h3><p>float类型，每秒&#x3D;30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[main+2CA1140]+60]+1F74</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当前生效的料理数据，似乎只是显示用（修改无效）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[main+2CBDB80]+A4    当前生效料理类型（修改无效）</span><br><span class="line">0 = 耐热防护</span><br><span class="line">1 = 耐寒防护</span><br><span class="line">2 = 电麻防护</span><br><span class="line">3 = 火焰防护（未验证）</span><br><span class="line">4 = 攻击提升</span><br><span class="line">5 = 防御提升</span><br><span class="line">6 = 安静性提升</span><br><span class="line">7 = 移动力提升</span><br><span class="line"></span><br><span class="line">[main+2CBDB80]+A8    当前生效料理等级（修改无效）</span><br><span class="line">[main+2CBDB80]+AC    当前生效料理剩余时间（修改无效）</span><br></pre></td></tr></table></figure><h2 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h2><p>修改装备数据有两条路径，一个在游戏界面，一个在背包界面。<br>对于背包数据，打开背包界面后查找林克当前装备的指针定位到数据结构的，这种方式在背包关闭时是无法定位的。<br><strong>注意：修改数据后要在不装备的情况下打开或关闭背包一次才会真正的将数据刷入。否则只是修改了显示数据，将物品丢弃后再拾起数据又会复原</strong>。</p><h3 id="当前武器"><a href="#当前武器" class="headerlink" title="当前武器"></a>当前武器</h3><table><thead><tr><th>数据</th><th>游戏世界</th><th>背包界面</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>耐久</td><td>[[[[main+2CC4768]+C0]-A0]+48]+D4C</td><td>[[main+2CA6D48]+447D8]+20</td><td>u32</td><td></td></tr><tr><td>是否已装备</td><td></td><td>[[main+2CA6D48]+447D8]+24</td><td>u8</td><td></td></tr><tr><td>词条属性值</td><td></td><td>[[main+2CA6D48]+447D8]+80</td><td>u32</td><td></td></tr><tr><td>词条</td><td></td><td>[[main+2CA6D48]+447D8]+88</td><td>u32</td><td></td></tr></tbody></table><h3 id="当前弓"><a href="#当前弓" class="headerlink" title="当前弓"></a>当前弓</h3><table><thead><tr><th>数据</th><th>游戏世界</th><th>背包界面</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>耐久</td><td>[[[[main+2CC4768]+C0]-70]+48]+D4C</td><td></td><td>u32</td><td></td></tr></tbody></table><h3 id="当前盾"><a href="#当前盾" class="headerlink" title="当前盾"></a>当前盾</h3><table><thead><tr><th>数据</th><th>游戏世界</th><th>背包界面</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>耐久</td><td>[[[[main+2CC4768]+C0]-88]+48]+D4C</td><td></td><td>u32</td><td></td></tr></tbody></table><h3 id="词条"><a href="#词条" class="headerlink" title="词条"></a>词条</h3><p>词条是一个 Flag。由低到高找到的第一个为 1 的位生效。第 32 位表示属性提升大，比如 0x80000001 表示攻击力提升大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       0x1 = 攻击力提升</span><br><span class="line">       0x2 = 耐力提升</span><br><span class="line">       0x4 = 结束暴击</span><br><span class="line">       0x8 = 远距离投掷</span><br><span class="line">      0x10 = 5连发</span><br><span class="line">      0x20 = 3连发</span><br><span class="line">      0x40 = 速射</span><br><span class="line">     0x100 = 盾防护提升</span><br><span class="line">0x80000000 = 属性提升大</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://github.com/Pistonight/botw-save-state/blob/main/src/mem/PointerList.txt">https://github.com/Pistonight/botw-save-state/blob/main/src/mem/PointerList.txt</a></p><p><a href="https://github.com/xenocard/CheatsHunter/blob/main/01007EF00011E000/cheats/8E9978D50BDD20B4.txt">https://github.com/xenocard/CheatsHunter/blob/main/01007EF00011E000/cheats/8E9978D50BDD20B4.txt</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 塞尔达传说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旷野之息神庙全亮、传送作弊</title>
      <link href="/2024/01/24/zelda-botw-temples/"/>
      <url>/2024/01/24/zelda-botw-temples/</url>
      
        <content type="html"><![CDATA[<p>在<code>塞尔达传说：旷野之息</code>中，神庙在地图上有四种状态：</p><ol><li>从未访问过。地图上不会出现图标。</li><li>访问过但是未激活。图标呈黄色，无法传送。</li><li>神庙已激活但未通关。图标呈外蓝内黄，可以传送。</li><li>神庙已通关。图标呈蓝色，可以传送。</li></ol><p><br>我第一直觉就是这是个枚举类型，于是找了几个小时 0123、1234 这些数字，始终没有找到地址。最后无奈对比存档文件发现地图上点亮神庙的依据是访问次数是否大于零。访问过才会出现在地图上，也就是说数据结构并不是我想的那样是一个简单的枚举类型。</p><h2 id="查找内存地址"><a href="#查找内存地址" class="headerlink" title="查找内存地址"></a>查找内存地址</h2><p>对于从未访问过的神庙搜索 0 即可，但是这样肯定不好找，有两个方法定位：</p><ol><li>先模糊搜索，然后离神庙远一点，再靠近神庙，这样访问次数就会+1。</li><li>用 <a href="https://www.marcrobledo.com/savegame-editors/zelda-botw/">存档编辑器</a> 修改神庙访问次数（方法见文章末尾链接）。改为一个特殊的数字，这样就比较好搜。</li></ol><p><br>我搜索到<code>迦奥玛·阿萨神庙</code>本次的地址为<code>heap+AB30D710</code>，数据类型为<code>u32</code>。而<code>heap</code>地址当然是不可靠的，我们需要找到存储在<code>main</code>中的指针。</p><h2 id="查找指针"><a href="#查找指针" class="headerlink" title="查找指针"></a>查找指针</h2><p>使用 <a href="https://github.com/tomvita/Breeze-Beta/">Breeze</a> 设置一个写入断点，断点在<code>main+1218ACC</code>。<br>用 IDA 定位到<code>main+1218ACC</code>，看看这段伪代码：</p><p><img src="/images/zelda-botw-temples/01.webp"></p><p><strong>从代码看，最后一次偏移量是<code>0x1C</code>，后面找指针时就找结尾是<code>0x1C</code>的就行了。</strong><br>根据附近的代码来看，指针深度至少在 3 层，类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[main+xxxx] + F0] - 58] + 1C</span><br></pre></td></tr></table></figure><p>再次搬出 Breeze，添加目标地址到书签中，然后按下<code>Memory Explorer</code>打开内存窗口</p><p><img src="/images/zelda-botw-temples/02.webp"></p><p>点击<code>Jump Forward</code></p><p><img src="/images/zelda-botw-temples/03.webp"></p><p>点击<code>Start</code>开始搜索</p><p><img src="/images/zelda-botw-temples/04.webp"></p><p>在搜索结果中看到了第一条数据的偏移量是 0x1C（图片中的 d&#x3D;1c），大概率是找到了，继续<code>Next depth</code></p><p><img src="/images/zelda-botw-temples/05.webp"></p><p>第二次搜索结果中看到了第一条数据的偏移量是 0x58（图片中的 d&#x3D;58），感觉离成功越来越近了，继续<code>Next depth</code></p><p><img src="/images/zelda-botw-temples/06.webp"></p><p>一般来说指针最多就四层或五层，我这里找到四层时就找到了，看图片中 BM 不等于0，说明找到了对应的地址并添加到了书签</p><p><img src="/images/zelda-botw-temples/07.webp"></p><p>然后关闭游戏，重新启动游戏，这是为了让内存地址变化，以便验证指针的正确性。到 Breeze 书签中校对值是否正确，找出最后偏移为 0x1C 的可用指针。<br>编程经验告诉我，相同的数据 99% 的情况下都是在一起的。发现<code>[[main+2CA6460]+240]+???</code>是一个指针数组，只需要遍历这个数组就能找到所有地点访问次数的地址了。</p><h2 id="地点数据"><a href="#地点数据" class="headerlink" title="地点数据"></a>地点数据</h2><p>包含：</p><ul><li>15 座塔</li><li>137 座神庙（多一个？） </li><li>4 个神兽</li></ul><p><br>前面两个神庙指针链不同，可能是没找对位置。</p><table><thead><tr><th>地点名称</th><th>访问次数</th></tr></thead><tbody><tr><td>托·库摩神庙</td><td>[[main+2CBDB88]+F0]+1C</td></tr><tr><td>席亚·米乌神庙</td><td>[[main+2CBDB88]+D8]+2C</td></tr><tr><td>卡玛·拉席神庙</td><td>[[[[main+2CA6460]+240]+10]+58]+1C</td></tr><tr><td>乌塔·多神庙</td><td>[[[[main+2CA6460]+240]+18]+58]+1C</td></tr><tr><td>卡·奥裘神庙</td><td>[[[[main+2CA6460]+240]+20]+58]+1C</td></tr><tr><td>基玛·科萨萨神庙</td><td>[[[[main+2CA6460]+240]+28]+58]+1C</td></tr><tr><td>基玛·兹斯神庙</td><td>[[[[main+2CA6460]+240]+30]+58]+1C</td></tr><tr><td>塔塔卡玛·希米利神庙</td><td>[[[[main+2CA6460]+240]+38]+58]+1C</td></tr><tr><td>托·卡尤神庙</td><td>[[[[main+2CA6460]+240]+40]+58]+1C</td></tr><tr><td>哈瓦·卡伊神庙</td><td>[[[[main+2CA6460]+240]+48]+58]+1C</td></tr><tr><td>妙斯·希诺神庙</td><td>[[[[main+2CA6460]+240]+50]+58]+1C</td></tr><tr><td>飞行训练场</td><td>[[[[main+2CA6460]+240]+58]+58]+1C</td></tr><tr><td>夏·塔瓦神庙</td><td>[[[[main+2CA6460]+240]+60]+58]+1C</td></tr><tr><td>诺伊艾·罗吉神庙</td><td>[[[[main+2CA6460]+240]+68]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+70]+58]+1C</td></tr><tr><td>利特村</td><td>[[[[main+2CA6460]+240]+78]+58]+1C</td></tr><tr><td>利特驿站</td><td>[[[[main+2CA6460]+240]+80]+58]+1C</td></tr><tr><td>阿科·瓦塔神庙</td><td>[[[[main+2CA6460]+240]+88]+58]+1C</td></tr><tr><td>沃力达·诺神庙</td><td>[[[[main+2CA6460]+240]+90]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+98]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+A0]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+A8]+58]+1C</td></tr><tr><td>神兽瓦·梅德</td><td>[[[[main+2CA6460]+240]+B0]+58]+1C</td></tr><tr><td>提纳·裘扎神庙</td><td>[[[[main+2CA6460]+240]+B8]+58]+1C</td></tr><tr><td>塔邦挞之塔</td><td>[[[[main+2CA6460]+240]+C0]+58]+1C</td></tr><tr><td>基哈·乌神庙</td><td>[[[[main+2CA6460]+240]+C8]+58]+1C</td></tr><tr><td>基希罗特·摩神庙</td><td>[[[[main+2CA6460]+240]+D0]+58]+1C</td></tr><tr><td>格鲁德之塔</td><td>[[[[main+2CA6460]+240]+D8]+58]+1C</td></tr><tr><td>库伊·塔卡神庙</td><td>[[[[main+2CA6460]+240]+E0]+58]+1C</td></tr><tr><td>希·基托神庙</td><td>[[[[main+2CA6460]+240]+E8]+58]+1C</td></tr><tr><td>萨萨·卡伊神庙</td><td>[[[[main+2CA6460]+240]+F0]+58]+1C</td></tr><tr><td>依盖队基地</td><td>[[[[main+2CA6460]+240]+F8]+58]+1C</td></tr><tr><td>格鲁德小镇</td><td>[[[[main+2CA6460]+240]+100]+58]+1C</td></tr><tr><td>卡拉卡拉集市</td><td>[[[[main+2CA6460]+240]+108]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+110]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+118]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+120]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+128]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+130]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+138]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+140]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+148]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+150]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+158]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+160]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+168]+58]+1C</td></tr><tr><td>达科·塔瓦神庙</td><td>[[[[main+2CA6460]+240]+170]+58]+1C</td></tr><tr><td>古科·齐塞神庙</td><td>[[[[main+2CA6460]+240]+178]+58]+1C</td></tr><tr><td>拉丘·乌罗神庙</td><td>[[[[main+2CA6460]+240]+180]+58]+1C</td></tr><tr><td>夏达·阿达神庙</td><td>[[[[main+2CA6460]+240]+188]+58]+1C</td></tr><tr><td>基哈·托乌萨神庙</td><td>[[[[main+2CA6460]+240]+190]+58]+1C</td></tr><tr><td>拉·库阿神庙</td><td>[[[[main+2CA6460]+240]+198]+58]+1C</td></tr><tr><td>拉诺·库席神庙</td><td>[[[[main+2CA6460]+240]+1A0]+58]+1C</td></tr><tr><td>海布拉之塔</td><td>[[[[main+2CA6460]+240]+1A8]+58]+1C</td></tr><tr><td>诺基·米席神庙</td><td>[[[[main+2CA6460]+240]+1B0]+58]+1C</td></tr><tr><td>迦奥玛·阿萨神庙</td><td>[[[[main+2CA6460]+240]+1B8]+58]+1C</td></tr><tr><td>多恩巴·塔神庙</td><td>[[[[main+2CA6460]+240]+1C0]+58]+1C</td></tr><tr><td>希利特·古奥玛神庙</td><td>[[[[main+2CA6460]+240]+1C8]+58]+1C</td></tr><tr><td>塔邦达大桥驿站</td><td>[[[[main+2CA6460]+240]+1D0]+58]+1C</td></tr><tr><td>夏奥·耀神庙</td><td>[[[[main+2CA6460]+240]+1D8]+58]+1C</td></tr><tr><td>托·雅萨神庙</td><td>[[[[main+2CA6460]+240]+1E0]+58]+1C</td></tr><tr><td>摩·拉塔尼阿神庙</td><td>[[[[main+2CA6460]+240]+1E8]+58]+1C</td></tr><tr><td>米达·罗基神庙</td><td>[[[[main+2CA6460]+240]+1F0]+58]+1C</td></tr><tr><td>究尼·希神庙</td><td>[[[[main+2CA6460]+240]+1F8]+58]+1C</td></tr><tr><td>格鲁德峡谷驿站</td><td>[[[[main+2CA6460]+240]+200]+58]+1C</td></tr><tr><td>荒野之塔</td><td>[[[[main+2CA6460]+240]+208]+58]+1C</td></tr><tr><td>克·诺伊神庙</td><td>[[[[main+2CA6460]+240]+210]+58]+1C</td></tr><tr><td>神兽瓦·娜波力斯</td><td>[[[[main+2CA6460]+240]+218]+58]+1C</td></tr><tr><td>裘希·奥神庙</td><td>[[[[main+2CA6460]+240]+220]+58]+1C</td></tr><tr><td>克贝·塔瓦神庙</td><td>[[[[main+2CA6460]+240]+228]+58]+1C</td></tr><tr><td>密·苏神庙</td><td>[[[[main+2CA6460]+240]+230]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+238]+58]+1C</td></tr><tr><td>夏·格玛神庙</td><td>[[[[main+2CA6460]+240]+240]+58]+1C</td></tr><tr><td>雪原驿站</td><td>[[[[main+2CA6460]+240]+248]+58]+1C</td></tr><tr><td>利·摩纳神庙</td><td>[[[[main+2CA6460]+240]+250]+58]+1C</td></tr><tr><td>忘却神殿</td><td>[[[[main+2CA6460]+240]+258]+58]+1C</td></tr><tr><td>罗纳·卡塔神庙</td><td>[[[[main+2CA6460]+240]+260]+58]+1C</td></tr><tr><td>玛丽塔驿站</td><td>[[[[main+2CA6460]+240]+268]+58]+1C</td></tr><tr><td>玛·诺拉神庙</td><td>[[[[main+2CA6460]+240]+270]+58]+1C</td></tr><tr><td>蒙亚·托玛神庙</td><td>[[[[main+2CA6460]+240]+278]+58]+1C</td></tr><tr><td>基瓦·扎塔斯神庙</td><td>[[[[main+2CA6460]+240]+280]+58]+1C</td></tr><tr><td>丘陵之塔</td><td>[[[[main+2CA6460]+240]+288]+58]+1C</td></tr><tr><td>希·达哥兹神庙</td><td>[[[[main+2CA6460]+240]+290]+58]+1C</td></tr><tr><td>复苏神庙</td><td>[[[[main+2CA6460]+240]+298]+58]+1C</td></tr><tr><td>平原外围的驿站</td><td>[[[[main+2CA6460]+240]+2A0]+58]+1C</td></tr><tr><td>鲁耀·塔乌神庙</td><td>[[[[main+2CA6460]+240]+2A8]+58]+1C</td></tr><tr><td>达·卡索神庙</td><td>[[[[main+2CA6460]+240]+2B0]+58]+1C</td></tr><tr><td>图米·恩科神庙</td><td>[[[[main+2CA6460]+240]+2B8]+58]+1C</td></tr><tr><td>艾茨·科力玛神庙</td><td>[[[[main+2CA6460]+240]+2C0]+58]+1C</td></tr><tr><td>吉诺·耀神庙</td><td>[[[[main+2CA6460]+240]+2C8]+58]+1C</td></tr><tr><td>斯玛·萨玛神庙</td><td>[[[[main+2CA6460]+240]+2D0]+58]+1C</td></tr><tr><td>迪拉·玛神庙</td><td>[[[[main+2CA6460]+240]+2D8]+58]+1C</td></tr><tr><td>卡扎·托基神庙</td><td>[[[[main+2CA6460]+240]+2E0]+58]+1C</td></tr><tr><td>达·乔卡席神庙</td><td>[[[[main+2CA6460]+240]+2E8]+58]+1C</td></tr><tr><td>萨斯·科萨神庙</td><td>[[[[main+2CA6460]+240]+2F0]+58]+1C</td></tr><tr><td>尼阿·奈阿神庙</td><td>[[[[main+2CA6460]+240]+2F8]+58]+1C</td></tr><tr><td>卡塔·丘基神庙</td><td>[[[[main+2CA6460]+240]+300]+58]+1C</td></tr><tr><td>海拉鲁城堡</td><td>[[[[main+2CA6460]+240]+308]+58]+1C</td></tr><tr><td>亚卡·玛塔神庙</td><td>[[[[main+2CA6460]+240]+310]+58]+1C</td></tr><tr><td>平原之塔</td><td>[[[[main+2CA6460]+240]+318]+58]+1C</td></tr><tr><td>加·巴希夫神庙</td><td>[[[[main+2CA6460]+240]+320]+58]+1C</td></tr><tr><td>玛·奥努神庙</td><td>[[[[main+2CA6460]+240]+328]+58]+1C</td></tr><tr><td>罗希塔·奇古神庙</td><td>[[[[main+2CA6460]+240]+330]+58]+1C</td></tr><tr><td>耀瓦卡·伊尔塔神庙</td><td>[[[[main+2CA6460]+240]+338]+58]+1C</td></tr><tr><td>初始之塔</td><td>[[[[main+2CA6460]+240]+340]+58]+1C</td></tr><tr><td>露奈·科力巴神庙</td><td>[[[[main+2CA6460]+240]+348]+58]+1C</td></tr><tr><td>湖之塔</td><td>[[[[main+2CA6460]+240]+350]+58]+1C</td></tr><tr><td>瓦·摩达伊神庙</td><td>[[[[main+2CA6460]+240]+358]+58]+1C</td></tr><tr><td>亚·纳迦神庙</td><td>[[[[main+2CA6460]+240]+360]+58]+1C</td></tr><tr><td>伊奥·索奥神庙</td><td>[[[[main+2CA6460]+240]+368]+58]+1C</td></tr><tr><td>基托·瓦瓦伊神庙</td><td>[[[[main+2CA6460]+240]+370]+58]+1C</td></tr><tr><td>克洛格森林</td><td>[[[[main+2CA6460]+240]+378]+58]+1C</td></tr><tr><td>基耀·乌神庙</td><td>[[[[main+2CA6460]+240]+380]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+388]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+390]+58]+1C</td></tr><tr><td>玛姆·拉诺神庙</td><td>[[[[main+2CA6460]+240]+398]+58]+1C</td></tr><tr><td>森岭之塔</td><td>[[[[main+2CA6460]+240]+3A0]+58]+1C</td></tr><tr><td>库恩·希达吉神庙</td><td>[[[[main+2CA6460]+240]+3A8]+58]+1C</td></tr><tr><td>纳米卡·奥兹神庙</td><td>[[[[main+2CA6460]+240]+3B0]+58]+1C</td></tr><tr><td>湿地驿站</td><td>[[[[main+2CA6460]+240]+3B8]+58]+1C</td></tr><tr><td>卡亚·米瓦神庙</td><td>[[[[main+2CA6460]+240]+3C0]+58]+1C</td></tr><tr><td>席罗·席拉神庙</td><td>[[[[main+2CA6460]+240]+3C8]+58]+1C</td></tr><tr><td>河畔驿站</td><td>[[[[main+2CA6460]+240]+3D0]+58]+1C</td></tr><tr><td>瓦哥·卡塔神庙</td><td>[[[[main+2CA6460]+240]+3D8]+58]+1C</td></tr><tr><td>瓦希·辽科神庙</td><td>[[[[main+2CA6460]+240]+3E0]+58]+1C</td></tr><tr><td>普玛·尼特神庙</td><td>[[[[main+2CA6460]+240]+3E8]+58]+1C</td></tr><tr><td>希·库乔夫神庙</td><td>[[[[main+2CA6460]+240]+3F0]+58]+1C</td></tr><tr><td>高原驿站</td><td>[[[[main+2CA6460]+240]+3F8]+58]+1C</td></tr><tr><td>卡奥·玛卡神庙</td><td>[[[[main+2CA6460]+240]+400]+58]+1C</td></tr><tr><td>希·塔塔恩科神庙</td><td>[[[[main+2CA6460]+240]+408]+58]+1C</td></tr><tr><td>晓拉·哈神庙</td><td>[[[[main+2CA6460]+240]+410]+58]+1C</td></tr><tr><td>鼓隆城</td><td>[[[[main+2CA6460]+240]+418]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+420]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+428]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+430]+58]+1C</td></tr><tr><td>希摩·依托塞神庙</td><td>[[[[main+2CA6460]+240]+438]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+440]+58]+1C</td></tr><tr><td>废弃的北部矿坑</td><td>[[[[main+2CA6460]+240]+448]+58]+1C</td></tr><tr><td>森岭驿站</td><td>[[[[main+2CA6460]+240]+450]+58]+1C</td></tr><tr><td>南部采矿场</td><td>[[[[main+2CA6460]+240]+458]+58]+1C</td></tr><tr><td>米罗·茨席神庙</td><td>[[[[main+2CA6460]+240]+460]+58]+1C</td></tr><tr><td>丘·拉姆席神庙</td><td>[[[[main+2CA6460]+240]+468]+58]+1C</td></tr><tr><td>协莫·拉塔神庙</td><td>[[[[main+2CA6460]+240]+470]+58]+1C</td></tr><tr><td>达塔·库斯神庙</td><td>[[[[main+2CA6460]+240]+478]+58]+1C</td></tr><tr><td>塔罗·尼席神庙</td><td>[[[[main+2CA6460]+240]+480]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+488]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+490]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+498]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+4A0]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+4A8]+58]+1C</td></tr><tr><td>双子山之塔</td><td>[[[[main+2CA6460]+240]+4B0]+58]+1C</td></tr><tr><td>希贝·尼亚斯神庙</td><td>[[[[main+2CA6460]+240]+4B8]+58]+1C</td></tr><tr><td>希贝·尼罗神庙</td><td>[[[[main+2CA6460]+240]+4C0]+58]+1C</td></tr><tr><td>哈尤·达玛神庙</td><td>[[[[main+2CA6460]+240]+4C8]+58]+1C</td></tr><tr><td>利·达席神庙</td><td>[[[[main+2CA6460]+240]+4D0]+58]+1C</td></tr><tr><td>双子驿站</td><td>[[[[main+2CA6460]+240]+4D8]+58]+1C</td></tr><tr><td>托托·伊萨神庙</td><td>[[[[main+2CA6460]+240]+4E0]+58]+1C</td></tr><tr><td>晓达·萨神庙</td><td>[[[[main+2CA6460]+240]+4E8]+58]+1C</td></tr><tr><td>湖畔驿站</td><td>[[[[main+2CA6460]+240]+4F0]+58]+1C</td></tr><tr><td>塞伊·乌托神庙</td><td>[[[[main+2CA6460]+240]+4F8]+58]+1C</td></tr><tr><td>费罗尼之塔</td><td>[[[[main+2CA6460]+240]+500]+58]+1C</td></tr><tr><td>卡米拉·奥姆纳神庙</td><td>[[[[main+2CA6460]+240]+508]+58]+1C</td></tr><tr><td>古·阿齐托神庙</td><td>[[[[main+2CA6460]+240]+510]+58]+1C</td></tr><tr><td>夏德·罗恩神庙</td><td>[[[[main+2CA6460]+240]+518]+58]+1C</td></tr><tr><td>达卡·卡神庙</td><td>[[[[main+2CA6460]+240]+520]+58]+1C</td></tr><tr><td>克哈·拉玛神庙</td><td>[[[[main+2CA6460]+240]+528]+58]+1C</td></tr><tr><td>神兽瓦·鲁达尼亚</td><td>[[[[main+2CA6460]+240]+530]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+538]+58]+1C</td></tr><tr><td>利诺·希米卡神庙</td><td>[[[[main+2CA6460]+240]+540]+58]+1C</td></tr><tr><td>山麓驿站</td><td>[[[[main+2CA6460]+240]+548]+58]+1C</td></tr><tr><td>奥尔汀之塔</td><td>[[[[main+2CA6460]+240]+550]+58]+1C</td></tr><tr><td>摩阿·基希托神庙</td><td>[[[[main+2CA6460]+240]+558]+58]+1C</td></tr><tr><td>萨·达究神庙</td><td>[[[[main+2CA6460]+240]+560]+58]+1C</td></tr><tr><td>塔·姆尔神庙</td><td>[[[[main+2CA6460]+240]+568]+58]+1C</td></tr><tr><td>萨奥·科席神庙</td><td>[[[[main+2CA6460]+240]+570]+58]+1C</td></tr><tr><td>拉聂尔之塔</td><td>[[[[main+2CA6460]+240]+578]+58]+1C</td></tr><tr><td>拉纳·罗基神庙</td><td>[[[[main+2CA6460]+240]+580]+58]+1C</td></tr><tr><td>米兹·耀神庙</td><td>[[[[main+2CA6460]+240]+588]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+590]+58]+1C</td></tr><tr><td>达乌·纳艾神庙</td><td>[[[[main+2CA6460]+240]+598]+58]+1C</td></tr><tr><td>卡姆·尤奥神庙</td><td>[[[[main+2CA6460]+240]+5A0]+58]+1C</td></tr><tr><td>哈诺特之塔</td><td>[[[[main+2CA6460]+240]+5A8]+58]+1C</td></tr><tr><td>塔瓦·吉努神庙</td><td>[[[[main+2CA6460]+240]+5B0]+58]+1C</td></tr><tr><td>亚奥·玛耀神庙</td><td>[[[[main+2CA6460]+240]+5B8]+58]+1C</td></tr><tr><td>丘卡·纳塔神庙</td><td>[[[[main+2CA6460]+240]+5C0]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+5C8]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+5D0]+58]+1C</td></tr><tr><td>兹纳·卡伊神庙</td><td>[[[[main+2CA6460]+240]+5D8]+58]+1C</td></tr><tr><td>茨茨阿·尼玛神庙</td><td>[[[[main+2CA6460]+240]+5E0]+58]+1C</td></tr><tr><td>南阿卡莱驿站</td><td>[[[[main+2CA6460]+240]+5E8]+58]+1C</td></tr><tr><td>阿卡莱之塔</td><td>[[[[main+2CA6460]+240]+5F0]+58]+1C</td></tr><tr><td>达席·希诺神庙</td><td>[[[[main+2CA6460]+240]+5F8]+58]+1C</td></tr><tr><td>吉兹·卡夫伊神庙</td><td>[[[[main+2CA6460]+240]+600]+58]+1C</td></tr><tr><td>一始村</td><td>[[[[main+2CA6460]+240]+608]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+610]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+618]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+620]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+628]+58]+1C</td></tr><tr><td>卓拉领地</td><td>[[[[main+2CA6460]+240]+630]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+638]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+640]+58]+1C</td></tr><tr><td>奈兹·耀玛神庙</td><td>[[[[main+2CA6460]+240]+648]+58]+1C</td></tr><tr><td>萨塔·卡达神庙</td><td>[[[[main+2CA6460]+240]+650]+58]+1C</td></tr><tr><td>玛乌·艾鲁亚神庙</td><td>[[[[main+2CA6460]+240]+658]+58]+1C</td></tr><tr><td>达·基基神庙</td><td>[[[[main+2CA6460]+240]+660]+58]+1C</td></tr><tr><td>神兽瓦·露塔</td><td>[[[[main+2CA6460]+240]+668]+58]+1C</td></tr><tr><td>鲁克·玛神庙</td><td>[[[[main+2CA6460]+240]+670]+58]+1C</td></tr><tr><td>吉塔·萨米神庙</td><td>[[[[main+2CA6460]+240]+678]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+680]+58]+1C</td></tr><tr><td>哈特诺古代研究所</td><td>[[[[main+2CA6460]+240]+688]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+690]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+698]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+6A0]+58]+1C</td></tr><tr><td></td><td>[[[[main+2CA6460]+240]+6A8]+58]+1C</td></tr><tr><td>米亚马·迦纳神庙</td><td>[[[[main+2CA6460]+240]+6B0]+58]+1C</td></tr><tr><td>沃托里村</td><td>[[[[main+2CA6460]+240]+6B8]+58]+1C</td></tr><tr><td>姆奥·吉姆神庙</td><td>[[[[main+2CA6460]+240]+6C0]+58]+1C</td></tr><tr><td>玛·卡亚神庙</td><td>[[[[main+2CA6460]+240]+6C8]+58]+1C</td></tr><tr><td>阿卡莱古代研究所</td><td>[[[[main+2CA6460]+240]+6D0]+58]+1C</td></tr><tr><td>图·卡罗神庙</td><td>[[[[main+2CA6460]+240]+6D8]+58]+1C</td></tr><tr><td>东阿卡莱驿站</td><td>[[[[main+2CA6460]+240]+6E0]+58]+1C</td></tr><tr><td>卡茨·托萨神庙</td><td>[[[[main+2CA6460]+240]+6E8]+58]+1C</td></tr><tr><td>利塔·兹摩神庙</td><td>[[[[main+2CA6460]+240]+6F0]+58]+1C</td></tr><tr><td>卡·姆神庙</td><td>[[[[main+2CA6460]+240]+6F8]+58]+1C</td></tr><tr><td>基奥·达夫纳神庙</td><td>[[[[main+2CA6460]+240]+700]+58]+1C</td></tr><tr><td>科尼·希卡神庙</td><td>[[[[main+2CA6460]+240]+708]+58]+1C</td></tr><tr><td>希·尤塔神庙</td><td>[[[[main+2CA6460]+240]+710]+58]+1C</td></tr><tr><td>塔诺·阿神庙</td><td>[[[[main+2CA6460]+240]+718]+58]+1C</td></tr><tr><td>洽斯·科塔神庙</td><td>[[[[main+2CA6460]+240]+720]+58]+1C</td></tr><tr><td>库古·齐德神庙</td><td>[[[[main+2CA6460]+240]+728]+58]+1C</td></tr></tbody></table><h2 id="显示神庙位置"><a href="#显示神庙位置" class="headerlink" title="显示神庙位置"></a>显示神庙位置</h2><p>我们可以将所有神庙访问次数写入大于零的值，这样地图上就能显示神庙了。但是这样做金手指太痛苦了，毕竟有一百多个神庙。。。而且为每个神庙做金手指容易出错。<br>更好的做法是修改程序逻辑，我们设置一个读断点，看看是哪里访问了次数数据。</p><p><img src="/images/zelda-botw-temples/08.webp"></p><p>游戏在<code>main+109dfb0</code>处不停地读取地点神庙次数，接着有两处<code>cmp xxx</code>语句，都是和次数有关的判断，都<code>nop</code>掉。<br>再往下翻一点，还有一处</p><p><img src="/images/zelda-botw-temples/09.webp"></p><p>一共三处，都 nop 掉，抱着试试看的心理测试一下，结果瞎猫碰上死耗子，神庙全显示了！</p><p><img src="/images/zelda-botw-temples/10.webp"></p><p>金手指：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[显示神庙位置]</span></span><br><span class="line">04000000 0109DFB8 D503201F</span><br><span class="line">04000000 0109DFD0 D503201F</span><br><span class="line">04000000 0109DFEC D503201F</span><br></pre></td></tr></table></figure><h2 id="显示高塔位置"><a href="#显示高塔位置" class="headerlink" title="显示高塔位置"></a>显示高塔位置</h2><p>思路与神庙一样，在访问次数的地方设置读断点，断在了<code>main+109FA30</code>处。代码和上面是一样的，nop 掉三处即可。</p><p>金手指：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[显示高塔位置]</span></span><br><span class="line">04000000 0109FA38 D503201F</span><br><span class="line">04000000 0109FA50 D503201F</span><br><span class="line">04000000 0109FA6C D503201F</span><br></pre></td></tr></table></figure><h2 id="显示古代研究所位置"><a href="#显示古代研究所位置" class="headerlink" title="显示古代研究所位置"></a>显示古代研究所位置</h2><p>思路与神庙一样，在访问次数的地方设置读断点，断在了<code>main+10A2110</code>处。代码和上面是一样的，nop 掉三处即可。</p><p>金手指：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[显示古代研究所位置]</span></span><br><span class="line">04000000 010A2118 D503201F</span><br><span class="line">04000000 010A2130 D503201F</span><br><span class="line">04000000 010A214C D503201F</span><br></pre></td></tr></table></figure><h2 id="显示神兽位置"><a href="#显示神兽位置" class="headerlink" title="显示神兽位置"></a>显示神兽位置</h2><p>思路与神庙一样，在访问次数的地方设置读断点，断在了<code>main+10A1950</code>处。代码和上面是一样的，nop 掉三处即可。</p><p>金手指：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[显示神兽位置]</span></span><br><span class="line">04000000 010A1958 D503201F</span><br><span class="line">04000000 010A1970 D503201F</span><br><span class="line">04000000 010A198C D503201F</span><br></pre></td></tr></table></figure><h2 id="显示功能-Flag"><a href="#显示功能-Flag" class="headerlink" title="显示功能 Flag"></a>显示功能 Flag</h2><p>为了搞清楚控制显示的 flag 到底在哪，于是我查看了一下高塔相关的伪代码：</p><p><img src="/images/zelda-botw-temples/11.webp"></p><p>重点在偏移 0x3C 处，这是一个 u32 类型的 flag，其中就包括控制神庙是否显示、是否可传送等等功能！<br>这个函数是控制高塔显示与否的函数，从代码上可以与显示有关的 flag 在第 16、17 位。测试发现控制显示的 flag 是第 16 位（0x8000）。<br><br>flag 的指针链是什么呢？仔细观察代码就可以发现了，和访问次数的指针一样，只是少一级，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[[[main+2CA6460]+240]+340]+58]+1C    初始之塔的次数地址</span><br><span class="line">[[[main+2CA6460]+240]+340]+3C         flag 地址，在次数地址的上一级，偏移 0x3C 处</span><br></pre></td></tr></table></figure><h2 id="传送功能-Flag"><a href="#传送功能-Flag" class="headerlink" title="传送功能 Flag"></a>传送功能 Flag</h2><p>经过反复对比、测试发现，传送 flag 在第 10 位（0x200）。<br>因为根据前面的经验，知道了这个游戏在渲染时不停的写入 flag，所以我们设置写入断点，会找到好几个地方写入，一个个翻一下有没有关于 0x200 立即数的操作，不意外的找到了：</p><p><img src="/images/zelda-botw-temples/12.webp"></p><p>来到 IDA 中看看清楚：</p><p><img src="/images/zelda-botw-temples/13.webp"></p><p>我们只需要修改 if 判断语句即可，让它始终写入传送 flag。</p><h2 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h2><p>前面的金手指都是用的 nop 指令，发现一个小问题，对于<code>托·库摩神庙</code>神庙有时候没有效果，有时候又能显示。<br>所以最终我改用了修改 flag 的方式做金手指，这样更稳妥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[显示神庙位置]</span><br><span class="line">04000000 0109DFB8 D503201F</span><br><span class="line">04000000 0109DFD4 1A8B116A</span><br><span class="line">04000000 0109DFF0 1A8AC149</span><br><span class="line"></span><br><span class="line">04000000 0109EFE0 D503201F</span><br><span class="line">04000000 0109F004 1A8B116A</span><br><span class="line">04000000 0109F020 1A8AC149</span><br><span class="line"></span><br><span class="line">[显示高塔位置]</span><br><span class="line">04000000 0109FA54 1A8B116A</span><br><span class="line">04000000 0109FA70 1A8AC149</span><br><span class="line"></span><br><span class="line">[显示古代研究所位置]</span><br><span class="line">04000000 010A2134 1A8B116A</span><br><span class="line">04000000 010A2150 1A8AC149</span><br><span class="line"></span><br><span class="line">[显示神兽位置]</span><br><span class="line">04000000 010A1974 1A8B116A</span><br><span class="line">04000000 010A1990 1A8AC149</span><br><span class="line"></span><br><span class="line">[已显示地点可传送]</span><br><span class="line">04000000 0109CC38 1A881108</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://www.tekqart.com/thread-310724-1-1.html">『塞尔达-旷野之息』神庙高塔全标记初始存档及修改方法</a><br><a href="https://www.tekqart.com/thread-289845-1-1.html">【金手指教程5】解鎖 FPS , MultiSearch 及 簡易找指針方法</a><br><a href="https://www.tekqart.com/thread-308956-1-1.html">【金手指教程6】对比存档找出想要的资料</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 塞尔达传说 </tag>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Breeze 配合 IDA 修改游戏逻辑</title>
      <link href="/2024/01/05/breeze-ida/"/>
      <url>/2024/01/05/breeze-ida/</url>
      
        <content type="html"><![CDATA[<p><a href="/2023/12/31/ns-make-cheatcode/">上一次</a> 学习了如何制作金手指文件。不过那个例子是改的游戏数据而非代码，这次学习如何修改游戏代码。</p><h2 id="查找游戏数据"><a href="#查找游戏数据" class="headerlink" title="查找游戏数据"></a>查找游戏数据</h2><p>还是以<code>塞尔达传说：旷野之息</code>为例。游戏信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TID：01007EF00011E000</span><br><span class="line">BID：8E9978D50BDD20B4</span><br></pre></td></tr></table></figure><p>这次修改精力值，因为精力值不显示具体的数字，所以需要用模糊搜索。Breeze 中的模糊搜索功能是 Memory Dump。<br>模糊搜索过程就不细讲了，无非就是让林克跑动一下让精力值不停变化、查找，如此循环。。。<br>最后确认精力数据地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前精力：heap + A74F9EDC</span><br><span class="line">最大精力：heap + A74F9EE0</span><br></pre></td></tr></table></figure><p>数据类型为<code>float</code>，占 4 字节。测试发现每一圈精力值对应值是 1000。那么在这个游戏中精力最大为三圈，也就是 3000。<br>虽然我们可以锁定这个值达到无限精力的目的，但是直接改数据会造成精力圈闪烁，游戏体验不好。<br>我期望的是跑步时不会出现精力圈，也就是修改游戏逻辑，让跑步所消耗的精力为零。</p><h2 id="查找数据写入位置"><a href="#查找数据写入位置" class="headerlink" title="查找数据写入位置"></a>查找数据写入位置</h2><p>利用 Breeze 的断点功能，对精力值位置 <code>heap + A74F9EDC</code> 处设置写入断点<br><img src="/images/breeze-ida/03.webp"></p><p>回到游戏，跑动一下减少精力值，再切回修改器。发现一处写入位置 <code>main + 0x00F70024</code><br><img src="/images/breeze-ida/04.webp"></p><p>虽然 Breeze 中也可以看到汇编代码，但是远不如 IDA 显示的多，操作起来也不方便。<br><img src="/images/breeze-ida/05.webp"></p><p>所以我们需要到 IDA 中来查看相关代码。</p><h2 id="提取游戏-NSO-文件"><a href="#提取游戏-NSO-文件" class="headerlink" title="提取游戏 NSO 文件"></a>提取游戏 NSO 文件</h2><p>NSO 文件类似于 Windows 系统上的 EXE&#x2F;DLL 文件，其中包含着游戏逻辑代码。我们需要提取出来然后在 IDA 中查看它。<br>准备工具：</p><ol><li>游戏文件管理工具 <a href="http://www.ffhome.com/works/1814.html">NSGame Manager</a>。用于提取游戏NSO文件。</li><li>IDA 插件 <a href="https://github.com/pgarba/SwitchIDAProLoader">SwitchIDAProLoader</a>。用于静态分析NSO文件。</li></ol><p>在 NSGame Manager 中加载游戏文件（nsp、xci），找到版本最新且 ROM 为 UPD 的包（对于没有补丁的游戏那就只有一个 ROM 为 APP 的包），选择右侧“工具”页面，然后选择容量最大的 NCA，点击“提取并解包NCA”即可，如图：<br><img src="/images/breeze-ida/01.webp"></p><p>会提取出一个没有扩展名的名为<code>main</code>的文件，它就是 NSO 文件。用 SwitchIDAProLoader 插件加载它<br><img src="/images/breeze-ida/02.webp"></p><h2 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h2><p>前面分析发现写入精力的地方是 <code>main + 0x00F70024</code>。我们在 IDA 中来到偏移 <code>0x00F70024</code> 的地方。可以看到汇编代码和 Breeze 捕捉到的地方是一样的，说明找对地方了。<br><img src="/images/breeze-ida/06.webp"></p><p>此时用 IDA 强大的 F5 还原成伪代码<br><img src="/images/breeze-ida/07.webp"></p><p>把这条语句 <code>NOP</code> 掉就可以达到锁定精力值的目的了。但有个不算是问题的问题，精力值虽然不会减少，但也不会增加，而我希望可以恢复精力，而不减少精力。<br>接着就是在 IDA 中静态分析这个函数，同时在 Breeze 中修改指令。来回几轮测试后找到关键语句：</p><p><img src="/images/breeze-ida/08.webp"></p><p>精力是从这个地址取的，是一个固定的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qword_7102CA1140 + 0xA4</span><br></pre></td></tr></table></figure><p>所以，精力的金手指格式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main + 2CA1140] + 0xA4</span><br></pre></td></tr></table></figure><p>写入精力值这一行代码在偏移 <code>0x00F6FF50</code> 处，看看汇编代码<br><img src="/images/breeze-ida/09.webp"></p><p>将汇编改为 <code>fmov s8, s0</code>可以避免进行减法操作<br><img src="/images/breeze-ida/10.webp"></p><p>现在可以制作金手指了。注意，金手指中的机器码要用大端方式。可以在 <a href="https://armconverter.com/">ARM to HEX Converter</a> 这样的网站中计算转换后的机器码。<br>勾选右上角，以大端方式转换。<br><img src="/images/breeze-ida/11.webp"></p><p>最终金手指文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[精力不减 开]</span></span><br><span class="line">04000000 00F6FF50 1E204008</span><br><span class="line"></span><br><span class="line"><span class="section">[精力不减 关]</span></span><br><span class="line">04000000 00F6FF50 1E202908</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://www.tekqart.com/thread-329093-1-1.html">使用Breeze在switch实机上对游戏进行汇编修改</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作 Switch 游戏金手指文件</title>
      <link href="/2023/12/31/ns-make-cheatcode/"/>
      <url>/2023/12/31/ns-make-cheatcode/</url>
      
        <content type="html"><![CDATA[<h2 id="作弊工具"><a href="#作弊工具" class="headerlink" title="作弊工具"></a>作弊工具</h2><p>目前在大气层系统中，作弊工具有两个：<a href="https://github.com/tomvita/EdiZon-SE">EdiZon SE</a> 和 <a href="https://github.com/tomvita/Breeze-Beta">Breeze</a>。都出自同一个作者。<br>EdiZon SE 是老牌工具，UI 操作反人类，相关教程与工具会多一写。<br>Breeze 是新秀，UI 更人性化，速度更快，支持修改汇编代码。</p><h2 id="内存区域概念"><a href="#内存区域概念" class="headerlink" title="内存区域概念"></a>内存区域概念</h2><p>作弊分为两类，修改游戏数据和修改游戏逻辑代码。</p><ol><li>修改数据：向内存区域写入数据，比如将金币改为 9999。这种方式不需要了解汇编代码。</li><li>修改逻辑：改变程序的执行逻辑，比如购买物品会扣掉 100 金币，改为购买物品增加 100 金币。</li></ol><p><br>无论是哪种方式，都需要先找到要修改的内存地址，而内存地址可能是会随着每次启动游戏而变动的。<br>为了搞清有哪些内存区域，可以用在 IDA 附加后，在下方命令栏输入<code>get info</code>查询，得到信息如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GDB&gt;get info</span><br><span class="line">Process:     0x89 (Application)</span><br><span class="line">Program Id:  0x01007ef00011e000</span><br><span class="line">Application: 1</span><br><span class="line">Hbl:         0</span><br><span class="line">Layout:</span><br><span class="line">  Alias: 0x5b9a200000 - 0x6b9a1fffff</span><br><span class="line">  Heap:  0x765e400000 - 0x785e3fffff</span><br><span class="line">  Aslr:  0x0008000000 - 0x7fffffffff</span><br><span class="line">  Stack: 0x6f25a00000 - 0x6fa59fffff</span><br><span class="line">Modules:</span><br><span class="line">  0x350d600000 - 0x350d601fff nnrtld.elf</span><br><span class="line">  0x350d604000 - 0x350f72dfff U-King.nss</span><br><span class="line">  0x351036a000 - 0x35106ddfff multimedia.elf</span><br><span class="line">  0x3510a87000 - 0x3510fb4fff nnSdk.elf</span><br></pre></td></tr></table></figure><p>留意后缀为 .nss 的模块，这是主程序的代码区，也就是所谓的 Main 区段，当我们要修改程序逻辑的时候就是针对这一块区域。<br>另一个要关注的就是 Heap 区段，几乎绝大多数游戏数据都会在这一块区域。</p><p>另外，也可以用 Breeze 来查看游戏内存布局信息：</p><p><img src="/images/ns-make-cheatcode/01.webp"></p><h2 id="制作金手指文件"><a href="#制作金手指文件" class="headerlink" title="制作金手指文件"></a>制作金手指文件</h2><p>这里以<code>塞尔达传说：旷野之息</code>为例。游戏信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TID：01007EF00011E000</span><br><span class="line">BID：8E9978D50BDD20B4</span><br></pre></td></tr></table></figure><p>数据搜索过程很简单就不多说了。卢比的修改地址是：<br>真实数值：heap + 0E435B40<br>显示数值：heap + A0E26620<br><br>金手指文件格式是怎样的呢？不得不先看看大气层官方文档 <a href="https://github.com/Atmosphere-NX/Atmosphere/blob/master/docs/features/cheats.md#cheat-code-format">作弊码格式</a> 一节。<br>卢比是 u32 类型，占用 4 字节。并且我们是向 Heap 区域写入，那么最终的金手指格式如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[10000 卢比]</span></span><br><span class="line">04100000 0E435B40 00002710</span><br><span class="line">04100000 A0E26620 00002710</span><br></pre></td></tr></table></figure><p>第一部分是操作码，第二部分是前面内存偏移地址，第三部分是待写入的值。</p><p>然后将文件保存到<code>sdmc:/atmosphere/contents/&#123;TID&#125;/cheats/&#123;BID&#125;.txt</code>。<br>其中 TID 是应用的标识符，每个程序唯一的。BID 对应该游戏的不同版本，每个版本有不同的 BID。<br><br>最后看看效果，成功！</p><p><img src="/images/ns-make-cheatcode/02.webp"></p><h2 id="搜索指针"><a href="#搜索指针" class="headerlink" title="搜索指针"></a>搜索指针</h2><p>实际上，heap 的地址是不稳定的，是易变的。虽然不知道为什么我重开游戏后金手指仍然有效，但是要稳定的话还是建议用指针定位内存地址。<br><br>用 <a href="https://github.com/tomvita/Noexes">JNoexs</a> 附加到游戏，搜索一次数据后软件会在当前目录<code>tmp</code>下生成一个<code>.dmp</code>文件。<br>第一次搜索数据需要很长时间，因为是全内存搜索。搜索时切记不要让 Switch 息屏，否则软件会停止工作。</p><p>然后切换到<code>Pointer Search</code>页面，<code>Dump File</code>选择刚才产生的<code>.dmp</code>文件，<code>Address</code>选择数据内存地址，<code>main</code>填入 main 区起始地址，其他设置保持默认就行了</p><p><img src="/images/ns-make-cheatcode/03.webp"></p><p>运气好的话，<code>Output</code>区域会显示一个结果，那么就可以制作金手指了。<br>但如果结果非常多，那么就尝试将<code>Max Offset</code>设置更大些再搜索。<br><br>用指针定位内存地址的方式在制作金手指时要稍微复杂一点点，可以用 <a href="http://ruisan.blog.jp/Simple%20SX%20OS%20Code%20Builder%20-%20.beta7.exe">Simple SX OS Code Builder</a> 这款工具来生成金手指代码。</p><p><img src="/images/ns-make-cheatcode/04.webp"></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://gist.github.com/xfangfang/167865cd4a7be03d912df4f149ce263d">GDB for Switch Modding Cheatsheet&#x2F;Tutorial</a><br><a href="https://github.com/Atmosphere-NX/Atmosphere/blob/master/docs/features/cheats.md">Cheats</a><br><a href="https://ruisan.blog.jp/archives/4327227.html">Swtich金手指制作 指针寻找 Noexes使用全面教程</a><br><a href="https://www.tekqart.com/thread-161094-1-1.html">Jnoexs查找指针地址金手指代码制作</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 IDA 调试 Switch 游戏</title>
      <link href="/2023/12/31/ns-ida-debug/"/>
      <url>/2023/12/31/ns-ida-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="附加进程"><a href="#附加进程" class="headerlink" title="附加进程"></a>附加进程</h2><p>确保 <a href="https://github.com/Atmosphere-NX/Atmosphere/">Atmosphere</a> 系统在 v1.2.3 及以上。<br>开启系统 gdbstub 选项。修改<code>sdmc:/atmosphere/config/system_settings.ini</code>文件，确保文件中包含以下设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[atmosphere]</span></span><br><span class="line"><span class="attr">enable_htc</span> = u8!<span class="number">0</span>x0</span><br><span class="line"><span class="attr">enable_standalone_gdbstub</span> = u8!<span class="number">0</span>x1</span><br></pre></td></tr></table></figure><p>接着启动 IDA，依次点击菜单<code>Debugger &gt; Attach &gt; Remote GDB Debugger</code>，出现以下对话框：</p><p><img src="/images/ns-ida-debug_01.webp"></p><p>Hostname 就填写 Switch 的网络地址。Port 是固定的 22225，且不可更改。<br>按照图中指示，依次点击<code>Debug options &gt; Set specific options</code>，将架构改为 ARM64。</p><p><img src="/images/ns-ida-debug_02.webp"><br><img src="/images/ns-ida-debug_03.webp"></p><p>此时先启动游戏，然后再在 IDA 中附加远程进程：</p><p><img src="/images/ns-ida-debug_04.webp"></p><p>拉到窗口最下，ID 最大的那个就是刚启动的游戏进程，附加它。</p><h3 id="区段识别"><a href="#区段识别" class="headerlink" title="区段识别"></a>区段识别</h3><p>此时进程的内存区都载入了，但是分不清堆、栈等区段。此时就需要跑一下网友 <a href="https://www.tekqart.com/space-uid-2551322.html">Eiffel2018</a> 制作的 IDA 脚本文件。（脚本发布于 <a href="https://www.tekqart.com/thread-289399-1-1.html">【金手指教程1】如何使用 IDA Pro 的 GDB 除错器</a>）</p><p><img src="/images/ns-ida-debug_05.webp"></p><p>其他下载地址：<a href="https://p.shipengliang.com/f/11753764-858159738-9a7583">https://p.shipengliang.com/f/11753764-858159738-9a7583</a>。<br>为了避免链接失效，我将脚本直接贴出来，分为32位和64位两种版本。<br>32位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----- Script created by Eiffel2018 -----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">info = send_dbg_command(<span class="string">&#x27;get info&#x27;</span>)</span><br><span class="line">infoheader, dummy, infobody = info.partition(<span class="string">&#x27;\nLayout:\n&#x27;</span>)</span><br><span class="line">layout, dummy, modules = infobody.partition(<span class="string">&#x27;\nModules:\n&#x27;</span>)</span><br><span class="line">regions = ida_idd.meminfo_vec_t()</span><br><span class="line"><span class="keyword">for</span> region <span class="keyword">in</span> layout.splitlines():</span><br><span class="line">    name, start, end = re.split(<span class="string">&#x27;[:|-]&#x27;</span>,region.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;Alias&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;Heap&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;Stack&#x27;</span>): </span><br><span class="line">        <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">        info = ida_idd.memory_info_t()</span><br><span class="line">        info.name = name.lower()</span><br><span class="line">        info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">        info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">        info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">        info.sbase = <span class="number">0</span></span><br><span class="line">        info.bitness = <span class="number">1</span></span><br><span class="line">        info.perm = <span class="number">6</span></span><br><span class="line">        regions.push_back(info)</span><br><span class="line">lastend=<span class="number">0</span></span><br><span class="line">lastbase=<span class="number">0</span></span><br><span class="line">lastname=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> region <span class="keyword">in</span> modules.splitlines():</span><br><span class="line">    start, end, name = region.strip().replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    name, dummy, ext = name.partition(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nss&#x27;</span>): </span><br><span class="line">        name=<span class="string">&#x27;main&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nrs.elf&#x27;</span>): </span><br><span class="line">        name=<span class="string">&#x27;nro&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (lastend&gt;<span class="number">0</span>):</span><br><span class="line">        info = ida_idd.memory_info_t()</span><br><span class="line">        info.name = lastname + <span class="string">&#x27;-data&#x27;</span></span><br><span class="line">        info.start_ea = lastend</span><br><span class="line">        info.end_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">        info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">        <span class="comment"># info.sbase = lastbase</span></span><br><span class="line">        info.sbase = <span class="number">0</span></span><br><span class="line">        info.bitness = <span class="number">1</span></span><br><span class="line">        info.perm = <span class="number">6</span></span><br><span class="line">        regions.push_back(info)</span><br><span class="line">        <span class="built_in">print</span>(lastname + <span class="string">&#x27;-data&#x27;</span>, <span class="built_in">hex</span>(lastend), start)</span><br><span class="line">        lastend=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;saltysd_core&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;saltysd_core-data&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;-data&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># if (name==&#x27;nnSdk&#x27;):</span></span><br><span class="line">        <span class="comment"># continue</span></span><br><span class="line">    <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">    info = ida_idd.memory_info_t()</span><br><span class="line">    info.name = name</span><br><span class="line">    info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">    info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">    info.sclass = <span class="string">&#x27;CODE&#x27;</span></span><br><span class="line">    info.sbase = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;main&#x27;</span>):</span><br><span class="line">        info.sbase = <span class="built_in">int</span>(start[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">    info.bitness = <span class="number">1</span></span><br><span class="line">    info.perm = <span class="number">5</span></span><br><span class="line">    regions.push_back(info)</span><br><span class="line">    lastend=info.end_ea</span><br><span class="line">    lastbase=info.sbase</span><br><span class="line">    lastname=info.name</span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nrs.elf&#x27;</span>): </span><br><span class="line">        mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">        start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextName==<span class="string">&#x27;AliasCode&#x27;</span>):</span><br><span class="line">            name=<span class="string">&#x27;nro-static&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            info = ida_idd.memory_info_t()</span><br><span class="line">            info.name = name</span><br><span class="line">            info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">            info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">            info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">            info.sbase = <span class="number">0</span></span><br><span class="line">            info.bitness = <span class="number">1</span></span><br><span class="line">            info.perm = <span class="number">4</span></span><br><span class="line">            regions.push_back(info)</span><br><span class="line">            lastend=info.end_ea</span><br><span class="line">            lastbase=info.sbase</span><br><span class="line">            lastname=info.name</span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextName==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">            name=<span class="string">&#x27;nro-data&#x27;</span></span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start2, end2, dummy, nextName2, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextName2==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">                end = end2</span><br><span class="line">                mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">                start2, end2, dummy, nextName2, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">                <span class="keyword">if</span> (nextName2==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">                    end = end2</span><br><span class="line">            <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            info = ida_idd.memory_info_t()</span><br><span class="line">            info.name = name</span><br><span class="line">            info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">            info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">            info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">            info.sbase = <span class="number">0</span></span><br><span class="line">            info.bitness = <span class="number">1</span></span><br><span class="line">            info.perm = <span class="number">6</span></span><br><span class="line">            regions.push_back(info)</span><br><span class="line">            lastend=info.end_ea</span><br><span class="line">            lastbase=info.sbase</span><br><span class="line">            lastname=info.name</span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">            lastend=<span class="number">0</span></span><br><span class="line">ida_dbg.set_manual_regions(regions)</span><br><span class="line">ida_dbg.enable_manual_regions(<span class="number">0</span>)</span><br><span class="line">ida_dbg.refresh_debugger_memory()</span><br><span class="line">ida_dbg.enable_manual_regions(<span class="number">1</span>)</span><br><span class="line">ida_dbg.refresh_debugger_memory()</span><br><span class="line">ida_dbg.edit_manual_regions()</span><br><span class="line">pc = idaapi.get_reg_val(<span class="string">&#x27;PC&#x27;</span>)</span><br><span class="line">ida_kernwin.jumpto(pc)</span><br><span class="line">ida_kernwin.refresh_idaview_anyway()</span><br></pre></td></tr></table></figure><p>64位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----- Script created by Eiffel2018 -----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">info = send_dbg_command(<span class="string">&#x27;get info&#x27;</span>)</span><br><span class="line">infoheader, dummy, infobody = info.partition(<span class="string">&#x27;\nLayout:\n&#x27;</span>)</span><br><span class="line">layout, dummy, modules = infobody.partition(<span class="string">&#x27;\nModules:\n&#x27;</span>)</span><br><span class="line">regions = ida_idd.meminfo_vec_t()</span><br><span class="line"><span class="keyword">for</span> region <span class="keyword">in</span> layout.splitlines():</span><br><span class="line">    name, start, end = re.split(<span class="string">&#x27;[:|-]&#x27;</span>,region.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;Alias&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;Heap&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;Stack&#x27;</span>): </span><br><span class="line">        <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">        info = ida_idd.memory_info_t()</span><br><span class="line">        info.name = name.lower()</span><br><span class="line">        info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">        info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">        info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">        info.sbase = <span class="number">0</span></span><br><span class="line">        info.bitness = <span class="number">2</span></span><br><span class="line">        info.perm = <span class="number">6</span></span><br><span class="line">        regions.push_back(info)</span><br><span class="line">lastend=<span class="number">0</span></span><br><span class="line">lastbase=<span class="number">0</span></span><br><span class="line">lastname=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> region <span class="keyword">in</span> modules.splitlines():</span><br><span class="line">    start, end, name = region.strip().replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    name, dummy, ext = name.partition(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nss&#x27;</span>): </span><br><span class="line">        name=<span class="string">&#x27;main&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nrs.elf&#x27;</span>): </span><br><span class="line">        name=<span class="string">&#x27;nro&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (lastend&gt;<span class="number">0</span>):</span><br><span class="line">        info = ida_idd.memory_info_t()</span><br><span class="line">        info.name = lastname + <span class="string">&#x27;-data&#x27;</span></span><br><span class="line">        info.start_ea = lastend</span><br><span class="line">        info.end_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">        info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">        <span class="comment"># info.sbase = lastbase</span></span><br><span class="line">        info.sbase = <span class="number">0</span></span><br><span class="line">        info.bitness = <span class="number">2</span></span><br><span class="line">        info.perm = <span class="number">6</span></span><br><span class="line">        regions.push_back(info)</span><br><span class="line">        <span class="built_in">print</span>(lastname + <span class="string">&#x27;-data&#x27;</span>, <span class="built_in">hex</span>(lastend), start)</span><br><span class="line">        lastend=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;saltysd_core&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;saltysd_core-data&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> name==<span class="string">&#x27;-data&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># if (name==&#x27;nnSdk&#x27;):</span></span><br><span class="line">        <span class="comment"># continue</span></span><br><span class="line">    <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">    info = ida_idd.memory_info_t()</span><br><span class="line">    info.name = name</span><br><span class="line">    info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">    info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">    info.sclass = <span class="string">&#x27;CODE&#x27;</span></span><br><span class="line">    info.sbase = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (name==<span class="string">&#x27;main&#x27;</span>):</span><br><span class="line">        info.sbase = <span class="built_in">int</span>(start[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">    info.bitness = <span class="number">2</span></span><br><span class="line">    info.perm = <span class="number">5</span></span><br><span class="line">    regions.push_back(info)</span><br><span class="line">    lastend=info.end_ea</span><br><span class="line">    lastbase=info.sbase</span><br><span class="line">    lastname=info.name</span><br><span class="line">    <span class="keyword">if</span> (ext==<span class="string">&#x27;nrs.elf&#x27;</span>): </span><br><span class="line">        mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">        start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextName==<span class="string">&#x27;AliasCode&#x27;</span>):</span><br><span class="line">            name=<span class="string">&#x27;nro-static&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            info = ida_idd.memory_info_t()</span><br><span class="line">            info.name = name</span><br><span class="line">            info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">            info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">            info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">            info.sbase = <span class="number">0</span></span><br><span class="line">            info.bitness = <span class="number">2</span></span><br><span class="line">            info.perm = <span class="number">4</span></span><br><span class="line">            regions.push_back(info)</span><br><span class="line">            lastend=info.end_ea</span><br><span class="line">            lastbase=info.sbase</span><br><span class="line">            lastname=info.name</span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextName==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">            name=<span class="string">&#x27;nro-data&#x27;</span></span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start2, end2, dummy, nextName2, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextName2==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">                end = end2</span><br><span class="line">                mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">                start2, end2, dummy, nextName2, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">                <span class="keyword">if</span> (nextName2==<span class="string">&#x27;AliasCodeData&#x27;</span>):</span><br><span class="line">                    end = end2</span><br><span class="line">            <span class="built_in">print</span>(name, start, <span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            info = ida_idd.memory_info_t()</span><br><span class="line">            info.name = name</span><br><span class="line">            info.start_ea = <span class="built_in">int</span>(start,<span class="number">16</span>)</span><br><span class="line">            info.end_ea = <span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span></span><br><span class="line">            info.sclass = <span class="string">&#x27;DATA&#x27;</span></span><br><span class="line">            info.sbase = <span class="number">0</span></span><br><span class="line">            info.bitness = <span class="number">2</span></span><br><span class="line">            info.perm = <span class="number">6</span></span><br><span class="line">            regions.push_back(info)</span><br><span class="line">            lastend=info.end_ea</span><br><span class="line">            lastbase=info.sbase</span><br><span class="line">            lastname=info.name</span><br><span class="line">            mapping = send_dbg_command(<span class="string">&#x27;get mapping &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">int</span>(end,<span class="number">16</span>)+<span class="number">1</span>))</span><br><span class="line">            start, end, dummy, nextName, dummy = mapping.replace(<span class="string">&#x27; - &#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>, <span class="number">4</span>);</span><br><span class="line">            lastend=<span class="number">0</span></span><br><span class="line">ida_dbg.set_manual_regions(regions)</span><br><span class="line">ida_dbg.enable_manual_regions(<span class="number">0</span>)</span><br><span class="line">ida_dbg.refresh_debugger_memory()</span><br><span class="line">ida_dbg.enable_manual_regions(<span class="number">1</span>)</span><br><span class="line">ida_dbg.refresh_debugger_memory()</span><br><span class="line">ida_dbg.edit_manual_regions()</span><br><span class="line">pc = idaapi.get_reg_val(<span class="string">&#x27;PC&#x27;</span>)</span><br><span class="line">ida_kernwin.jumpto(pc)</span><br><span class="line">ida_kernwin.refresh_idaview_anyway()</span><br></pre></td></tr></table></figure><p>回到 IDA 中，依次点击菜单<code>File &gt; Script file</code>，或者用快捷键<code>ALT + F7</code>运行脚本。</p><p><img src="/images/ns-ida-debug_06.webp"></p><p>都识别出来了，没问题。<br>自己动手搜过数据的都知道，我们主要关心的就是代码区 main 和数据区 heap。</p><h2 id="编辑机器码"><a href="#编辑机器码" class="headerlink" title="编辑机器码"></a>编辑机器码</h2><p>现在假设我们已经找到了需要修改程序逻辑的地方，如何在 IDA 中方便的编辑呢？答案是 <a href="https://github.com/keystone-engine/keypatch">keypatch</a> 插件。<br>这个插件依赖两个 python 包，确保已经安装了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install six</span><br><span class="line">pip install keystone-engine</span><br></pre></td></tr></table></figure><p>然后将 <a href="https://github.com/keystone-engine/keypatch/raw/master/keypatch.py">keypatch.py</a> 文件保存到 IDA 的 plugins 目录中即可。</p><p>接着在 main 区段中要编辑的地方点击右键，会有一个 Keypatch 菜单项。</p><p><img src="/images/ns-ida-debug_07.webp"></p><p>或者直接按<code>Ctrl + Alt + K</code>快捷键启动编辑对话框</p><p><img src="/images/ns-ida-debug_08.webp"></p><p>输入要修改的语句，按下 Patch 按钮完成编辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能是因为大气层系统 GDBstub 是实验性的问题，动态调式很容易让程序崩溃，所以并不怎么好用。主要还是要靠金手指工具搜索。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://gist.github.com/jam1garner/c9ba6c0cff150f1a2480d0c18ff05e33">https://gist.github.com/jam1garner/c9ba6c0cff150f1a2480d0c18ff05e33</a><br><a href="https://shipengliang.com/games/switch-%E9%87%91%E6%89%8B%E6%8C%87%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ida-pro-%E7%9A%84-gdb-%E8%B0%83%E8%AF%95%E5%99%A8.html">Switch 金手指制作教程二：如何使用 IDA Pro 的 GDB 调试器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的内存泄露方式</title>
      <link href="/2023/12/01/net-memory-leak/"/>
      <url>/2023/12/01/net-memory-leak/</url>
      
        <content type="html"><![CDATA[<p>本以为带有<code>GC</code>功能的 C# 不会有内存泄露问题，原来我天真了，其实 C# 也会有内存泄露问题，只是不像 C&#x2F;C++ 那么有负担。</p><h2 id="常见泄露方式"><a href="#常见泄露方式" class="headerlink" title="常见泄露方式"></a>常见泄露方式</h2><p>在 C&#x2F;C++ 语言中，内存泄露是因为分配了内存后未释放，同时没有指针指向它导致的。<br>而在 C# 中，内存泄露是因为内存被引用了，但引用这块内存的实例却从不会被访问到，从而导致 GC 无法回收它。</p><h3 id="未取消事件订阅"><a href="#未取消事件订阅" class="headerlink" title="未取消事件订阅"></a>未取消事件订阅</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event handled by Subscriber&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line">        subscriber.Subscribe(publisher);</span><br><span class="line">        publisher.DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Foo(publisher);</span><br><span class="line">        publisher.DoSomething();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外的话，事件处理器会被调用两次。因为 Publisher 实例的 MyEvent 一直持有对 Subscriber 的引用，导致内存泄露。<br>最好的解决方式是手动用<code>-=</code>操作及时取消订阅，这是最好的方式，没有之一。</p><h3 id="使用弱事件模式"><a href="#使用弱事件模式" class="headerlink" title="使用弱事件模式"></a>使用弱事件模式</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/events/weak-event-patterns">弱事件模式</a>（Weak Event Pattern）是一种在事件订阅中使用弱引用的设计模式。它旨在解决常见的事件订阅导致的潜在内存泄漏问题。<br>订阅者对象使用弱引用来订阅事件。通过使用弱引用，订阅者对象可以在没有其他强引用时被垃圾回收，从而避免潜在的内存泄漏问题。当订阅者对象被垃圾回收时，事件发布者不再持有对其的引用，因此不会阻止其被回收。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//publisher.MyEvent += HandleEvent;</span></span><br><span class="line">    </span><br><span class="line">    WeakEventManager&lt;Publisher, EventArgs&gt;.AddHandler(publisher, <span class="keyword">nameof</span>(publisher.MyEvent), HandleEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.weakeventmanager">WeakEventManager</a> 是基础。.NET 内置了一些弱事件类如 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.weakeventmanager-2">WeakEventManager&lt;TEventSource,TEventArgs&gt;</a>、<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.propertychangedeventmanager">PropertyChangedEventManager</a> 等等。<br>再次运行程序，还是会有两次输出，这是因为 GC 没有及时回收 Subscriber，这可能会导致各种意想不到的副作用。所以在使用弱事件时需要注意这个问题。</p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>lambda函数适合作为事件处理器吗？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publisher.MyEvent += (<span class="built_in">object</span> sender, EventArgs args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">this</span>._name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果是 GC 之后处理器仍然会被调用。本质上这个处理器还是强引用，且无法被取消。<br>而如果在这个函数中有任何对类实例的引用，那么也会造成内存泄露。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publisher.MyEvent += (<span class="built_in">object</span> sender, EventArgs args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">this</span>.name); <span class="comment">// 引用了类的字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以为了避免内存泄露，还是要为实例指定一个变量并稍后取消订阅：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventHandler handler = <span class="built_in">delegate</span> (<span class="built_in">object</span> sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//some code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">publisher.MyEvent += handler;</span><br><span class="line">publisher.MyEvent -= handler;</span><br></pre></td></tr></table></figure><h3 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;MyClass&gt; _instances = <span class="keyword">new</span> List&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _instances.Add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>MyClass</code>类的构造函数会将每个新创建的实例添加到一个静态的<code>List&lt;MyClass&gt;</code>集合中。由于<code>List&lt;MyClass&gt;</code>是静态的，它会一直保留对所有实例的引用。这将导致内存泄漏，因为这些对象无法被释放。<br>为了解决这个问题，可以通过添加一个析构函数或者手动释放资源的方法来从<code>_instances</code>集合中移除实例。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;MyClass&gt; _instances = <span class="keyword">new</span> List&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _instances.Add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        _instances.Remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(HandleTick);</span><br><span class="line">        timer.Change(TimeSpan.FromSeconds(<span class="number">5</span>), TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleTick</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有在适当的时候停止或销毁 Timer，它将一直保持对 MyClass 实例的引用，导致内存泄漏。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存泄漏的本质是引用没有被正确释放，导致对象无法被垃圾回收器回收。在 C# 中，垃圾回收器负责自动管理内存，它会跟踪对象之间的引用关系，并在对象不再被引用时，自动回收它们所占用的内存。<br>当一个对象不再被引用时，垃圾回收器会将其标记为可回收。但如果该对象仍然被其他对象引用，或者存在循环引用，垃圾回收器无法判断该对象是否仍然需要保留。这就导致了一个内存泄漏的情况，即对象无法被垃圾回收器正确释放，从而持续占用内存。<br>为了避免内存泄漏，需要及时释放对象的引用。这可以通过手动解除对象之间的引用、及时取消注册事件处理器、释放非托管资源、将静态变量设置为弱引用等方式来实现。这样，垃圾回收器就能够正确地判断对象是否可以被回收，并及时释放对象所占用的内存。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/141032986">可能会导致.NET内存泄露的8种行为</a><br><a href="https://michaelscodingspot.com/5-techniques-to-avoid-memory-leaks-by-events-in-c-net-you-should-know/">5 Techniques to avoid Memory Leaks by Events in C# .NET you should know</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>await TaskYield 的意义</title>
      <link href="/2023/11/23/task-yield/"/>
      <url>/2023/11/23/task-yield/</url>
      
        <content type="html"><![CDATA[<p><code>await Task.Yield()</code>的意义就是一句话：释放控制权，让其他任务得到执行的机会。<br>为什么要这么做呢？主要是 <strong>为了让调用者没有 await 的时候可以立即返回</strong>。<br><br>考虑以下例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Bar(); <span class="comment">// 释放控制权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _ = Test(); <span class="comment">// 不需要等待 Test 执行完成，而是希望尽快返回</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Called Test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Test 方法开头有一段耗时的操作，会阻塞 Foo 一秒钟。直到碰上<code>await</code>释放了控制权，此时由于调用方并没有用<code>await</code>去等待 Test 方法，所以 Foo 才得以继续执行。<br><br>问题是什么呢？问题在于 Foo 希望立即返回，而你（Test方法）却阻塞了我一秒钟！<br>作为异步 API 的设计者，那么就可以在函数开头加上一句<code>await Task.Yield()</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Yield(); <span class="comment">// 立即释放控制权</span></span><br><span class="line"></span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 由于 await 之后重新分配到了新线程上执行，所以不会阻塞调用线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就实现了一个真正的异步方法！但注意这里有个前提，就是 <strong>调用者没有使用 await 去等待时才有意义</strong>。</p><h2 id="为什么不用-Task-CompletedTask？"><a href="#为什么不用-Task-CompletedTask？" class="headerlink" title="为什么不用 Task.CompletedTask？"></a>为什么不用 Task.CompletedTask？</h2><p>从前面的内容来看，要实现一个能立即返回的异步方法，重点就是要尽可能快的调用<code>await</code>以达到释放控制权的目的。<br>那么我们可以去<code>await</code>框架内部的一些特殊的任务，比如 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.completedtask">Task.CompletedTask</a>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Test1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.CompletedTask; <span class="comment">// 因为是一个已完成的任务，所以不会释放控制权</span></span><br><span class="line"></span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 依然在调用线程上执行，导致阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Task.CompletedTask</code>是一个已经完成的 Task 对象，它表示一个不返回任何结果的已完成任务。它会立即返回，并且不会引发线程切换。因为任务已经完成，不需要等待。<br>所以它和<code>Task.Yield</code>不是一回事。</p><h2 id="Task-Delay-0-呢？"><a href="#Task-Delay-0-呢？" class="headerlink" title="Task.Delay(0) 呢？"></a>Task.Delay(0) 呢？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Test1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">0</span>); <span class="comment">// 等同于 Task.CompletedTask</span></span><br><span class="line"></span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 依然在调用线程上执行，导致阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/microsoft/referencesource/blob/master/mscorlib/system/threading/Tasks/Task.cs#L5863">Task.Delay</a> 实现中，延迟时间为 0 时将会返回<code>Task.CompletedTask</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/22645024/">When would I use Task.Yield()?</a><br><a href="https://blog.walterlv.com/post/sleep-delay-zero-vs-yield.html">C#&#x2F;.NET 中 Thread.Sleep(0), Task.Delay(0), Thread.Yield(), Task.Yield() 不同的执行效果和用法建议</a><br><a href="https://www.cnblogs.com/OpenCoder/p/12201446.html">await Task.Yield()和await Task.CompletedTask有什么不同</a><br><a href="https://www.cnblogs.com/dudu/p/task-yield.html">终于明白了 C# 中 Task.Yield 的用途</a><br><a href="https://stackoverflow.com/questions/33407007/">Task.Delay(0) not asynchronous</a><br><a href="https://stackoverflow.com/questions/18527149/">Task.Yield() versus Task.Delay(0)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步不是线程</title>
      <link href="/2023/11/22/async-not-thread/"/>
      <url>/2023/11/22/async-not-thread/</url>
      
        <content type="html"><![CDATA[<p>我和很多人一样，刚学着使用<code>async</code>方法时以为是会新开一个线程并执行代码。心想有了这玩意还要<code>Thread</code>、<code>Task</code>干嘛。。。<br>而实时并非如此。<br><br>线程的问题就是会造成 CPU 资源的浪费。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>); <span class="comment">// 模拟某种耗时的操作。在此期间界面无法响应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个方法是在 UI 线程上执行的，所以整个线程被冻结了，导致界面无法响应。在此期间该线程无事可做，这就是资源的浪费。<br><br>如果用异步就不同了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>); <span class="comment">// 与 Thread.Sleep 不同的是，await 不会阻塞线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遇到 await 表达式时，它会暂停当前方法的执行，并返回控制权给调用者，使得线程可以执行其他工作，比如响应 UI。<br>一旦可等待对象操作完成，await 表达式就会返回并继续执行后面的代码。<br><br>注意，await 后面的代码可能会与之前的代码运行在不同的线程上，这取决于<code>SynchronizationContext</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">TestAync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仍然在主线程上</span></span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;TestAync: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用原始上下文。await 之后的代码可能会被分配到其他线程上执行</span></span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1</span>).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Sleep 模拟耗时操作，没有冻结 UI 线程，因为此时的线程已经切换到非 UI 线程上了</span></span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与开头的线程ID不同了</span></span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;TestAync: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> TestAync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异步模型解决了在此前开发中的两个痛点：</p><ol><li>解决传统的基于回调的异步编程所带来的一系列问题。使得在异步代码中可以使用类似同步代码的方式来编写异步操作，避免了回调地狱。</li><li>更好地利用线程，<code>await</code>关键字可以使应用程序能够处理更多的并发操作，提高了应用程序的并发性能和吞吐量。</li></ol><br/><ul><li><code>async</code>方法可以通过返回<code>Task</code>、<code>Task&lt;T&gt;</code> 或 <code>void</code>来标记。返回类型为<code>Task</code> 或 <code>Task&lt;T&gt;</code>的方法可以实现异步操作，并在操作完成时提供结果或状态。返回类型为<code>void</code> 的方法通常用于事件处理程序等不需要提供结果的情况。</li><li><code>async</code>方法不会开启新线程。<code>async</code>方法本质上是一个状态机，它可以在执行过程中暂停和恢复，而不会阻塞调用线程。</li><li><code>await</code>会让出当前线程的 CPU 时间片，以允许其他任务在可用的线程上执行。</li><li><code>await</code>之前的代码和之后的代码可能不在同一个线程上，这取决于上下文和调度器。</li><li>可以使用<code>ConfigureAwait(false)</code>来禁用上下文捕获，以避免不必要的线程切换。这在某些情况下可以提高性能，特别是在不需要 UI 上下文的非 UI 代码中。</li><li>异步方法应该遵循一致的命名约定，以便清楚地表示其异步特性，例如在方法名后添加”Async”后缀。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">Async and Await</a><br><a href="https://stackoverflow.com/questions/37419572/">If async-await doesn’t create any additional threads, then how does it make applications responsive?</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDK style 工程文件介绍</title>
      <link href="/2023/11/17/csproj-sdkstyle/"/>
      <url>/2023/11/17/csproj-sdkstyle/</url>
      
        <content type="html"><![CDATA[<p>SDK style 是一种新的项目文件格式。与传统的 .NET Framework 项目文件相比，新的 SDK style 提供了更简洁、可读性更好的语法，同时还引入了更多的灵活性和功能。<br>新风格的 csproj 文件是从 VS2017 版本开始引入和支持的。在 VS2015 和更早的版本，使用的是传统 csproj 文件格式。</p><h2 id="新老工程文件"><a href="#新老工程文件" class="headerlink" title="新老工程文件"></a>新老工程文件</h2><p>先看看老的工程文件是个什么样子。新建一个 .NET Framework 窗体项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;Exists(&#x27;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">Condition</span>=<span class="string">&quot; &#x27;$(Configuration)&#x27; == &#x27;&#x27; &quot;</span>&gt;</span>Debug<span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Platform</span> <span class="attr">Condition</span>=<span class="string">&quot; &#x27;$(Platform)&#x27; == &#x27;&#x27; &quot;</span>&gt;</span>AnyCPU<span class="tag">&lt;/<span class="name">Platform</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectGuid</span>&gt;</span>&#123;013DB7AC-1A98-4BB9-8D01-C6CEA6C8AB78&#125;<span class="tag">&lt;/<span class="name">ProjectGuid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>WinExe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RootNamespace</span>&gt;</span>WindowsFormsApp1<span class="tag">&lt;/<span class="name">RootNamespace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AssemblyName</span>&gt;</span>WindowsFormsApp1<span class="tag">&lt;/<span class="name">AssemblyName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFrameworkVersion</span>&gt;</span>v4.8.1<span class="tag">&lt;/<span class="name">TargetFrameworkVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FileAlignment</span>&gt;</span>512<span class="tag">&lt;/<span class="name">FileAlignment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AutoGenerateBindingRedirects</span>&gt;</span>true<span class="tag">&lt;/<span class="name">AutoGenerateBindingRedirects</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Deterministic</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Deterministic</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot; &#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Debug|AnyCPU&#x27; &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>AnyCPU<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DebugSymbols</span>&gt;</span>true<span class="tag">&lt;/<span class="name">DebugSymbols</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DebugType</span>&gt;</span>full<span class="tag">&lt;/<span class="name">DebugType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Optimize</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Optimize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputPath</span>&gt;</span>bin\Debug\<span class="tag">&lt;/<span class="name">OutputPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span>&gt;</span>DEBUG;TRACE<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ErrorReport</span>&gt;</span>prompt<span class="tag">&lt;/<span class="name">ErrorReport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WarningLevel</span>&gt;</span>4<span class="tag">&lt;/<span class="name">WarningLevel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot; &#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Release|AnyCPU&#x27; &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>AnyCPU<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DebugType</span>&gt;</span>pdbonly<span class="tag">&lt;/<span class="name">DebugType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Optimize</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Optimize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputPath</span>&gt;</span>bin\Release\<span class="tag">&lt;/<span class="name">OutputPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ErrorReport</span>&gt;</span>prompt<span class="tag">&lt;/<span class="name">ErrorReport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WarningLevel</span>&gt;</span>4<span class="tag">&lt;/<span class="name">WarningLevel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Core&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Xml.Linq&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Data.DataSetExtensions&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.CSharp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Data&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Deployment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Drawing&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Net.Http&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Windows.Forms&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Form1.cs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SubType</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">SubType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Compile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Form1.Designer.cs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DependentUpon</span>&gt;</span>Form1.cs<span class="tag">&lt;/<span class="name">DependentUpon</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Compile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Program.cs&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Properties\AssemblyInfo.cs&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">&quot;Properties\Resources.resx&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Generator</span>&gt;</span>ResXFileCodeGenerator<span class="tag">&lt;/<span class="name">Generator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LastGenOutput</span>&gt;</span>Resources.Designer.cs<span class="tag">&lt;/<span class="name">LastGenOutput</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SubType</span>&gt;</span>Designer<span class="tag">&lt;/<span class="name">SubType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EmbeddedResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Properties\Resources.Designer.cs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AutoGen</span>&gt;</span>True<span class="tag">&lt;/<span class="name">AutoGen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DependentUpon</span>&gt;</span>Resources.resx<span class="tag">&lt;/<span class="name">DependentUpon</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Compile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">None</span> <span class="attr">Include</span>=<span class="string">&quot;Properties\Settings.settings&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Generator</span>&gt;</span>SettingsSingleFileGenerator<span class="tag">&lt;/<span class="name">Generator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LastGenOutput</span>&gt;</span>Settings.Designer.cs<span class="tag">&lt;/<span class="name">LastGenOutput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">None</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Compile</span> <span class="attr">Include</span>=<span class="string">&quot;Properties\Settings.Designer.cs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AutoGen</span>&gt;</span>True<span class="tag">&lt;/<span class="name">AutoGen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DependentUpon</span>&gt;</span>Settings.settings<span class="tag">&lt;/<span class="name">DependentUpon</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DesignTimeSharedInput</span>&gt;</span>True<span class="tag">&lt;/<span class="name">DesignTimeSharedInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Compile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">None</span> <span class="attr">Include</span>=<span class="string">&quot;App.config&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(MSBuildToolsPath)\Microsoft.CSharp.targets&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再看看新的工程文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>WinExe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>net7.0-windows<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>高下立判，新风格的工程文件精简多了！</p><h2 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h2><h3 id="OutputType"><a href="#OutputType" class="headerlink" title="OutputType"></a>OutputType</h3><p>用于指定项目输出的文件类型。支持以下值：</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>Library</td><td>DLL 动态库</td></tr><tr><td>Exe</td><td>控制台程序</td></tr><tr><td>WinExe</td><td>窗口程序</td></tr></tbody></table><h3 id="TargetFramework"><a href="#TargetFramework" class="headerlink" title="TargetFramework"></a>TargetFramework</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#targetframework">TargetFramework</a> 用于指定项目的目标框架。它表示项目所针对的特定台或运行时环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>net48<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>支持的值看这里：<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/frameworks#supported-target-frameworks">支持的目标框架</a>。<br>但是一般来说我们不应该指定这个值，而应该用复数版本的参数<code>TargetFrameworks</code>。</p><h3 id="TargetFrameworks"><a href="#TargetFrameworks" class="headerlink" title="TargetFrameworks"></a>TargetFrameworks</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#targetframeworks">TargetFrameworks</a> 允许针对多个不同的目标框架进行构建，每个目标框架通过分号进行分隔：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TargetFrameworks</span>&gt;</span>netcoreapp3.1;net462<span class="tag">&lt;/<span class="name">TargetFrameworks</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是必填的参数，指示工程使用哪些框架编译。</p><h3 id="AppendTargetFrameworkToOutputPath"><a href="#AppendTargetFrameworkToOutputPath" class="headerlink" title="AppendTargetFrameworkToOutputPath"></a>AppendTargetFrameworkToOutputPath</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#appendtargetframeworktooutputpath">AppendTargetFrameworkToOutputPath</a> 属性决定了输出路径中是否追加<code>TargetFramework</code>的值，默认为<code>true</code>。</p><h3 id="PlatformTarget"><a href="#PlatformTarget" class="headerlink" title="PlatformTarget"></a>PlatformTarget</h3><p><code>PlatformTarget</code> 用于指定项目的目标平台。它决定了编译后的文件的实际架构。<br>可能的值：<code>AnyCPU</code>、<code>x86</code>、<code>x64</code>、<code>arm</code>、<code>arm64</code>。<br>来自 <a href="https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.RuntimeIdentifierInference.targets">Microsoft.NET.RuntimeIdentifierInference.targets</a> 文件中的片段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Determine PlatformTarget (if not already set) from runtime identifier. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">When</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(PlatformTarget)&#x27; != &#x27;&#x27; or &#x27;$(RuntimeIdentifier)&#x27; == &#x27;&#x27;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">When</span> <span class="attr">Condition</span>=<span class="string">&quot;$(RuntimeIdentifier.EndsWith(&#x27;-x86&#x27;)) or $(RuntimeIdentifier.Contains(&#x27;-x86-&#x27;))&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">When</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">When</span> <span class="attr">Condition</span>=<span class="string">&quot;$(RuntimeIdentifier.EndsWith(&#x27;-x64&#x27;)) or $(RuntimeIdentifier.Contains(&#x27;-x64-&#x27;))&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>x64<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">When</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">When</span> <span class="attr">Condition</span>=<span class="string">&quot;$(RuntimeIdentifier.EndsWith(&#x27;-arm&#x27;)) or $(RuntimeIdentifier.Contains(&#x27;-arm-&#x27;))&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>arm<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">When</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">When</span> <span class="attr">Condition</span>=<span class="string">&quot;$(RuntimeIdentifier.EndsWith(&#x27;-arm64&#x27;)) or $(RuntimeIdentifier.Contains(&#x27;-arm64-&#x27;))&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>arm64<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">When</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PlatformTarget</span>&gt;</span>AnyCPU<span class="tag">&lt;/<span class="name">PlatformTarget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Choose</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以<code>PlatformTarget</code>不需要手动设置。</p><h3 id="ImplicitUsings"><a href="#ImplicitUsings" class="headerlink" title="ImplicitUsings"></a>ImplicitUsings</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#implicitusings">ImplicitUsings</a> 用于指定在项目代码中隐式引用的命名空间（using）。可以在项目中省略对特定命名空间的显式引用，从而简化代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="UseWindowsForms"><a href="#UseWindowsForms" class="headerlink" title="UseWindowsForms"></a>UseWindowsForms</h3><p>当 <a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props-desktop#usewindowsforms">UseWindowsForms</a> 属性设置为 true 时，项目将引用并使用 Windows Forms 库，以便开发 Windows Forms 应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">UseWindowsForms</span>&gt;</span>true<span class="tag">&lt;/<span class="name">UseWindowsForms</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="UseWPF"><a href="#UseWPF" class="headerlink" title="UseWPF"></a>UseWPF</h3><p>当 <a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props-desktop#usewpf">UseWPF</a> 属性设置为 true 时，项目将引用并使用 WPF 库，以便开发 WPF 程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">UseWPF</span>&gt;</span>true<span class="tag">&lt;/<span class="name">UseWPF</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="RuntimeIdentifier"><a href="#RuntimeIdentifier" class="headerlink" title="RuntimeIdentifier"></a>RuntimeIdentifier</h3><p>RID 是运行时标识符的缩写。 RID 值用于标识应用程序运行所在的目标平台。.NET 包使用它们来表示 NuGet 包中特定于平台的资产。<br>在编译时它会根据<code>PlatformTarget</code>属性自动设置，不需要手动设置。</p><h3 id="AppendRuntimeIdentifierToOutputPath"><a href="#AppendRuntimeIdentifierToOutputPath" class="headerlink" title="AppendRuntimeIdentifierToOutputPath"></a>AppendRuntimeIdentifierToOutputPath</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#appendruntimeidentifiertooutputpath">AppendRuntimeIdentifierToOutputPath</a> 属性决定了输出路径中是否追加<code>RuntimeIdentifier</code>的值，默认为<code>true</code>。</p><h3 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h3><p>是否启用 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可空类型</a> 特性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Nullable</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">Nullable</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 Nullable 设置可以提高代码的可读性、减少潜在的空引用异常，并帮助你编写更健壮和高质量的代码。</p><h3 id="LangVersion"><a href="#LangVersion" class="headerlink" title="LangVersion"></a>LangVersion</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/configure-language-version">LangVersion</a> 用于设置使用 C# 语言的版本。不设置时会有 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/configure-language-version#defaults">默认值</a>。<br>原则上版本越高越好，毕竟使用新特性会使开发效率提高。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/common-msbuild-project-properties">常用的 MSBuild 项目属性</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/overview">.NET 项目 SDK</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/core/rid-catalog">.NET RID 目录</a><br><a href="https://doughnuts.dev/platform-vs-platformtarget/">Platform vs. PlatformTarget In Any .NET Build</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> MSBuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Winforms 中工作线程更新界面的几种方式</title>
      <link href="/2023/11/15/multithreading-ui/"/>
      <url>/2023/11/15/multithreading-ui/</url>
      
        <content type="html"><![CDATA[<p>UI 元素通常是在主线程（UI线程）上创建和操作的。如果在非UI线程上直接更新 UI，可能会导致多个线程同时访问和修改UI元素，从而引发线程安全问题，例如竞态条件、死锁等。<br>在 Winforms 中，如果在工作线程上直接更新 UI，会引发 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception">InvalidOperationException</a> 异常，该异常表示跨线程操作无效。</p><h2 id="Control-CheckForIllegalCrossThreadCalls"><a href="#Control-CheckForIllegalCrossThreadCalls" class="headerlink" title="Control.CheckForIllegalCrossThreadCalls"></a>Control.CheckForIllegalCrossThreadCalls</h2><p>通过将 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.checkforillegalcrossthreadcalls">Control.CheckForIllegalCrossThreadCalls</a> 属性设置为<code>false</code>来禁用跨线程调用的检查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CheckForIllegalCrossThreadCalls = <span class="literal">false</span>;</span><br><span class="line">Task.Run(() =&gt; label1.Text = <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>禁用此检查可能会导致线程安全问题和意外的行为。因此，通常不建议在生产环境中禁用<code>Control.CheckForIllegalCrossThreadCalls</code>检查。除非你知道自己在干什么。</p><h2 id="BackgroundWorker"><a href="#BackgroundWorker" class="headerlink" title="BackgroundWorker"></a>BackgroundWorker</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker">BackgroundWorker</a> 是用于执行后台操作的组件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BackgroundWorker worker;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建BackgroundWorker实例</span></span><br><span class="line">    worker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事件处理程序</span></span><br><span class="line">    worker.DoWork += Worker_DoWork;</span><br><span class="line">    worker.ProgressChanged += Worker_ProgressChanged;</span><br><span class="line">    worker.RunWorkerCompleted += Worker_RunWorkerCompleted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用报告进度和支持取消操作</span></span><br><span class="line">    worker.WorkerReportsProgress = <span class="literal">true</span>;</span><br><span class="line">    worker.WorkerSupportsCancellation = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buttonStart_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动后台操作</span></span><br><span class="line">    worker.RunWorkerAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buttonCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取消后台操作</span></span><br><span class="line">    <span class="keyword">if</span> (worker.IsBusy)</span><br><span class="line">    &#123;</span><br><span class="line">        worker.CancelAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Worker_DoWork</span>(<span class="params"><span class="built_in">object</span> sender, DoWorkEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 后台操作代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查是否取消操作</span></span><br><span class="line">        <span class="keyword">if</span> (worker.CancellationPending)</span><br><span class="line">        &#123;</span><br><span class="line">            e.Cancel = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        Thread.Sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报告进度</span></span><br><span class="line">        worker.ReportProgress(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作完成后，可以将结果存储到e.Result中</span></span><br><span class="line">    e.Result = <span class="string">&quot;操作完成！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Worker_ProgressChanged</span>(<span class="params"><span class="built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 更新UI以显示进度信息</span></span><br><span class="line">    progressBar.Value = e.ProgressPercentage;</span><br><span class="line">    labelProgress.Text = <span class="string">$&quot;进度：<span class="subst">&#123;e.ProgressPercentage&#125;</span>%&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Worker_RunWorkerCompleted</span>(<span class="params"><span class="built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理操作完成后的结果</span></span><br><span class="line">    <span class="keyword">if</span> (e.Cancelled)</span><br><span class="line">    &#123;</span><br><span class="line">        labelResult.Text = <span class="string">&quot;操作被取消&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.Error != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        labelResult.Text = <span class="string">$&quot;错误：<span class="subst">&#123;e.Error.Message&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        labelResult.Text = <span class="string">$&quot;结果：<span class="subst">&#123;e.Result&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从提供的成员方法来看，似乎很适合带有进度条的场景，比如下载、解压等。<br>BackgroundWorker 是较早的异步编程模型，功能相对有限。它不能很好地处理复杂的异步操作，如任务组合和异常处理等。所以不推荐使用。</p><h2 id="Control-Invoke"><a href="#Control-Invoke" class="headerlink" title="Control.Invoke"></a>Control.Invoke</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.invoke">Control.Invoke</a> 方法允许在UI线程上执行代码。可以在工作线程中调用 Control.Invoke 方法，将 UI 更新的代码包装在一个委托中，然后将其传递给 Control.Invoke 来更新UI。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    label1.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        label1.Text = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Debug.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是一个同步方法，会阻塞调用线程直到委托执行完成。</p><h2 id="Control-BeginInvoke"><a href="#Control-BeginInvoke" class="headerlink" title="Control.BeginInvoke"></a>Control.BeginInvoke</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.begininvoke">Control.BeginInvoke</a> 是 Invoke 的异步版本，不会阻塞调用线程。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    label1.BeginInvoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        label1.Text = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Debug.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果需要等待委托返回可以使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.endinvoke">Control.EndInvoke</a> 方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ar = label1.BeginInvoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        label1.Text = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> result = EndInvoke(ar); <span class="comment">// 阻塞当前线程，并得到返回值&quot;result&quot;</span></span><br><span class="line">    Debug.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="SynchronizationContext"><a href="#SynchronizationContext" class="headerlink" title="SynchronizationContext"></a>SynchronizationContext</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext">SynchronizationContext</a> 是一个抽象类，用于提供线程间同步和上下文传递的功能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建UI同步上下文</span></span><br><span class="line"><span class="keyword">var</span> uiSyncContext = SynchronizationContext.Current;</span><br><span class="line"></span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Background thread id: &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用UI同步上下文将任务调度到UI线程上执行</span></span><br><span class="line">    uiSyncContext.Send(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;UI thread id: &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在UI线程上更新UI元素</span></span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Task completed!&quot;</span>);</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext.send">Send</a> 是同步的，会阻塞调用线程。而 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext.post">Post</a> 是异步版本。</p><h2 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskscheduler">TaskScheduler</a> 是一个抽象类，用于定义任务的调度行为。<br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskscheduler.fromcurrentsynchronizationcontext">TaskScheduler.FromCurrentSynchronizationContext</a> 是一个静态方法，它返回与当前同步上下文关联的 TaskScheduler 对象。它可用于在异步操作中将任务调度到当前同步上下文中执行，以确保操作在正确的线程上执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 TaskScheduler.FromCurrentSynchronizationContext 获取与当前同步上下文关联的 TaskScheduler 对象</span></span><br><span class="line">TaskScheduler uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在后台线程上执行异步操作</span></span><br><span class="line"><span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Background thread id: &quot;</span> + System.Threading.Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    Task.Delay(<span class="number">2000</span>).Wait();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 TaskScheduler.FromCurrentSynchronizationContext 将任务调度到UI线程上执行</span></span><br><span class="line">    Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;UI thread id: &quot;</span> + System.Threading.Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在UI线程上更新UI元素</span></span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Task completed!&quot;</span>);</span><br><span class="line">    &#125;, System.Threading.CancellationToken.None, TaskCreationOptions.None, uiScheduler);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这些都是在工作线程更新UI的一些常见方式。以下是对每种方案的简要总结：</p><ul><li><p><code>Control.CheckForIllegalCrossThreadCalls</code>：这是一种简单的方式。但是，这种方式是不安全的，可能导致UI线程和工作线程之间的竞态条件和其他线程安全问题。因此不推荐使用它。</p></li><li><p><code>BackgroundWorker</code>：一个已经废弃的组件。功能相对有限，不适用于复杂的异步操作。因此不推荐使用它。</p></li><li><p><code>Control.Invoke</code>和<code>Control.BeginInvoke</code>：这是使用<code>Control</code>类提供的方法在工作线程上执行操作并在UI线程上更新UI的传统方式。<code>Invoke</code>是同步的，会阻塞调用线程，而<code>BeginInvoke</code>是异步的，不会阻塞。</p></li><li><p><code>SynchronizationContext</code>：用于在不同线程之间同步操作。它提供了<code>Send</code>和<code>Post</code>方法来将操作调度到关联的线程上执行。优点是它提供了更灵活的线程同步和调度机制，并且可以用于管理UI线程之外的其他线程。</p></li><li><p><code>TaskScheduler</code>：用于调度和管理任务的抽象类。通过使用<code>TaskScheduler.FromCurrentSynchronizationContext</code>方法可以将任务调度到 UI 线程上执行。侧重点是任务调度。</p></li></ul><p><br>只是更新 UI 控件的话，推荐用<code>Control.Invoke</code>和<code>Control.BeginInvoke</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft.Extensions.DependencyInjection 入门</title>
      <link href="/2023/11/11/Microsoft-Extensions-DependencyInjection/"/>
      <url>/2023/11/11/Microsoft-Extensions-DependencyInjection/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/">Microsoft.Extensions.DependencyInjection</a> 是 .NET Core 中用于依赖注入的库。<br>但是它也支持 .NET Framework。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IServiceProvider serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">    .AddTransient&lt;IService, Service&gt;()</span><br><span class="line">    .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> service = serviceProvider.GetService&lt;IService&gt;();</span><br><span class="line">service.PrintMessage();</span><br></pre></td></tr></table></figure><p>IServiceCollection：用于注册应用程序所需的服务。并通过<code>BuildServiceProvider</code>方法构建<code>ServiceProvider</code>。<br>IServiceProvider：提供服务的容器。构建<code>ServiceProvider</code>时，<code>IServiceCollection</code>中注册的所有服务都会被实例化，并按照其生命周期进行管理。</p><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><ul><li><p>以三种不同的生命周期方式注册：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddSingleton&lt;IService, Service&gt;();</span><br><span class="line">AddScoped&lt;IService, Service&gt;();</span><br><span class="line">AddTransient&lt;IService, Service&gt;();</span><br></pre></td></tr></table></figure><p>生命周期内容可以看下一节。</p></li><li><p>支持带<code>Key</code>注册服务，以便区分不同的实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceCollection = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = serviceCollection</span><br><span class="line">        .AddKeyedTransient&lt;IServiceA, ServiceA1&gt;(<span class="string">&quot;A1&quot;</span>)</span><br><span class="line">        .AddKeyedTransient&lt;IServiceA, ServiceA2&gt;(<span class="string">&quot;A2&quot;</span>)</span><br><span class="line">        .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = serviceProvider.GetKeyedService&lt;IServiceA&gt;(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    obj.Say();</span><br><span class="line"></span><br><span class="line">    obj = serviceProvider.GetKeyedService&lt;IServiceA&gt;(<span class="string">&quot;A2&quot;</span>);</span><br><span class="line">    obj.Say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>Key</code>是一个<code>object</code>类型，所以也可以是其他类型作为 Key。</p></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><ul><li>单例。每次请求都会返回相同的实例。<code>ServiceProvider</code>会引用该实例。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">        .AddSingleton&lt;IService, Service&gt;()</span><br><span class="line">        .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> service = serviceProvider.GetService&lt;IService&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;service.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 4094363</span></span><br><span class="line"></span><br><span class="line">    service = serviceProvider.GetService&lt;IService&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;service.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 4094363</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>两次输出相同的 HashCode。</li><li>支持从已有实例进行注册<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddSingleton(<span class="keyword">new</span> Service());</span><br></pre></td></tr></table></figure></li></ul><h3 id="Scoped"><a href="#Scoped" class="headerlink" title="Scoped"></a>Scoped</h3><ul><li>作用域。在同一个作用域内请求会返回相同的实例。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">        .AddScoped&lt;IService, Service&gt;()</span><br><span class="line">        .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> scope = serviceProvider.CreateScope())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> s1 = scope.ServiceProvider.GetService&lt;IService&gt;();</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s1.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 4094363</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> s2 = scope.ServiceProvider.GetService&lt;IService&gt;();</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s2.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 4094363</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> scope = serviceProvider.CreateScope())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> s1 = scope.ServiceProvider.GetService&lt;IService&gt;();</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s1.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 41962596</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> s2 = scope.ServiceProvider.GetService&lt;IService&gt;();</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s2.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 41962596</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果不在作用域内请求也是可以的，但是会产生单例的效果：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">        .AddScoped&lt;IService, Service&gt;()</span><br><span class="line">        .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s3 = serviceProvider.GetService&lt;IService&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s3.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 42119052</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s4 = serviceProvider.GetService&lt;IService&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s4.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 42119052</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在作用域外请求被认为是反模式，为了约束这种错误的用法，可以在<code>BuildServiceProvider</code>方法中传入<code>validateScopes = true</code>。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">        .AddScoped&lt;IService, Service&gt;()</span><br><span class="line">        .BuildServiceProvider(validateScopes: <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s3 = serviceProvider.GetService&lt;IService&gt;();  <span class="comment">// InvalidOperationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>错误的用法将会抛出一个<code>InvalidOperationException</code>异常。</li></ul><h3 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h3><ul><li>瞬态。每次请求都创建一个新的实例。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">        .AddTransient&lt;IServiceA, ServiceA&gt;()</span><br><span class="line">        .BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s1 = serviceProvider.GetService&lt;IServiceA&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s1.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 4094363</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s2 = serviceProvider.GetService&lt;IServiceA&gt;();</span><br><span class="line">    Debug.WriteLine(<span class="string">$&quot;<span class="subst">&#123;s2.GetHashCode()&#125;</span>&quot;</span>);  <span class="comment">// 19575591</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>每次请求都是新的实例。</li></ul><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p><code>Microsoft.Extensions.DependencyInjection</code>仅有构造函数注入。并不支持属性注入。</p><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li>容器会选择具有最多参数的构造函数来进行注入。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AddTransient&lt;IServiceA, ServiceA&gt;();</span><br><span class="line">AddTransient&lt;IServiceB, ServiceB&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceC</span> : <span class="title">IServiceC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceC</span>(<span class="params">IServiceA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceC</span>(<span class="params">IServiceA a, IServiceB b</span>)  <span class="comment">// 命中</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceC</span>(<span class="params"><span class="built_in">int</span> n1, <span class="built_in">int</span> n2, <span class="built_in">int</span> n3</span>)  <span class="comment">// 参数虽多，但是类型没有注册</span></span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Microsoft.Extensions.DependencyInjection</code>很轻量，它并不是一个大而全的 IoC 容器。对于复杂的依赖注入场景来说功能有限。为了满足更高级的需求，可以使用其他第三方容器。<br>它只是微软官方一系列扩展包中的一个公共模块，是为了服务其他扩展的。<br><br>以下是其他部分扩展：</p><ol><li><code>Microsoft.Extensions.Logging</code>：提供了日志记录功能的扩展，可以与各种日志记录器（如Console、Debug、File、EventSource等）集成。</li><li><code>Microsoft.Extensions.Configuration</code>：提供了配置管理功能的扩展，可以从不同的配置源（如JSON、XML、环境变量等）读取和解析配置信息。</li><li><code>Microsoft.Extensions.Caching</code>：提供了缓存功能的扩展，可以将数据缓存在内存、分布式缓存（如Redis）中，并提供灵活的缓存策略。</li><li><code>Microsoft.Extensions.Options</code>：提供了配置选项功能的扩展，可以轻松地将配置选项注入到应用程序中，并进行验证和转换。</li><li><code>Microsoft.Extensions.Diagnostics.HealthChecks</code>：提供了应用程序健康检查功能的扩展，可以检查应用程序的各种依赖和状态。</li></ol><p><br>官方的扩展远不止这几个，更多的可以直接去 nuget 网站搜索前缀<code>Microsoft.Extensions</code>即可。<a href="https://www.nuget.org/packages?q=Microsoft.Extensions">便民链接</a><br>这些包的设计目标是提供可插拔的模块，以便开发人员根据项目需求选择适当的功能和扩展。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codeproject.com/Articles/5339241/Exploring-the-Microsoft-Extensions-DependencyInjec">Exploring the Microsoft.Extensions.DependencyInjection Machinery</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DependencyInjection </tag>
            
            <tag> IoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ServiceLocator 模式</title>
      <link href="/2023/11/10/service-locator-pattern/"/>
      <url>/2023/11/10/service-locator-pattern/</url>
      
        <content type="html"><![CDATA[<p>当我第一次看到<code>ServiceLocator</code>这个名字的时候以为只是一个常见的类名而已，后来才知道这其实是一种设计模式。<br>ServiceLocator 充当了一个中介的角色，负责定位和提供服务的实例。它最终目的是为了解决依赖管理的问题。</p><h2 id="ServiceLocator-实现"><a href="#ServiceLocator-实现" class="headerlink" title="ServiceLocator 实现"></a>ServiceLocator 实现</h2><p>一个简单的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceA</span> : <span class="title">IService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service A is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceB</span> : <span class="title">IService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service B is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceLocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;<span class="built_in">string</span>, IService&gt; services = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, IService&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterService</span>(<span class="params"><span class="built_in">string</span> key, IService service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        services[key] = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">GetService</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (services.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> services[key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotFoundException(<span class="string">$&quot;Service with key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; is not registered.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        ServiceLocator.RegisterService(<span class="string">&quot;ServiceA&quot;</span>, <span class="keyword">new</span> ServiceA());</span><br><span class="line">        ServiceLocator.RegisterService(<span class="string">&quot;ServiceB&quot;</span>, <span class="keyword">new</span> ServiceB());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并使用服务</span></span><br><span class="line">        IService serviceA = ServiceLocator.GetService(<span class="string">&quot;ServiceA&quot;</span>);</span><br><span class="line">        serviceA.Execute();</span><br><span class="line"></span><br><span class="line">        IService serviceB = ServiceLocator.GetService(<span class="string">&quot;ServiceB&quot;</span>);</span><br><span class="line">        serviceB.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceLocator 就做了一件事：<strong>负责提供服务的实例</strong>。</p><h2 id="为什么需要-ServiceLocator？"><a href="#为什么需要-ServiceLocator？" class="headerlink" title="为什么需要 ServiceLocator？"></a>为什么需要 ServiceLocator？</h2><p>当我们还是小白，没有任何设计模式的概念时，代码应该是这样写的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service A is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceA = <span class="keyword">new</span> ServiceA();</span><br><span class="line">        serviceA.Execute();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service B is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceA = <span class="keyword">new</span> ServiceB();</span><br><span class="line">serviceA.Execute();</span><br></pre></td></tr></table></figure><p>显然，ServiceA 依赖于 ServiceB 的实现，这违反了<strong>依赖倒置原则</strong>。<br>于是我们引入了接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServiceA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceA</span> : <span class="title">IServiceA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service A is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">IServiceA serviceA</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        serviceA.Execute();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Service B is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceB = <span class="keyword">new</span> ServiceB();</span><br><span class="line">serviceB.Execute(<span class="keyword">new</span> ServiceA());  <span class="comment">// 注入依赖参数，术语称为 &quot;依赖注入&quot;</span></span><br></pre></td></tr></table></figure><p>现在符合了依赖倒置原则，即：<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<br>为什么需要服务定位器？当我们频繁使用依赖注入时，实际上在注入上下文中也产生了依赖：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bar</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceB = <span class="keyword">new</span> ServiceB();</span><br><span class="line">        serviceB.Execute(<span class="keyword">new</span> ServiceA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时虽然 ServiceB 不依赖 ServiceA，但是 Foo 却和 ServiceA、ServiceB 耦合了。<br>此时就需要 ServiceLocator 登场了。通过使用 ServiceLocator，应用程序的各个部分可以统一通过服务定位器获取它们所需的服务，而无需直接依赖于具体的实现类。这有助于减少类之间的直接依赖，提高灵活性和可维护性。<br>采用 ServiceLocator 后的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bar</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceB = ServiceLocator.GetService&lt;IServiceB&gt;();</span><br><span class="line">        serviceB.Execute(ServiceLocator.GetService&lt;IServiceA&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Common-Service-Locator"><a href="#Common-Service-Locator" class="headerlink" title="Common Service Locator"></a>Common Service Locator</h2><p><a href="https://www.nuget.org/packages/CommonServiceLocator">CommonServiceLocator</a> 是一个服务定位器的通用实现。相较于普通的服务定位器，<code>CommonServiceLocator</code>的区别在于它是全局唯一的服务定位器，通过设置全局的 ServiceLocator 提供者，可以在整个应用程序中使用同一个 ServiceLocator 来解析服务，而不需要每个地方都创建一个新的服务定位器实例。<br><br>以 <a href="https://www.nuget.org/packages/Unity.Container">Unity</a> 容器为例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> CommonServiceLocator;</span><br><span class="line"><span class="keyword">using</span> Unity;</span><br><span class="line"><span class="keyword">using</span> Unity.ServiceLocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer();</span><br><span class="line">container.RegisterType&lt;School&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locator = <span class="keyword">new</span> UnityServiceLocator(container);</span><br><span class="line">ServiceLocator.SetLocatorProvider(() =&gt; locator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = ServiceLocator.Current.GetInstance&lt;School&gt;();</span><br></pre></td></tr></table></figure><p>服务定位器会隐藏具体的容器，使得调用者依赖定位器而不是容器。<br>除了 Unity 外，一些主流的容器都有对应的 CommonServiceLocator 包装。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codeproject.com/Articles/5337102/Service-Locator-Pattern-in-Csharp">Service Locator Pattern in C#</a><br><a href="https://johnnyqian.net/blog/common-service-locator.html">Common Service Locator</a><br><a href="https://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">Service Locator is an Anti-Pattern</a><br><a href="https://stackoverflow.com/questions/4985455/dependency-injection-vs-service-location">Dependency Injection vs Service Location</a><br><a href="https://stackoverflow.com/questions/1557781/whats-the-difference-between-the-dependency-injection-and-service-locator-patte">What’s the difference between the Dependency Injection and Service Locator patterns?</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XPath 常用语法</title>
      <link href="/2023/11/08/xpath-syntax/"/>
      <url>/2023/11/08/xpath-syntax/</url>
      
        <content type="html"><![CDATA[<p>XPath 不会经常用，但是需要的时候又想不起来一些特性该怎么用，所以整理了一些比较常见的用法。<br>在 C# 中，主要用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.xmlnode.selectsinglenode">XmlNode.SelectSingleNode</a> 和 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.xmlnode.selectnodes">XmlNode.SelectNodes 方法</a> 方法查询，前者查询单个节点，后者查询多个节点。</p><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>先复习一下节点的类型。在XML中有5种主要的节点类型，它们是：</p><ol><li>元素节点（Element Node）：表示XML文档的元素，包括标签、属性和内容。</li><li>属性节点（Attribute Node）：用于描述元素节点的属性。</li><li>文本节点（Text Node）：包含元素节点内的文本内容。</li><li>注释节点（Comment Node）：用于添加注释或说明性文本到XML文件中。</li><li>CDATA节（CDATA Section）：用于在XML文档中包含需要保留原始格式的文本数据。</li></ol><p><br>此外，还有两种特殊类型的节点：<br>6. 处理指令节点（Processing Instruction Node）：用于向XML解析器提供额外的指令或信息，通常位于XML文档的开头。<br>7. 命名空间节点（Namespace Node）：用于定义和管理XML文档中的命名空间。</p><p>这些节点类型共同构成了XML文档的结构和内容。<br>在日常开发中，主要就是对前三种类型节点的查询与读写。</p><h2 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;.&quot;</span>);              <span class="comment">// 当前节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;..&quot;</span>);             <span class="comment">// 父节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;Item&quot;</span>);           <span class="comment">// 从当前节点中查找子节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;*&quot;</span>);              <span class="comment">// 任意节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;/Root&quot;</span>);          <span class="comment">// 文档的根节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item&quot;</span>);         <span class="comment">// 查找文档中所有的 &quot;Item&quot; 节点，无论节点有多深</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[Child]&quot;</span>);  <span class="comment">// 选择包含有子节点 &quot;Child&quot; 的节点</span></span><br></pre></td></tr></table></figure><h2 id="按属性过滤"><a href="#按属性过滤" class="headerlink" title="按属性过滤"></a>按属性过滤</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择属性节点 */</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item/@Name&quot;</span>);  <span class="comment">// 选择所有名为 &quot;Name&quot; 的属性节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item/@*&quot;</span>);     <span class="comment">// 选取所有属性节点</span></span><br><span class="line"></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[@Id]&quot;</span>);             <span class="comment">// 包含属性名为 &quot;Id&quot; 的节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[@Name=&#x27;jack&#x27;]&quot;</span>);    <span class="comment">// 要求属性等于指定的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有用引号的表示是数字，可以用逻辑表运算符</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[@Id &lt; 10]&quot;</span>);  <span class="comment">// 属性 Id 值小于 10 的节点</span></span><br><span class="line"></span><br><span class="line">SelectNodes(<span class="string">&quot;//*[@Id=3][@Age=18]&quot;</span>);     <span class="comment">// 逻辑与，要求同时满足条件</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//*[@Id=3 and @Age=18]&quot;</span>);  <span class="comment">// 逻辑与，要求同时满足条件</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//*[@Id=3 or @Age=18]&quot;</span>);   <span class="comment">// 逻辑或，满足条件之一即可</span></span><br></pre></td></tr></table></figure><h2 id="按位置过滤"><a href="#按位置过滤" class="headerlink" title="按位置过滤"></a>按位置过滤</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按索引返回，与数组一样，不过索引从1开始</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[1]&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符通常用于属性过滤时。</p><ul><li><code>=</code>：等于</li><li><code>!=</code>：不等于</li><li><code>&gt;</code>：大于</li><li><code>&gt;=</code>：大于等于</li><li><code>&lt;</code>：小于</li><li><code>&lt;=</code>：小于等于</li><li><code>and</code>：逻辑与</li><li><code>or</code>：逻辑或</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>返回当前节点下的子节点，无论是什么类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;/Root/node()&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>获取文本节点内容。<br>XML内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Node</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取得文本节点值有两种方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = doc.SelectSingleNode(<span class="string">&quot;/Root/Node&quot;</span>);</span><br><span class="line">Debug.WriteLine(node.InnerText);</span><br></pre></td></tr></table></figure><p>方式二就是使用<code>text()</code>函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = doc.SelectSingleNode(<span class="string">&quot;/Root/Node/text()&quot;</span>);</span><br><span class="line">Debug.WriteLine(node.Value);  <span class="comment">// jack</span></span><br></pre></td></tr></table></figure><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>返回节点位置，下标从1开始</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* position 表示结果列表中的索引 */</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[position() &lt;= 5]&quot;</span>);  <span class="comment">// 选取前面5个节点</span></span><br></pre></td></tr></table></figure><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>最后一个元素。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* last 选择列表中最后一个节点 */</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[last()]&quot;</span>);      <span class="comment">// 最后一个节点</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[last() - 1]&quot;</span>);  <span class="comment">// 倒数第2个节点</span></span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><p>属性值是否包含指定字符串。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* start-with、ends-with、contains */</span></span><br><span class="line">SelectNodes(<span class="string">&quot;//Item[contains(@name, &#x27;xxx&#x27;)]&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="starts-with"><a href="#starts-with" class="headerlink" title="starts-with"></a>starts-with</h3><p>属性值是否以指定字符串开始。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;//Item[starts-with(@name, &#x27;xxx&#x27;)]&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ends-with"><a href="#ends-with" class="headerlink" title="ends-with"></a>ends-with</h3><p>属性值是否以指定字符串结束。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;//Item[ends-with(@name, &#x27;xxx&#x27;)]&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>测试发现 C# 不支持此函数</strong>。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>返回当前节点的名称。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;//*[contains(name(), &#x27;Item&#x27;)]&quot;</span>);  <span class="comment">// 所有元素节点名中包含 &quot;Item&quot; 的节点</span></span><br></pre></td></tr></table></figure><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>字串查询。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectNodes(<span class="string">&quot;//*[substring(name(), 1, 4) = &#x27;Node&#x27;]&quot;</span>);  <span class="comment">// 从位置1取4个字符</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="索引筛选出多个结果"><a href="#索引筛选出多个结果" class="headerlink" title="索引筛选出多个结果"></a>索引筛选出多个结果</h3><p>假设 XML 内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Employees</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Employee</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Employee</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Employee</span> <span class="attr">Id</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employees</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果用<code>SelectNodes(&quot;//Item[1]&quot;)</code>会查询出几个结果呢？答案是两个。因为这句话的意思是<strong>查询任意位置，名为 Item 的第1个节点</strong>。<br>由于<code>&lt;Employee Id=&quot;2&quot; /&gt;</code>处于父节点中第一个符合条件的，所以也会被筛选出来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/xpath/index.asp">XPath 教程</a><br><a href="https://www.w3school.com.cn/xpath/xpath_functions.asp">XPath 函数</a><br><a href="https://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html">Xpath语法格式整理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScottPlot 查找离鼠标最近的点</title>
      <link href="/2023/11/05/scottplot-find-nearest-point/"/>
      <url>/2023/11/05/scottplot-find-nearest-point/</url>
      
        <content type="html"><![CDATA[<p>官方已经在 <a href="https://scottplot.net/faq/mouse-position/">Mouse Position - ScottPlot FAQ</a> 中给出了查找鼠标位置和最近点的方法。<br>官方示例是以单个散点图作为说明的。而现实中，一个图表肯定不止一条数据，我们不仅仅需要找出最近的X点，还要找出最近的Y点。<br><br>解决思路如下：</p><ol><li>遍历绘图对象，找出每个绘图对象当前鼠标所处的XY点。</li><li>再通过上面得到的X点，找出最近的X点。此时便得到了距离鼠标最近的X点。</li><li>用第一步得到的XY点，计算出鼠标所在的像素点位置。</li><li>获取鼠标像素点位置，从第3步的结果中找出离当前鼠标像素位置最近的点即可。</li></ol><p><br>一句话说就是找出距离鼠标最近的每个绘图对象的XY点并转换为像素坐标，再从中找出离鼠标最近的像素坐标即可。<br>伪代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> plottable <span class="keyword">in</span> formsPlot.Plot.GetPlottables())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到当前 X 点</span></span><br><span class="line">    <span class="keyword">var</span> (mouseCoordX, _) = formsPlot.GetMouseCoordinates(plottable.XAxisIndex, plottable.YAxisIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，并非所有绘制对象都有 GetPointNearest 方法。这里以信号图举例</span></span><br><span class="line">    <span class="keyword">if</span> (plottable <span class="keyword">is</span> SignalPlotConst&lt;<span class="built_in">double</span>&gt; signalPlot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 得到最近的 X 点</span></span><br><span class="line">        <span class="keyword">var</span> (nearestX, nearestY, index) = signalPlot.GetPointNearestX(mouseCoordX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到离鼠标最近的 XY 像素坐标</span></span><br><span class="line">        <span class="keyword">var</span> (xPixel, yPixel) = formsPlot.Plot.GetPixel(nearestX, nearestY, plottable.XAxisIndex, plottable.YAxisIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前鼠标像素位置</span></span><br><span class="line"><span class="keyword">var</span> (mousePixelX, mousePixelY) = formsPlot.GetMousePixel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 从上面的结果中找出离当前鼠标位置最近的点</span></span><br></pre></td></tr></table></figure><p>至于如何从一系列坐标中找出最近的点，可以用欧氏距离的公式，通过计算 X 坐标和 Y 坐标的差的平方和再开根号得到距离。<br>伪代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PointF <span class="title">FindNearestPoint</span>(<span class="params">List&lt;PointF&gt; list, <span class="built_in">float</span> mousePixelX, <span class="built_in">float</span> mousePixelY</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PointF nearestPoint = <span class="literal">default</span>;</span><br><span class="line">    <span class="keyword">var</span> minDistance = <span class="built_in">double</span>.MaxValue;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> point <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> distance = Math.Sqrt(Math.Pow(point.X - mousePixelX, <span class="number">2</span>) + Math.Pow(point.Y - mousePixelY, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (distance &gt; minDistance) <span class="keyword">continue</span>;</span><br><span class="line">        minDistance = distance;</span><br><span class="line">        nearestPoint = point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nearestPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="/images/scottplot-find-nearest-point_01.webp"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://scottplot.net/faq/mouse-position/">Mouse Position</a><br><a href="https://github.com/ScottPlot/ScottPlot/discussions/1590">How to find the plottable nearest the cursor</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ScottPlot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 AutoHotKey 显示隐藏软件窗口</title>
      <link href="/2023/11/03/ahk-showhide-window/"/>
      <url>/2023/11/03/ahk-showhide-window/</url>
      
        <content type="html"><![CDATA[<p>我有这样一个需求，使用频率很高的软件在未使用的时候暂时隐藏它，用的时候按下快捷键就能弹出来。<br>虽然有些软件自带热键显示隐藏的功能，但是大部分软件都是没有的。这时候就可以用 <a href="https://www.autohotkey.com/">AutoHotKey</a> 来解决。<br><br>通过查找窗口标题、窗口类名基本上能定位到唯一的窗口。但是现在很多客户端软件都喜欢用 <a href="https://www.electronjs.org/">Electron</a> 之类的框架开发。<br>这类框架都是基于 Web 技术，有个特点是软件会包含多个进程。<br>如果仅仅只通过标题和类名去查找窗口就会匹配到多个窗口，因为渲染进程也含有隐藏窗口，且标题和类名大概率都相同。<br><br>于是我多加了一个检查条件：窗口样式。隐藏窗口基本都是无边框没有菜单栏的。<br>这是一个针对 <a href="https://chatboxai.app/zh">Chatbox</a> 的例子：</p><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Win + C</span></span><br><span class="line"><span class="title">#c::</span></span><br><span class="line"><span class="built_in">WinGet,</span> hwnd, List, <span class="keyword">ahk_class</span> Chrome_WidgetWin_1</span><br><span class="line">found := <span class="literal">false</span></span><br><span class="line"><span class="built_in">Loop,</span> <span class="variable">%hwnd%</span></span><br><span class="line">&#123;</span><br><span class="line">    hwnd := hwnd<span class="variable">%A_Index%</span></span><br><span class="line"><span class="built_in">    WinGetTitle,</span> title, <span class="keyword">ahk_id</span> <span class="variable">%hwnd%</span></span><br><span class="line">    if (title = <span class="string">&quot;Chatbox&quot;</span>) <span class="comment">; 匹配窗口标题</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">        WinGet,</span> style, Style, <span class="keyword">ahk_id</span> <span class="variable">%hwnd%</span></span><br><span class="line">        if (style &amp; <span class="number">0</span>x6CF00000) <span class="comment">; 匹配除了 WS_VISIBLE 之外的样式</span></span><br><span class="line">        &#123;</span><br><span class="line">            found := <span class="literal">true</span></span><br><span class="line">            if (style &amp; <span class="number">0</span>x10000000) <span class="comment">; 检查 WS_VISIBLE 样式判断是否处于可见状态</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="built_in">                WinHide,</span> <span class="keyword">ahk_id</span> <span class="variable">%hwnd%</span></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line"><span class="built_in">                WinShow,</span> <span class="keyword">ahk_id</span> <span class="variable">%hwnd%</span></span><br><span class="line"><span class="built_in">                WinActivate,</span> <span class="keyword">ahk_id</span> <span class="variable">%hwnd%</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!found)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">    Run,</span> <span class="string">&quot;C:\Users\ADMIN\AppData\Local\Programs\xyz.chatboxapp.app\Chatbox.exe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>如果要用于其他软件，改下标题、类名、样式就能用了。<br>窗口样式可以参考官方手册：<a href="https://ahkcn.github.io/docs/misc/Styles.htm">https://ahkcn.github.io/docs/misc/Styles.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Switch 大气层系统介绍</title>
      <link href="/2023/10/21/switch-atmosphere/"/>
      <url>/2023/10/21/switch-atmosphere/</url>
      
        <content type="html"><![CDATA[<h2 id="hekate"><a href="#hekate" class="headerlink" title="hekate"></a>hekate</h2><p><a href="https://github.com/CTCaer/hekate">hekate </a> 是 Switch 开机后第一个运行的程序，类似于 PC 电脑上的 BIOS 程序，负责引导系统（比如大气层系统）。<br>还有一些实用工具等功能。</p><h2 id="Atmosphere-大气层系统"><a href="#Atmosphere-大气层系统" class="headerlink" title="Atmosphere 大气层系统"></a>Atmosphere 大气层系统</h2><p>GitHub：<a href="https://github.com/Atmosphere-NX/Atmosphere">https://github.com/Atmosphere-NX/Atmosphere</a><br>升级系统时，要确认 Atmosphere 的版本是否支持目标 Switch 版本，如果不支持的话则要先升级 Atmosphere，再升级 Switch 系统版本。</p><h3 id="系统插件"><a href="#系统插件" class="headerlink" title="系统插件"></a>系统插件</h3><p>插件是随系统启动的。类似于 Windows 系统上的服务程序，是不可见的，在后台工作。<br>系统插件安装目录：<code>\atmosphere\contents</code><br>插件的配置目录：<code>\config</code><br>插件配置文件夹要与插件名相同，比如特斯拉插件的配置路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\config\Tesla\</span><br></pre></td></tr></table></figure><h3 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h3><p>应用程序文件扩展名是<code>.nro</code>，等同于我们手机上的 APP，需要从系统相册中启动应用。<br>系统应用安装目录：<code>\atmosphere\switch</code></p><h2 id="特斯拉菜单"><a href="#特斯拉菜单" class="headerlink" title="特斯拉菜单"></a>特斯拉菜单</h2><p>特斯拉需要单独拿出来讲，因为它有自己的开发框架和应用（.ovl程序）。简单理解的话就是类似微信，它为我们提供了小程序（.ovl程序）。<br>特斯拉由两个部分组成：<a href="https://github.com/WerWolv/nx-ovlloader">nx-ovlloader</a> 和 <a href="https://github.com/WerWolv/Tesla-Menu">Tesla-Menu</a>。<br>工作原理：<code>nx-ovlloader</code>是系统插件，它会加载<code>\switch\.overlays\ovlmenu.ovl</code>，也就是特斯拉菜单。<br>特斯拉菜单自身也属于一个加载器（微信），它负责加载<code>.ovl</code>后缀的菜单程序（小程序）。<br>菜单程序安装位置：<code>switch\.overlays</code></p><h3 id="配置特斯拉菜单"><a href="#配置特斯拉菜单" class="headerlink" title="配置特斯拉菜单"></a>配置特斯拉菜单</h3><p>呼出快捷键修改位置：<code>\config\tesla\config.ini</code>。<strong>如果文件不存在则创建它，否则无法呼出菜单</strong>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tesla]</span></span><br><span class="line"><span class="attr">key_combo</span>=L+DDOWN</span><br></pre></td></tr></table></figure><p>上面的配置是指按<code>L + 左摇杆下</code>呼出菜单。<br>支持的按键：</p><ul><li>普通按键 &#x3D; A, B, X, Y, L, R, ZL, ZR</li><li>摇杆 &#x3D; LS, RS</li><li>加和减 &#x3D; PLUS, MINUS,</li><li>方向键 &#x3D; DUP, DDOWN, DLEFT, DRIGHT</li></ul><p><br>如果想修改菜单的顺序，可以插件名字前面加个数字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0_EdiZon</span><br><span class="line">1_emuiibo</span><br><span class="line">2_QuickNTP</span><br></pre></td></tr></table></figure><h2 id="虚拟amiibo"><a href="#虚拟amiibo" class="headerlink" title="虚拟amiibo"></a>虚拟amiibo</h2><p><a href="https://github.com/XorTroll/emuiibo">emuiibo</a> 是一个可以虚拟 amiibo 的插件，支持特斯拉。<br>主要讲讲如何生成 amiboo 数据：</p><ol><li>安装 <a href="https://github.com/XorTroll/emuiibo">emuiibo</a> 插件。</li><li>安装 <a href="https://github.com/Slluxx/AmiiboGenerator">AmiiboGenerator</a>。</li><li>进入相册启动<code>AmiiboGenerator</code>程序。</li><li>确保网络畅通，按下<code>-</code>键开始更新数据库。</li><li>可选图像下载。按下<code>B</code>，再按<code>ZR</code>启用图像下载。网络不好的最好设置代理服务器。</li><li>按下<code>ZL</code>键选中所有的数据，再按<code>X</code>键开始生成数据，生成完毕后打开 emuiibo 就可以模拟 amiibo 了。</li></ol><p><br>amiboo 数据库地址：<a href="https://www.amiiboapi.com/api/amiibo/">https://www.amiiboapi.com/api/amiibo/</a><br>懒得折腾的话就直接下载网友生成好的数据：<a href="https://www.bilibili.com/read/cv25544001/">https://www.bilibili.com/read/cv25544001/</a></p><h2 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h2><p><a href="https://github.com/tomvita/EdiZon-SE">EdiZon-SE</a> 是金手指插件。<br>作弊码可以通过 <a href="https://github.com/HamletDuFromage/aio-switch-updater">aio-switch-updater</a> 程序在线下载，不过都是英文的。<br>推荐还是按需下载，玩什么游戏就去网上找，解压到 <code>\atmosphere\contents\</code> 目录下。<br><br>特斯拉版本插件用这个：<a href="https://github.com/proferabg/EdiZon-Overlay">https://github.com/proferabg/EdiZon-Overlay</a></p><h2 id="常用插件和程序"><a href="#常用插件和程序" class="headerlink" title="常用插件和程序"></a>常用插件和程序</h2><table><thead><tr><th>应用名称</th><th align="center">.nro</th><th align="center">.ovl</th><th>说明</th></tr></thead><tbody><tr><td>daybreak</td><td align="center">✔️</td><td align="center">❌</td><td>系统固件升级程序。已经包含在大气层系统中</td></tr><tr><td><a href="https://github.com/rashevskyv/dbi">DBI</a></td><td align="center">✔️</td><td align="center">❌</td><td>系统必备！安装游戏、传输文件等功能</td></tr><tr><td><a href="https://github.com/BernardoGiordano/Checkpoint">Checkpoint</a></td><td align="center">✔️</td><td align="center">❌</td><td>存档管理工具。支持备份、还原等</td></tr><tr><td><a href="https://github.com/HamletDuFromage/aio-switch-updater">aio-switch-updater</a></td><td align="center">✔️</td><td align="center">❌</td><td>在线更新系统、金手指作弊码等功能</td></tr><tr><td><a href="https://github.com/tomvita/EdiZon-SE">EdiZon-SE</a></td><td align="center">✔️</td><td align="center">❌</td><td>金手指</td></tr><tr><td><a href="https://github.com/proferabg/EdiZon-Overlay">EdiZon-Overlay</a></td><td align="center">❌</td><td align="center">✔️</td><td>特斯拉版金手指</td></tr><tr><td><a href="https://github.com/XorTroll/emuiibo">emuiibo</a></td><td align="center">❌</td><td align="center">✔️</td><td>虚拟amiibo</td></tr><tr><td><a href="https://github.com/WerWolv/ovl-sysmodules">ovl-sysmodules</a></td><td align="center">❌</td><td align="center">✔️</td><td>系统模块管理</td></tr></tbody></table><h2 id="Switch-固件下载地址"><a href="#Switch-固件下载地址" class="headerlink" title="Switch 固件下载地址"></a>Switch 固件下载地址</h2><p><a href="https://darthsternie.net/switch-firmwares/">https://darthsternie.net/switch-firmwares/</a><br><a href="https://github.com/THZoria/NX_Firmware">https://github.com/THZoria/NX_Firmware</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gbatemp.net/threads/tesla-the-nintendo-switch-overlay-menu.557362/">Tesla - The Nintendo Switch Overlay Menu</a><br><a href="http://www.265xh.com/nszhinan/4455.html">大气层特斯拉菜单插件排序调整方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 调用非托管 DLL 参数传递总结</title>
      <link href="/2023/10/19/csharp-pinvoke/"/>
      <url>/2023/10/19/csharp-pinvoke/</url>
      
        <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>基本类型没有什么特别的地方，直接传递即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo1(char v1, short v2, int v3, float v4, double v5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo1</span>(<span class="params"><span class="built_in">char</span> v1, <span class="built_in">short</span> v2, <span class="built_in">int</span> v3, <span class="built_in">float</span> v4, <span class="built_in">double</span> v5</span>)</span>;</span><br></pre></td></tr></table></figure><p>对于指针或引用类型需要加入<code>ref</code>关键字：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo2(int* v1, int&amp; v2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo2</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> v1, <span class="keyword">ref</span> <span class="built_in">int</span> v2</span>)</span>;</span><br></pre></td></tr></table></figure><p>引用类型是 C++ 特有的，从规范上讲不建议在接口中使用引用类型，而应该用指针。</p><h3 id="数字类型对照表"><a href="#数字类型对照表" class="headerlink" title="数字类型对照表"></a>数字类型对照表</h3><p>下面是一些常见 C 数字类型及其在 C# 中的对应类型的对照表：</p><table><thead><tr><th>C 数据类型</th><th>C# 数据类型</th></tr></thead><tbody><tr><td>char</td><td>char</td></tr><tr><td>unsigned char</td><td>byte</td></tr><tr><td>signed char</td><td>sbyte</td></tr><tr><td>short</td><td>short</td></tr><tr><td>unsigned short</td><td>ushort</td></tr><tr><td>int</td><td>int</td></tr><tr><td>unsigned int</td><td>uint</td></tr><tr><td>long</td><td>long</td></tr><tr><td>unsigned long</td><td>ulong</td></tr><tr><td>long long</td><td>long (or) System.Int64</td></tr><tr><td>unsigned long long</td><td>ulong (or) System.UInt64</td></tr><tr><td>float</td><td>float</td></tr><tr><td>double</td><td>double</td></tr><tr><td>long double</td><td>decimal</td></tr><tr><td>size_t</td><td>UIntPtr</td></tr></tbody></table><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>在 DLL 接口中，一般能见到<code>bool</code>和<code>BOOL</code>两种类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Foo1</span><span class="params">()</span>; <span class="comment">// 不推荐</span></span><br><span class="line">BOOL <span class="title function_">Foo2</span><span class="params">()</span>; <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><p><code>bool</code>和<code>BOOL</code>是 C++ 和 Windows API 中使用的两种不同的布尔类型，它们之间存在一些区别。</p><ol><li><p><strong><code>bool</code>类型 (C++ 中)</strong>:</p><ul><li><code>bool</code>是 C++ 标准库中引入的布尔类型。</li><li><code>bool</code>类型的大小在标准规范中没有特别指定，但通常情况下，它占用一个字节（8位）。</li><li><code>bool</code>类型的值可以是 <code>true</code> 或 <code>false</code>。</li></ul></li><li><p><strong><code>BOOL</code>类型 (Windows API 中)</strong>:</p><ul><li><code>BOOL</code>是 Windows API 中广泛使用的布尔类型。</li><li><code>BOOL</code>类型在 Windows API 中通常被定义为一个 4 字节整数（32位），其中<code>FALSE</code>被定义为<code>0</code>，其他任何值被定义为<code>TRUE</code>。</li><li><code>BOOL</code>类型的使用是为了与 Windows 操作系统和其 API 的兼容性。</li></ul></li></ol><p><br>C# 中的<code>bool</code>类型可以很好地与 C++ 的<code>bool</code>类型兼容，因为它们都表示布尔值，即<code>true</code>或<code>false</code>。<br>如果要与使用<code>BOOL</code>的 C++ 代码进行交互，需要进行一些额外的处理。<br>例如，对于一个返回<code>BOOL</code>的 Windows API 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyFunction</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以在 C# 中这样声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;YourLibrary.dll&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">return: MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">MyFunction</span>()</span>;</span><br></pre></td></tr></table></figure><p>使用<code>MarshalAs</code>特性来确保<code>BOOL</code>被正确映射到<code>bool</code>。<br><br>其实不使用 <code>[return: MarshalAs(UnmanagedType.Bool)]</code> 特性也可能得到正确的结果，因为 .NET 框架通常会自动处理返回值的映射。然而，使用<code>MarshalAs</code>是一个良好的做法，因为它提供了更清晰的代码和更可靠的结果。<br><br>关于布尔类型的一些知识：<a href="https://stackoverflow.com/questions/28514373">What is the size of a boolean In C#? Does it really take 4-bytes?</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组本质上就是指针。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo5(int* arr1, int arr2[])</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo5</span>(<span class="params"><span class="built_in">int</span>[] arr1, <span class="built_in">int</span>[] arr2</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：函数内对数组的修改会影响原数组</strong>，因为数组是引用类型。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>默认是窄字符，使用本机编码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo3(const char* str)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo3</span>(<span class="params"><span class="built_in">string</span> v1</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果是宽字符，则需要通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.charset">CharSet</a> 参数指定为<code>Unicode</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo4(const wchar_t* str)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo4</span>(<span class="params"><span class="built_in">string</span> v1</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果同时出现窄字符和宽字符（不好的设计）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo7(const char* str1, const wchar_t* str2)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo7</span>(<span class="params">[MarshalAs(UnmanagedType.LPStr</span>)]<span class="built_in">string</span> v1, [<span class="title">MarshalAs</span>(<span class="params">UnmanagedType.LPWStr</span>)]<span class="built_in">string</span> v2)</span>;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshalasattribute">MarshalAsAttribute</a> 指示封送类型。而<code>CharSet</code>将不再生效。</p><h3 id="传出字符串"><a href="#传出字符串" class="headerlink" title="传出字符串"></a>传出字符串</h3><p>使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder">StringBuilder</a> 类型接受字符串。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo6(char* buf, const int bufLen)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo6</span>(<span class="params">StringBuilder str, <span class="built_in">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>);</span><br><span class="line">MyLib.Foo6(sb, sb.Capacity);</span><br></pre></td></tr></table></figure><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>某些情况下可能会直接返回一个<code>char*</code>作为字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* __stdcall <span class="title">Foo8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* myString = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* dynamicString = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(myString) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(dynamicString, myString);</span><br><span class="line">    <span class="keyword">return</span> dynamicString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时就不能用<code>string</code>接受了，而需要使用<code>IntPtr</code>作为返回类型，再用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringansi">Marshal.PtrToStringAnsi</a> 转为字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">Foo8</span>()</span>;</span><br><span class="line"></span><br><span class="line">IntPtr p = MyLib.Foo8();</span><br><span class="line"><span class="built_in">string</span> s = Marshal.PtrToStringAnsi(p);</span><br></pre></td></tr></table></figure><p>宽字符版：<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringuni">Marshal.PtrToStringUni</a><br>UTF-8版：<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringutf8">Marshal.PtrToStringUTF8</a><br>另外还要注意，当 DLL 在堆上分配了内存后，还应该提供释放内存的接口方法，否则会产生内存泄露。</p><h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h2><p>结构是值类型，所以和基础类型的用法一样：<br>下面是一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)  <span class="comment">// 内存按1字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdcall <span class="title function_">Foo9</span><span class="params">(MyStruct s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s.x = <span class="number">5</span>;</span><br><span class="line">    s.y = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，结构需要通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.structlayoutattribute">StructLayout</a> 指定内存布局。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential)</span>]  <span class="comment">// 顺序布局，也就是按1字节对齐</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo9</span>(<span class="params">MyStruct ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms = <span class="keyword">new</span> MyStruct();</span><br><span class="line">ms.x = <span class="number">1</span>;</span><br><span class="line">ms.y = <span class="number">2</span>;</span><br><span class="line">MyLib.Foo9(ms);</span><br><span class="line">MessageBox.Show(<span class="string">$&quot;<span class="subst">&#123;ms.x&#125;</span>, <span class="subst">&#123;ms.y&#125;</span>&quot;</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure><p>如果需要在函数内对结构进行修改，那么需要使用<code>ref</code>来定义参数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo9</span>(<span class="params"><span class="keyword">ref</span> MyStruct ms</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="返回结构"><a href="#返回结构" class="headerlink" title="返回结构"></a>返回结构</h3><p>与字符串不同，结构体可以直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStruct __stdcall <span class="title function_">Foo10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyStruct ms;</span><br><span class="line">    ms.x = <span class="number">5</span>;</span><br><span class="line">    ms.y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> MyStruct <span class="title">Foo10</span>()</span>;</span><br></pre></td></tr></table></figure><h3 id="返回结构指针"><a href="#返回结构指针" class="headerlink" title="返回结构指针"></a>返回结构指针</h3><p>可以用<code>ref</code>关键字定义结构体指针：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyStruct* __stdcall Foo11()</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">ref</span> MyStruct <span class="title">Foo11</span>()</span>;</span><br></pre></td></tr></table></figure><p>但是这样无法得到结构的指针，也就不能释放它了，导致内存泄露。<br>所以建议使用<code>IntPtr</code>作为返回类型，然后用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure">Marshal.PtrToStructure</a> 转换：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntPtr p = MyLib.Foo11();</span><br><span class="line"><span class="keyword">var</span> ms = Marshal.PtrToStructure&lt;MyStruct&gt;(p);</span><br><span class="line">MessageBox.Show(<span class="string">$&quot;<span class="subst">&#123;ms.x&#125;</span>, <span class="subst">&#123;ms.y&#125;</span>&quot;</span>);</span><br><span class="line">MyLib.Free(p);  <span class="comment">// DLL提供释放接口</span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>需要使用委托来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们要定义一个回调函数原型，它接受一个整数参数并返回一个整数。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CallbackFunction)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">SomeFunction</span><span class="params">(CallbackFunction callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callback</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C#中使用DLL中的回调函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委托的签名与回调函数相匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CallbackDelegate</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;YourDLL.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SomeFunction</span>(<span class="params">[MarshalAs(UnmanagedType.FunctionPtr</span>)] CallbackDelegate callback)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建委托实例，并将其传递给DLL中的函数</span></span><br><span class="line">CallbackDelegate myCallback = (<span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">   Console.WriteLine(<span class="string">$&quot;Callback called with value: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">value</span> * <span class="number">2</span>; <span class="comment">// 做一些处理并返回结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用DLL函数，并传递委托</span></span><br><span class="line"><span class="built_in">int</span> result = SomeFunction(myCallback);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Result from DLL: <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，C#中的委托将在DLL内部的函数中被调用，并且C#代码可以处理回调函数的结果。</p><h2 id="调用-Win32-API"><a href="#调用-Win32-API" class="headerlink" title="调用 Win32 API"></a>调用 Win32 API</h2><p>微软推出了 <a href="https://www.nuget.org/packages/Microsoft.Windows.CsWin32/">Microsoft.Windows.CsWin32</a> 包，使得调用 Win32 API 异常简单。<br>安装包后，在工程目录下新建一个<code>NativeMethods.txt</code>文件，在其中写入要用到的符号，包括函数、常量等名称即可，每行一个。<br>然后以<code>PInvoke.XXX</code>方式使用即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mono-project.com/docs/advanced/pinvoke/">https://www.mono-project.com/docs/advanced/pinvoke/</a><br><a href="https://manski.net/2012/05/pinvoke-tutorial-basics-part-1/">https://manski.net/2012/05/pinvoke-tutorial-basics-part-1/</a><br><a href="https://manski.net/2012/06/pinvoke-tutorial-passing-strings-part-2/">https://manski.net/2012/06/pinvoke-tutorial-passing-strings-part-2/</a><br><a href="https://manski.net/2012/06/pinvoke-tutorial-passing-parameters-part-3/">https://manski.net/2012/06/pinvoke-tutorial-passing-parameters-part-3/</a><br><a href="https://manski.net/2012/06/pinvoke-tutorial-pinning-part-4/">https://manski.net/2012/06/pinvoke-tutorial-pinning-part-4/</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.unmanagedtype">UnmanagedType 枚举</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity.Container 快速入门</title>
      <link href="/2023/10/15/unitycontainer/"/>
      <url>/2023/10/15/unitycontainer/</url>
      
        <content type="html"><![CDATA[<p>第三方 IoC 容器库不少，之所以选择这个是因为只有它支持 .NET Framework 4.0，这样可以让那些古老的程序也能焕发青春。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>包地址：<a href="https://www.nuget.org/packages/Unity.Container/">https://www.nuget.org/packages/Unity.Container/</a></p><h2 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h2><p>注册主要分为三种方式</p><h3 id="按类型注册"><a href="#按类型注册" class="headerlink" title="按类型注册"></a>按类型注册</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;Foo&gt;(); <span class="comment">// 可有可无的一行代码</span></span><br><span class="line"><span class="keyword">var</span> foo = Container.Resolve&lt;Foo&gt;();</span><br></pre></td></tr></table></figure><p>如果是非接口类型，可以不用注册。</p><h3 id="按接口注册"><a href="#按接口注册" class="headerlink" title="按接口注册"></a>按接口注册</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container.RegisterType&lt;IFoo, Foo&gt;();</span><br><span class="line"><span class="keyword">var</span> foo = container.Resolve&lt;IFoo&gt;();</span><br></pre></td></tr></table></figure><p>如果接口有多个实现，默认按最后一次注册的为准</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;IFoo, Foo&gt;();</span><br><span class="line">Container.RegisterType&lt;IFoo, Foo2&gt;();</span><br><span class="line"><span class="keyword">var</span> foo = Container.Resolve&lt;IFoo&gt;(); <span class="comment">// Foo2</span></span><br></pre></td></tr></table></figure><p>具名注册，解决同一接口有多个实现的问题</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;IFoo, Foo&gt;(<span class="string">&quot;xxx&quot;</span>); <span class="comment">// 给一个名称</span></span><br><span class="line">Container.RegisterType&lt;IFoo, Foo2&gt;();</span><br><span class="line"><span class="keyword">var</span> foo = Container.Resolve&lt;IFoo&gt;(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="按实例注册"><a href="#按实例注册" class="headerlink" title="按实例注册"></a>按实例注册</h3><p>和按类型注册差不多，只是传入的参数是实例。传入后容器会持有引用，以后检索会返回该实例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sampleClass = <span class="keyword">new</span> SampleClass();</span><br><span class="line"></span><br><span class="line">container.RegisterInstance(sampleClass);</span><br><span class="line"><span class="keyword">var</span> obj1 = (SampleClass)container.Resolve(<span class="keyword">typeof</span>(SampleClass));</span><br><span class="line">obj1.Increase();</span><br><span class="line">Debug.WriteLine(obj1.ReferenceCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = (SampleClass)container.Resolve(<span class="keyword">typeof</span>(SampleClass));</span><br><span class="line">obj2.Increase();</span><br><span class="line">Debug.WriteLine(obj2.ReferenceCount);</span><br></pre></td></tr></table></figure><p>这样每次获得的都是同一个实例，起到了单例的效果。<br>支持具名化，方便检索同类型的不同实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.RegisterInstance(<span class="string">&quot;name&quot;</span>, sampleClass);</span><br></pre></td></tr></table></figure><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><p>注册一个工厂函数，以便在解析时动态创建实例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer();</span><br><span class="line">container.RegisterType&lt;School&gt;();</span><br><span class="line">container.RegisterFactory&lt;People&gt;(c =&gt; <span class="keyword">new</span> People());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = container.Resolve&lt;School&gt;();</span><br><span class="line">x.Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">School</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Func&lt;People&gt; _factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">School</span>(<span class="params">Func&lt;People&gt; factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> people = _factory();</span><br><span class="line">        Console.WriteLine(people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="瞬态生存期"><a href="#瞬态生存期" class="headerlink" title="瞬态生存期"></a>瞬态生存期</h3><p>类型：<code>TypeLifetime.Transient</code><br>所谓瞬态就是每次解析时都创建一个新的实例。这也是默认的生命周期管理方式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;SampleClass&gt;();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Container.RegisterType&lt;SampleClass&gt;(TypeLifetime.Transient);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = Container.Resolve&lt;SampleClass&gt;(); <span class="comment">// 新实例</span></span><br><span class="line"><span class="keyword">var</span> obj2 = Container.Resolve&lt;SampleClass&gt;(); <span class="comment">// 新实例</span></span><br></pre></td></tr></table></figure><h3 id="解析生存期"><a href="#解析生存期" class="headerlink" title="解析生存期"></a>解析生存期</h3><p>类型：<code>TypeLifetime.PerResolve</code><br>这个稍微难理解点，表面上看和<code>Transient</code>是一样的，但是它发生在库内部隐式注入对象时。<br>直接看例子比较容易理解</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> A a &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params">A arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;B: <span class="subst">&#123;arg.GetHashCode()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C</span>(<span class="params">A arg1, B arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;A: <span class="subst">&#123;arg1.GetHashCode()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按瞬态类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;A&gt;(TypeLifetime.Transient);</span><br><span class="line"><span class="keyword">var</span> x = Container.Resolve&lt;C&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出B: 30631159</span></span><br><span class="line"><span class="comment">// 输出A: 7244975</span></span><br></pre></td></tr></table></figure><p>两次输出结果不同，意味着传递给 C 的对象 a 实例与传递给 B 对象的 a 实例不同。<br>如果改为<code>PerResolve</code>方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;A&gt;(TypeLifetime.PerResolve);</span><br><span class="line"><span class="keyword">var</span> x = Container.Resolve&lt;C&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出B: 65204782</span></span><br><span class="line"><span class="comment">// 输出A: 65204782</span></span><br></pre></td></tr></table></figure><p>顾名思义，就是每次调用<code>Resolve</code>时对于同一类型只会创建一个实例。</p><h3 id="容器树单例-全局唯一"><a href="#容器树单例-全局唯一" class="headerlink" title="容器树单例(全局唯一)"></a>容器树单例(全局唯一)</h3><p>类型：<code>TypeLifetime.Singleton</code><br>它确保对象在整个容器树内只被创建一次。<br>注册类型总是将注册放置在容器树的根，并使其对该容器的所有子容器全局可用。注册是否发生在子容器的根节点并不重要，注册目的地总是根节点。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IUnityContainer container1 = <span class="keyword">new</span> UnityContainer();</span><br><span class="line"><span class="keyword">var</span> container2 = container1.CreateChildContainer();</span><br><span class="line"></span><br><span class="line">container2.RegisterType&lt;IA, A&gt;(TypeLifetime.Singleton); <span class="comment">// 在子容器上注册的注册行为，实际上推到了根容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = container1.Resolve&lt;IA&gt;(); <span class="comment">// 根容器可以检索到实例</span></span><br><span class="line"><span class="keyword">var</span> obj2 = container2.Resolve&lt;IA&gt;();</span><br><span class="line">Console.WriteLine(obj1 == obj2); <span class="comment">// 输出 True</span></span><br></pre></td></tr></table></figure><h3 id="容器树单例-向下传递"><a href="#容器树单例-向下传递" class="headerlink" title="容器树单例(向下传递)"></a>容器树单例(向下传递)</h3><p>类型：<code>TypeLifetime.PerContainer</code>、<code>TypeLifetime.ContainerControlled</code><br>与<code>TypeLifetime.Singleton</code>类似，只不过不会推到根容器去注册，但是会向子容器传递。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IUnityContainer container1 = <span class="keyword">new</span> UnityContainer();</span><br><span class="line"><span class="keyword">var</span> container2 = container1.CreateChildContainer();</span><br><span class="line"></span><br><span class="line">container1.RegisterType&lt;IA, A&gt;(TypeLifetime.PerContainer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = container1.Resolve&lt;IA&gt;();</span><br><span class="line"><span class="keyword">var</span> obj2 = container2.Resolve&lt;IA&gt;();</span><br><span class="line">Console.WriteLine(obj1 == obj2);  <span class="comment">// 输出 True。因为子容器共享父容器的实例</span></span><br></pre></td></tr></table></figure><h3 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h3><p>类型：<code>TypeLifetime.Hierarchical</code>、<code>TypeLifetime.Scoped</code><br>容器级别的单例。父容器与子容器都可以有自己唯一的实例，互不打扰。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IUnityContainer container1 = <span class="keyword">new</span> UnityContainer();</span><br><span class="line"><span class="keyword">var</span> container2 = container1.CreateChildContainer();</span><br><span class="line"></span><br><span class="line">container1.RegisterType&lt;IA, A&gt;(TypeLifetime.Scoped);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = container1.Resolve&lt;IA&gt;();</span><br><span class="line"><span class="keyword">var</span> obj2 = container2.Resolve&lt;IA&gt;();</span><br><span class="line">Console.WriteLine(obj1 == obj2);  <span class="comment">// 输出 False。因为子容器有自己的实例</span></span><br></pre></td></tr></table></figure><h3 id="容器瞬态"><a href="#容器瞬态" class="headerlink" title="容器瞬态"></a>容器瞬态</h3><p>类型：<code>TypeLifetime.PerContainerTransient</code><br>容器会持有对象，直到容器销毁。且如果对象实现了 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.idisposable">IDisposable </a> 接口，则会在释放时调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer();</span><br><span class="line">container.RegisterType&lt;IFoo, Foo&gt;(TypeLifetime.PerContainerTransient); <span class="comment">// 容器级瞬态</span></span><br><span class="line"><span class="keyword">var</span> x = container1.Resolve&lt;IFoo&gt;(); <span class="comment">// 容器会持有 x，直到容器销毁</span></span><br><span class="line">container.Dispose(); <span class="comment">// 销毁容器，会触发 x.Dispose()</span></span><br></pre></td></tr></table></figure><h3 id="线程单例"><a href="#线程单例" class="headerlink" title="线程单例"></a>线程单例</h3><p>类型：<code>TypeLifetime.PerThread</code><br>每个线程都有自己的一个单例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;IFoo, Foo&gt;(TypeLifetime.PerThread);</span><br></pre></td></tr></table></figure><h3 id="外部生存期"><a href="#外部生存期" class="headerlink" title="外部生存期"></a>外部生存期</h3><p>类型：<code>TypeLifetime.External</code><br>容器将持有对象实例的弱引用，每次调用<code>Resolve</code>都会返回该实例。如果实例不再有效，则创建新实例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container.RegisterType&lt;IFoo, Foo&gt;(TypeLifetime.External);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> x1 = Container.Resolve&lt;IFoo&gt;(); <span class="comment">// 容器会持有 x 的弱引用</span></span><br><span class="line"><span class="keyword">var</span> x2 = Container.Resolve&lt;IFoo&gt;(); <span class="comment">// x 还在有效范围内，会返回上一次的实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash相同</span></span><br><span class="line">Debug.WriteLine(x1.GetHashCode());</span><br><span class="line">Debug.WriteLine(x2.GetHashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让GC回收x引用</span></span><br><span class="line">x1 = <span class="literal">null</span>;</span><br><span class="line">x2 = <span class="literal">null</span>;</span><br><span class="line">GC.Collect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x3 = Container.Resolve&lt;IFoo&gt;(); <span class="comment">// 由于容器持有的弱引用对象已经被GC回收，这里会产生新对象</span></span><br><span class="line">Debug.WriteLine(x3.GetHashCode());</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>通过一系列以<code>Injection</code>开头的类注入。用的最多的就三类：构造注入、属性注入、方法注入。</p><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ol><li><p>如果一个类有多个构造函数，容器会选择具有最多参数的构造函数来进行注入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a, IB b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a, IB b, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line">container.RegisterType&lt;IB, B&gt;();</span><br><span class="line"><span class="keyword">var</span> myObject = container.Resolve&lt;MyClass&gt;(); <span class="comment">// 输出&quot;2&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <a href="http://unitycontainer.org/api/Unity.InjectionConstructorAttribute.html">InjectionConstructor</a> 标记构造函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">InjectionConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a, IB b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line">container.RegisterType&lt;IB, B&gt;();</span><br><span class="line"><span class="keyword">var</span> myObject = container.Resolve&lt;MyClass&gt;(); <span class="comment">// 输出&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>根据默认规则，容器会匹配最多参数的构造函数。但可以用<code>[InjectionConstructor]</code>指定构造函数。</p></li><li><p>通过 <a href="http://unitycontainer.org/api/Unity.Injection.InjectionConstructor.html">InjectionConstructor</a> 配置构造参数信息，以便可以调用指定的构造函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionConstructor(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">container.Resolve&lt;MyClass&gt;(); <span class="comment">// 输出 &quot;jack&quot;</span></span><br></pre></td></tr></table></figure><p>容器虽然能匹配到带有<code>IA</code>参数的构造函数，但是仍会调用 InjectionConstructor 指定构造函数。</p></li><li><p>容器将优先使用注册类型时指定的构造函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">InjectionConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionConstructor(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">container.Resolve&lt;MyClass&gt;(); <span class="comment">// 输出 &quot;jack&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，同时使用了注解和注册时指定两种方式。后者优先级更高。</p></li><li><p>覆盖参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionConstructor(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">container.Resolve&lt;MyClass&gt;(<span class="keyword">new</span> ParameterOverride(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;annie&quot;</span>)); <span class="comment">// 参数名大小写敏感。不能写为 &quot;Name&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<strong>参数名是区分大小写的</strong>。<br>覆盖参数主要应用在需要向构造函数传递参数的时候。</p></li></ol><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><ol><li><p>使用 <a href="http://unitycontainer.org/api/Unity.DependencyAttribute.html">Dependency</a> 标记属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Dependency</span>]</span><br><span class="line"><span class="keyword">public</span> IFoo Foo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://unitycontainer.org/api/Unity.Injection.InjectionProperty.html">InjectionProperty</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionProperty(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;jack&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> obj = container.Resolve&lt;MyClass&gt;();</span><br><span class="line">Debug.WriteLine(obj.Name); <span class="comment">// 输出 &quot;jack&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>覆盖属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionProperty(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">container.Resolve&lt;MyClass&gt;(<span class="keyword">new</span> PropertyOverride(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;annie&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><ol><li><p>使用 <a href="http://unitycontainer.org/api/Unity.InjectionMethodAttribute.html">InjectionMethod</a> 标记方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IA a, IB b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">InjectionMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo1</span>(<span class="params">IA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;InjectionMethod 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">InjectionMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo2</span>(<span class="params">IB b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">&quot;InjectionMethod 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line">container.RegisterType&lt;IB, B&gt;();</span><br><span class="line">container.Resolve&lt;MyClass&gt;(); <span class="comment">// 依次输出 &quot;2&quot;、&quot;InjectionMethod 1&quot;、&quot;InjectionMethod 2&quot;</span></span><br></pre></td></tr></table></figure><p>方法会在构造函数结束时调用。</p></li><li><p><a href="http://unitycontainer.org/api/Unity.Injection.InjectionMethod.html">InjectionMethod</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo</span>(<span class="params">IB b</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionMethod(<span class="string">&quot;Foo&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h3 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h3><p>一般很少会用这种方式注入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Dependency</span>]</span><br><span class="line">    <span class="keyword">public</span> IA a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IB b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.RegisterType&lt;MyClass&gt;(<span class="keyword">new</span> InjectionField(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意字段访问权限要求是<code>public</code>。</p><h2 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h2><ul><li><p>不要互相注入</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">A</span>(<span class="params">IB b</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">B</span> : <span class="title">IB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">B</span>(<span class="params">IA a</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会陷入死循环，从而引发 <a href="https://learn.microsoft.com/zh-cn//dotnet/api/system.stackoverflowexception">System.StackOverflowException</a> 异常。</p></li><li><p>子容器可以使用父容器的接口，反之则不行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IUnityContainer container = <span class="keyword">new</span> UnityContainer();</span><br><span class="line">container.RegisterType&lt;IA, A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> childContainer = container.CreateChildContainer();</span><br><span class="line">childContainer.RegisterType&lt;IB, B&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = childContainer.Resolve&lt;IA&gt;(); <span class="comment">// 子容器知道父容器注册的接口</span></span><br><span class="line"><span class="keyword">var</span> b = container.Resolve&lt;IB&gt;();      <span class="comment">// 错误！父容器不知道子容器注册的接口</span></span><br></pre></td></tr></table></figure><p>单例是例外，因为单例被推到了父容器中注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childContainer.RegisterType&lt;IB, B&gt;(TypeLifetime.Singleton); <span class="comment">// 单例会在父容器中注册</span></span><br><span class="line">container.Resolve&lt;IB&gt;();</span><br></pre></td></tr></table></figure></li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://unitycontainer.org/tutorials/Composition/composition.html">http://unitycontainer.org/tutorials/Composition/composition.html</a><br><a href="https://www.tutorialsteacher.com/ioc/unity-container">https://www.tutorialsteacher.com/ioc/unity-container</a><br><a href="https://nblumhardt.com/2010/01/the-relationship-zoo/">The Relationship Zoo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DependencyInjection </tag>
            
            <tag> IoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Winforms 程序采用 MVP 的一点总结</title>
      <link href="/2023/10/14/winforms-mvp/"/>
      <url>/2023/10/14/winforms-mvp/</url>
      
        <content type="html"><![CDATA[<h2 id="MVP的两种实现方式"><a href="#MVP的两种实现方式" class="headerlink" title="MVP的两种实现方式"></a>MVP的两种实现方式</h2><p><code>MVP</code>有两种变体：<code>Passive View</code>和<code>Supervising Controller</code>。两者的主要区别就是<code>View</code>和<code>Model</code>是否直接交流。</p><h3 id="被动视图（Passive-View）"><a href="#被动视图（Passive-View）" class="headerlink" title="被动视图（Passive View）"></a>被动视图（Passive View）</h3><p><code>View</code>和<code>Model</code>不知道彼此。<code>Model</code>的变化要告知<code>Presenter</code>，再由<code>Presenter</code>来改变<code>View</code>。<br>优点是<code>View</code>和<code>Model</code>解耦了。缺点是<code>Presenter</code>会比较重，数据更新需要手动完成，这就意味着放弃了数据绑定功能。<br><img src="/images/Passive-View-with-Tags.webp"></p><h3 id="监督控制器（Supervising-Controller）"><a href="#监督控制器（Supervising-Controller）" class="headerlink" title="监督控制器（Supervising Controller）"></a>监督控制器（Supervising Controller）</h3><p><code>View</code>可以知道<code>Model</code>的存在。让<code>Model</code>通过事件等方式发出数据变化的通知，<code>View</code>订阅<code>Model</code>的变化。<br>这主要是利用了语言或框架的特性让<code>View</code>直接感知<code>Model</code>的变化，而不用经过<code>Presenter</code>，这样可以减少代码量，缺点是<code>View</code>对<code>Model</code>耦合了。<br><img src="/images/Supervising-Controller.webp"></p><h2 id="M、V、P之间的关系"><a href="#M、V、P之间的关系" class="headerlink" title="M、V、P之间的关系"></a>M、V、P之间的关系</h2><p>先看图<br><img src="/images/Pa0iB.png"><br>为 V 定义一个接口，接口中暴露的方法就是为 P 提供的。这么做的目的是为了让 P 不知道 V 的存在，从而让 P 仅依赖接口，这样更容易测试 P。<br>V 和 P 是 1：1 的关系。<br>P 和 M 是 1：N 的关系。</p><h2 id="让-View-独立"><a href="#让-View-独立" class="headerlink" title="让 View 独立"></a>让 View 独立</h2><p>先看一个典型的<code>View</code>和<code>Presenter</code>连接的地方</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Presenter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Presenter</span>(<span class="params">IView view</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _view = view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">View</span> : <span class="title">IView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">View</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _presenter = <span class="keyword">new</span> Presenter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户触发一个 UI 行为，比如点击鼠标时，如何让<code>Presenter</code>响应呢？基本上就两种方式：</p><ol><li>让<code>View</code>直接调用<code>Presenter</code>中的方法。但这会产生耦合。</li><li><code>View</code>利用事件等机制实现广播，让<code>Presenter</code>去订阅<code>View</code>产生的通知。这样<code>View</code>就是完全独立的。但需要在释放时取消订阅事件，这比直接调用<code>Presenter</code>的方法多了一些步骤。</li></ol><p>普遍共识是采用第二种方式，让<code>View</code>不知道<code>Presenter</code>的存在。但这只是理想情况，现实开发中还有很多复杂性，所以还是得看情况决定用哪种方式。<br><br>但是上面的例子<code>View</code>依然还是知道如何创建<code>Presenter</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">View</span> : <span class="title">IView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">View</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _presenter = <span class="keyword">new</span> Presenter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时你有三种选择：</p><ol><li>在类的外部将<code>View</code>和<code>Presenter</code>连接起来（订阅通知）。</li><li>创建一个<code>PresenterFactory</code>工厂类，构造过程交给它。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPresenter = PresenterFactory.Create&lt;MyPresenter&gt;();</span><br><span class="line">mPresenter.View = <span class="keyword">this</span>; <span class="comment">// 在 seter 中订阅通知</span></span><br></pre></td></tr></table></figure></li><li>使用 IoC 容器注入（推荐）。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHomeView</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">TView</span>&gt; &#123;</span><br><span class="line">    TView View &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeView</span> : <span class="title">Form</span>, <span class="title">IHomeView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IPresenter&lt;IHomeView&gt; presenter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeView</span>(<span class="params">IPresenter&lt;IHomeView&gt; presenter</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.presenter = presenter;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，<code>View</code>仅仅只是知道一个什么都没用的<code>IPresenter</code>接口，从来不会使用它，持有它只是为了保持<code>Presenter</code>的生命周期。<br>最后记住在<code>View</code>关闭时通知<code>Presenter</code>互相解除引用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://draveness.me/mvx/">浅谈 MVC、MVP 和 MVVM 架构模式</a><br><a href="https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference">MVP 和 MVC 是什么以及有什么区别？</a><br><a href="https://stackoverflow.com/questions/43532525">如何在 WinForms 中使用 MVP 的依赖注入？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinForms 中使用 ReactiveUI</title>
      <link href="/2023/09/28/reactiveui-winforms/"/>
      <url>/2023/09/28/reactiveui-winforms/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 NuGet 包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactiveUI.WinForms</span><br></pre></td></tr></table></figure><p>目前最新版是<code>19.4.1</code>。框架要求 .NET Framework 版本在<code>4.6.2</code> 及以上。</p><h2 id="视图模型-ViewModel"><a href="#视图模型-ViewModel" class="headerlink" title="视图模型(ViewModel)"></a>视图模型(ViewModel)</h2><p><code>ViewModel</code>应该从 <a href="https://www.reactiveui.net/api/reactiveui/reactiveobject/">ReactiveObject</a> 继承，它实现了 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.inotifypropertychanged">INotifyPropertyChanged</a>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FormViewModel</span> : <span class="title">ReactiveObject</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><p>定义可通知的属性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FormViewModel</span> : <span class="title">ReactiveObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _name;</span><br><span class="line">        <span class="keyword">set</span> =&gt; <span class="keyword">this</span>.RaiseAndSetIfChanged(<span class="keyword">ref</span> _name, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.reactiveui.net/api/reactiveui/ireactiveobjectextensions/abeac7d9">RaiseAndSetIfChanged</a> 方法会尝试修改字段，如果修改成功则会发出变化的通知。<br>当有很多属性时，会存在很多相似的<code>geter/seter</code>代码，很不美观。<br>此时可以考虑引入<code>ReactiveUI.Fody</code>包，然后用<code>[Reactive]</code>注解可以节省很多代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FormViewModel</span> : <span class="title">ReactiveObject</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Reactive</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h2><p><code>View</code>应该从 <a href="https://www.reactiveui.net/api/reactiveui/iviewfor_1/">IViewFor&lt;T&gt;</a> 继承，这是个泛型接口，<code>T</code>就是具体的<code>ViewModel</code>类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyApp.ViewModel;</span><br><span class="line"><span class="keyword">using</span> ReactiveUI;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span>, <span class="title">IViewFor</span>&lt;<span class="title">FormViewModel</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="keyword">this</span>.WhenActivated(OnWhenActivated);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnWhenActivated</span>(<span class="params">Action&lt;IDisposable&gt; d</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Assert(ViewModel != <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 初始化代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> IViewFor.ViewModel</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; ViewModel;</span><br><span class="line">            <span class="keyword">set</span> =&gt; ViewModel = <span class="keyword">value</span> <span class="keyword">as</span> FormViewModel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> FormViewModel ViewModel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WhenActivated-是什么"><a href="#WhenActivated-是什么" class="headerlink" title="WhenActivated 是什么"></a>WhenActivated 是什么</h3><p><a href="https://www.reactiveui.net/docs/handbook/when-activated/">WhenActivated</a> 方法用于在视图被激活时执行特定的代码。基本上就是执行初始化的地方。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span>, <span class="title">IViewFor</span>&lt;<span class="title">FormViewModel</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        <span class="keyword">this</span>.WhenActivated(OnWhenActivated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> IViewFor.ViewModel</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; ViewModel;</span><br><span class="line">        <span class="keyword">set</span> =&gt; ViewModel = <span class="keyword">value</span> <span class="keyword">as</span> FormViewModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FormViewModel ViewModel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleActivation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">@&quot;HandleActivation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleDeactivation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">@&quot;HandleDeactivation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnWhenActivated</span>(<span class="params">CompositeDisposable d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Assert(ViewModel != <span class="literal">null</span>);</span><br><span class="line">        HandleActivation();</span><br><span class="line">        Disposable.Create(HandleDeactivation).DisposeWith(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnWhenActivated</span>(<span class="params">CompositeDisposable d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Assert(ViewModel != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 ViewModel 上的属性到视图的单向绑定</span></span><br><span class="line">    <span class="keyword">this</span>.OneWayBind(ViewModel, vm =&gt; vm.Description, v =&gt; v.label1.Text).DisposeWith(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">    <span class="keyword">this</span>.Bind(ViewModel, vm =&gt; vm.Name, v =&gt; v.textBox1.Text).DisposeWith(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定命令</span></span><br><span class="line">    <span class="keyword">this</span>.BindCommand(ViewModel, vm =&gt; vm.OpenCommand, v =&gt; v.btnOpen).DisposeWith(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最基础也最常见的用法。更多用法可以查看官方文档：<a href="https://www.reactiveui.net/docs/handbook/data-binding/">https://www.reactiveui.net/docs/handbook/data-binding/</a></p><h2 id="WhenAny"><a href="#WhenAny" class="headerlink" title="WhenAny"></a>WhenAny</h2><p>ReactiveUI 提供了一系列以 “WhenAny” 开头的方法，用于创建观察属性之间的关系和绑定。这些方法允许你监视属性的变化，并在这些属性变化时执行特定的操作。以下是一些常用的 “WhenAny” 方法：</p><ol><li><code>WhenAny</code>：监视一个或多个属性的变化，并生成一个 <code>IObservable</code>，以便在这些属性中的任何一个发生变化时发出通知。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.WhenAnyValue(x =&gt; x.FirstName, x =&gt; x.LastName)</span><br><span class="line">    .Subscribe(names =&gt; &#123; <span class="comment">/* 当 FirstName 或 LastName 变化时执行操作 */</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><code>WhenAnyValue</code>：与 <code>WhenAny</code> 类似，但专门用于监视属性值的变化。它会发出属性的当前值，并在属性值变化时发出新值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.WhenAnyValue(x =&gt; x.Age)</span><br><span class="line">    .Subscribe(age =&gt; &#123; <span class="comment">/* 当 Age 属性值变化时执行操作 */</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><code>WhenAnyObservable</code>：监视一个或多个 <code>IObservable</code>，并在其中任何一个发出通知时执行操作。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.WhenAnyObservable(x =&gt; x.LoadDataCommand.IsExecuting)</span><br><span class="line">    .Subscribe(isExecuting =&gt; &#123; <span class="comment">/* 当 LoadDataCommand 的执行状态变化时执行操作 */</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><code>WhenAnyDynamic</code>：与 <code>WhenAny</code> 类似，但是允许动态选择属性，通常用于在字符串或 Lambda 表达式中引用属性。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.WhenAnyDynamic(x =&gt; x.GetPropertyByName(DynamicPropertyName))</span><br><span class="line">    .Subscribe(<span class="keyword">value</span> =&gt; &#123; <span class="comment">/* 当指定属性变化时执行操作 */</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>这些方法使你能够轻松地创建响应式的属性监视和绑定，以便在属性变化时执行相关操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.reactiveui.net/docs/handbook/view-models/">https://www.reactiveui.net/docs/handbook/view-models/</a><br><a href="https://www.reactiveui.net/docs/handbook/when-any/">https://www.reactiveui.net/docs/handbook/when-any/</a><br><a href="https://www.reactiveui.net/docs/handbook/commands/">https://www.reactiveui.net/docs/handbook/commands/</a><br><a href="https://www.cnblogs.com/aijiao/p/17328272.html">https://www.cnblogs.com/aijiao/p/17328272.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ReactiveUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 类的序列化</title>
      <link href="/2023/09/26/csharp-serialize/"/>
      <url>/2023/09/26/csharp-serialize/</url>
      
        <content type="html"><![CDATA[<h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>被序列化的类要求用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.serializableattribute">Serializable</a> 属性标注。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Weight = <span class="number">0</span>;</span><br><span class="line">    [<span class="meta">NonSerialized</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _secret;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name, <span class="built_in">int</span> secret</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Age = age;</span><br><span class="line">        _name = name;</span><br><span class="line">        _secret = secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name =&gt; _name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Name: <span class="subst">&#123;Name&#125;</span>, Age:<span class="subst">&#123;Age&#125;</span>, Weight:<span class="subst">&#123;Weight&#125;</span>, Secret:<span class="subst">&#123;_secret&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObject(<span class="number">10</span>, <span class="string">&quot;jack&quot;</span>, <span class="number">80</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Weight = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">Stream stream = <span class="keyword">new</span> FileStream(<span class="string">&quot;MyObj.bin&quot;</span>, FileMode.Create, FileAccess.Write, FileShare.None);</span><br><span class="line">formatter.Serialize(stream, obj);</span><br><span class="line">stream.Close();</span><br></pre></td></tr></table></figure><p>反序列化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">Stream stream = <span class="keyword">new</span> FileStream(<span class="string">&quot;MyObj.bin&quot;</span>, FileMode.Open, FileAccess.Read, FileShare.Read);</span><br><span class="line"><span class="keyword">var</span> obj = (MyObject)formatter.Deserialize(stream);</span><br><span class="line">stream.Close();</span><br><span class="line"></span><br><span class="line">Debug.WriteLine(obj.ToString());</span><br></pre></td></tr></table></figure><p>输入内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: , Age:10, Weight:100, Secret:80</span><br></pre></td></tr></table></figure><p>由此可知：</p><ol><li>需要被序列化的类要用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.serializableattribute">Serializable</a> 属性标注。</li><li>默认会序列化所有字段，除非用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.nonserializedattribute">NonSerialized</a> 属性忽略。</li></ol><h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>如果需要更精细的控制序列化、反序列化过程，则需要实现 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.serialization.iserializable">ISerializable</a> 接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 ISerializable 接口的 GetObjectData 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将对象的字段添加到 SerializationInfo 对象中</span></span><br><span class="line">    info.AddValue(<span class="string">&quot;Name&quot;</span>, Name);</span><br><span class="line">    info.AddValue(<span class="string">&quot;Age&quot;</span>, Age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Person</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 SerializationInfo 对象中检索字段的值</span></span><br><span class="line">    Name = info.GetString(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    Age = info.GetInt32(<span class="string">&quot;Age&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>序列化时会调用 GetObjectData 方法。</li><li>反序列化时会调用构造函数，构造函数可以是私有的。<br><br><strong>以下是一些需要实现 ISerializable 接口的情况：</strong></li><li>自定义序列化格式：如果想要将对象序列化为特定的格式，而不是默认的二进制格式，可以实现 ISerializable 接口来自行定义序列化和反序列化的过程。</li><li>对象包含非序列化成员：如果类包含某些成员，它们不应该被序列化，可以通过实现 ISerializable 来排除这些成员。</li><li>对象包含敏感信息：如果对象包含敏感信息，如密码或私钥，你可能希望在序列化过程中对其进行加密或以其他方式进行安全处理。</li><li>对象包含复杂的引用关系：某些对象包含复杂的引用关系，可能导致默认的序列化过程出现循环引用或无法正确序列化的问题。通过实现 ISerializable 接口，你可以控制序列化过程，以处理这些引用关系。</li><li>特殊构造逻辑：如果你的类有特殊的构造逻辑，需要在反序列化过程中执行，可以通过 ISerializable 接口的构造函数来实现这些逻辑。</li></ul><h3 id="反序列化完成通知"><a href="#反序列化完成通知" class="headerlink" title="反序列化完成通知"></a>反序列化完成通知</h3><p>某些情况下，我们需要在反序列化完成后完成一些逻辑，那么就可以实现 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.serialization.ideserializationcallback">IDeserializationCallback</a> 接口，以便获得通知。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IDeserializationCallback</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> OriginalValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ComputedValue &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OriginalValue = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 IDeserializationCallback 接口的回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeserialization</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在反序列化完成后，重新计算 ComputedValue</span></span><br><span class="line">        ComputedValue = OriginalValue * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinForms 数据绑定类型转换的两种方式</title>
      <link href="/2023/07/26/binding-formattingenabled/"/>
      <url>/2023/07/26/binding-formattingenabled/</url>
      
        <content type="html"><![CDATA[<p>在数据绑定中，有种常见的需求就是将枚举类型绑定到下拉框列表，比如这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> MyOptions</span><br><span class="line">&#123;</span><br><span class="line">    Option1,</span><br><span class="line">    Option2,</span><br><span class="line">    Option3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">comboBox1.DataBindings.Add(<span class="keyword">nameof</span>(comboBox1.SelectedIndex), <span class="keyword">this</span>, <span class="keyword">nameof</span>(Option));</span><br></pre></td></tr></table></figure><p>众所周知 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.combobox.selectedindex">ComboBox.SelectedIndex</a> 属性是一个 int 类型，当绑定的控件读取属性时会将 MyOptions 强转为 int 类型，所以从数据源到控件是没有问题的。<br>但是当控件值变化时却无法写回数据源，会得到一个运行时错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引发的异常:“System.InvalidCastException”(位于 mscorlib.dll 中)</span><br></pre></td></tr></table></figure><p>这个异常在内部消化了，并不会引起应用崩溃，但是这会导致绑定只有单向的效果。</p><h2 id="用-Binding-Parse-事件转换"><a href="#用-Binding-Parse-事件转换" class="headerlink" title="用 Binding.Parse 事件转换"></a>用 Binding.Parse 事件转换</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.binding.parse">Binding.Parse</a> 事件在绑定控件的值更改时发生。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ParseEnum</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">object</span> sender, ConvertEventArgs e</span>) <span class="keyword">where</span> T: Enum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.DesiredType != <span class="keyword">typeof</span>(T)) <span class="keyword">return</span>;</span><br><span class="line">    e.Value = (T)e.Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bind = <span class="keyword">new</span> Binding(<span class="keyword">nameof</span>(comboBox1.SelectedIndex), <span class="keyword">this</span>, <span class="keyword">nameof</span>(Option), <span class="literal">false</span>, DataSourceUpdateMode.OnPropertyChanged);</span><br><span class="line">bind.Parse += ParseEnum&lt;MyOptions&gt;;</span><br><span class="line">comboBox1.DataBindings.Add(bind);</span><br></pre></td></tr></table></figure><p>它可以工作，但是不够完美。因为在绑定 Parse 事件时需要提供具体的目标类型，没有通用性。</p><h2 id="用-TypeConverter-转换"><a href="#用-TypeConverter-转换" class="headerlink" title="用 TypeConverter 转换"></a>用 TypeConverter 转换</h2><p>在 WPF 中，数据绑定有 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.data.ivalueconverter">IValueConverter</a> 接口可以实现转换功能。而在 .NET Framework 中有个类似的类 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter">TypeConverter</a>。<br>使用很简单，主要有4个方法：</p><ol><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter.canconvertto">CanConvertTo</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter.convertto">ConvertTo</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter.canconvertfrom">CanConvertFrom</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter.convertfrom">ConvertFrom</a></li></ol><p>前两个方法当从数据源到控件时会被调用，而后两个从控件到数据源时会被调用，所以我们只需要重写后两个即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">EnumValueConverter</span> : <span class="title">EnumConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumValueConverter</span>(<span class="params">Type type</span>) : <span class="title">base</span>(<span class="params">type</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvertFrom</span>(<span class="params">ITypeDescriptorContext context, Type sourceType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sourceType 就是绑定的控件属性的类型，这里是 int</span></span><br><span class="line">        <span class="keyword">return</span> sourceType == <span class="keyword">typeof</span>(<span class="built_in">int</span>) || <span class="keyword">base</span>.CanConvertFrom(context, sourceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ConvertFrom</span>(<span class="params">ITypeDescriptorContext context, CultureInfo culture, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Enum.Parse(EnumType, <span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要在枚举类型上用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverterattribute">TypeConverterAttribute</a> 标注。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TypeConverter(typeof(EnumValueConverter))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> MyOptions</span><br><span class="line">&#123;</span><br><span class="line">    Option1,</span><br><span class="line">    Option2,</span><br><span class="line">    Option3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要在绑定时将第4个参数<code>formattingEnabled</code>属性设置为<code>true</code>，表示启用数据格式化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bind = <span class="keyword">new</span> Binding(<span class="keyword">nameof</span>(comboBox1.SelectedIndex), <span class="keyword">this</span>, <span class="keyword">nameof</span>(Option), <span class="literal">true</span>, DataSourceUpdateMode.OnPropertyChanged);</span><br><span class="line">comboBox1.DataBindings.Add(bind);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/2044067/">How to convert enum to a bool for DataBinding in Winforms?</a><br><a href="https://stackoverflow.com/questions/3430217/">Winforms data binding: Can a TypeConverter be used instead of the Format&#x2F;Parse events?</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 中两种配置文件机制</title>
      <link href="/2023/07/20/csharp-settings/"/>
      <url>/2023/07/20/csharp-settings/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在C#中，有两种配置文件的机制，分别是用户配置文件和应用程序配置文件，它们分别对应产生<code>user.config</code>和<code>app.config</code>文件。<br>这两种机制的主要区别在于：</p><ul><li>存储位置：应用程序配置文件位于应用程序的根目录下，而用户配置文件位于用户的应用程序数据文件夹下。因此，用户配置文件是与具体用户相关的，而应用程序配置文件是与应用程序相关的。</li><li>读写权限：应用程序配置文件是只读的，而用户配置文件是可写的。因此，在应用程序配置文件中存储的配置信息是全局的，只能在应用程序部署时进行修改，而在用户配置文件中存储的配置信息是与具体用户相关的，可以在运行时根据用户的偏好进行修改。</li><li>使用方式：应用程序配置文件主要用于存储应用程序的全局配置信息，而用户配置文件主要用于存储用户的偏好设置。在代码中，可以使用ConfigurationManager类来读取应用程序配置文件中的配置信息，而使用Settings类来读取和写入用户配置文件中的配置信息。</li></ul><h2 id="user-config"><a href="#user-config" class="headerlink" title="user.config"></a>user.config</h2><p>用户配置文件（user.config）是用于存储应用程序的用户配置信息，例如窗口尺寸、字体样式、颜色方案等等。用户配置文件通常位于用户的应用程序数据文件夹下，并且是可写的。在Visual Studio中，可以使用“项目属性”窗口来定义这些用户配置信息，系统会自动生成一个Settings.settings文件，并在运行时自动创建和维护相应的user.config文件。在代码中，可以使用Settings类来读取和写入用户配置文件中的配置信息。<br><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.applicationsettingsbase">ApplicationSettingsBase</a> 类可以用于管理应用程序的设置，通过使用 ApplicationSettingsBase 类，我们可以轻松地读取和写入应用程序级别的设置，而无需编写大量的代码来实现这些功能。<br>要使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.applicationsettingsbase">ApplicationSettingsBase</a>，通常需要创建一个自定义设置类，该类继承自 ApplicationSettingsBase。在自定义设置类中，可以定义代表应用程序可配置设置的属性。通过使用<code> [DefaultSettingValue]</code>或<code>[UserScopedSetting]</code>等属性，可以为每个设置项指定默认值和作用域。<br>先看一个简单的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">AppSettings</span> : <span class="title">ApplicationSettingsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">bool</span> IsActive</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; (<span class="built_in">bool</span>)<span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)];</span><br><span class="line">        <span class="keyword">set</span> =&gt; <span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发生异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The settings property &#x27;IsActive&#x27; was not found.</span><br></pre></td></tr></table></figure><p>因为使用它需要几个基本条件：</p><ol><li>属性访问权限必须是<code>public</code>。</li><li>必须提供范围注解：<code>[UserScopedSetting]</code>或者<code>[ApplicationScopedSetting]</code>。</li><li>必须提供默认值。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">AppSettings</span> : <span class="title">ApplicationSettingsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UserScopedSetting()</span>]</span><br><span class="line">    [<span class="meta">DefaultSettingValue(<span class="string">&quot;true&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsActive</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; (<span class="built_in">bool</span>)<span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)];</span><br><span class="line">        <span class="keyword">set</span> =&gt; <span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="用户级设置"><a href="#用户级设置" class="headerlink" title="用户级设置"></a>用户级设置</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.userscopedsettingattribute">UserScopedSetting</a> 注解表示这个属性是<strong>用户级的设置</strong>。<br>所谓用户级的设置，是指属性存储在当前进程用户的相关位置，该设置不会与其他用户共享设置。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">AppSettings</span> : <span class="title">ApplicationSettingsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UserScopedSetting()</span>]</span><br><span class="line">    [<span class="meta">DefaultSettingValue(<span class="string">&quot;true&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsActive</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; (<span class="built_in">bool</span>)<span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)];</span><br><span class="line">        <span class="keyword">set</span> =&gt; <span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> settings = <span class="keyword">new</span> AppSettings();</span><br><span class="line"><span class="keyword">var</span> isActive = settings.IsActive;</span><br><span class="line">settings.Save();</span><br></pre></td></tr></table></figure><p>调用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.applicationsettingsbase.save">Save</a> 方法后会持久化设置（仅会保存用户设置）。<br>配置文件在哪个位置呢？可以使用这段代码查看</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetDefaultExeConfigPath</span>(<span class="params">ConfigurationUserLevel userLevel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> userConfig = System.Configuration.ConfigurationManager.OpenExeConfiguration(userLevel);</span><br><span class="line">    <span class="keyword">return</span> userConfig.FilePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = GetDefaultExeConfigPath(ConfigurationUserLevel.PerUserRoamingAndLocal);</span><br></pre></td></tr></table></figure><p>得到的路径大概是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Admin\AppData\Local\MyCompany\MyApp_Url_lab5ev2xnbcazbd33m1aiehm2mtop5ce\1.0.0.0\user.config</span><br></pre></td></tr></table></figure><h3 id="存储到-Roaming-目录"><a href="#存储到-Roaming-目录" class="headerlink" title="存储到 Roaming 目录"></a>存储到 Roaming 目录</h3><p>默认情况下属性将存储在当前用户目录下，如果要存储到<code>Roaming</code>目录，需要使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.settingsmanageabilityattribute">SettingsManageability</a> 标注。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">AppSettings</span> : <span class="title">ApplicationSettingsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UserScopedSetting()</span>]</span><br><span class="line">    [<span class="meta">SettingsManageability(SettingsManageability.Roaming)</span>]</span><br><span class="line">    [<span class="meta">DefaultSettingValue(<span class="string">&quot;true&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsActive</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; (<span class="built_in">bool</span>)<span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)];</span><br><span class="line">        <span class="keyword">set</span> =&gt; <span class="keyword">this</span>[<span class="keyword">nameof</span>(IsActive)] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置文件路径将会在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Admin\AppData\Roaming\...</span><br></pre></td></tr></table></figure><h3 id="应用级设置"><a href="#应用级设置" class="headerlink" title="应用级设置"></a>应用级设置</h3><p>与用户级设置对应的是应用级的设置，用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.applicationscopedsettingattribute">ApplicationScopedSetting</a> 注解类标注。<br>应用级的设置是不可以持久化的，默认值就是属性注解中的值。</p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p><code>user.config</code>文件的完整路径如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Profile Directory&gt;\&lt;Company Name&gt;\&lt;App Name&gt;_&lt;Evidence Type&gt;_&lt;Evidence Hash&gt;\&lt;Version&gt;\user.config</span><br></pre></td></tr></table></figure><p>其中，不同部分的含义如下：</p><ul><li><code>&lt;Profile Directory&gt;</code>：用户的应用程序数据目录，对应环境变量<code>%LOCALAPPDATA%</code>，如<code>C:\Users\&lt;UserName&gt;\AppData\Local</code>。</li><li><code>&lt;Company Name&gt;</code>：公司名称，通常是应用程序开发者的公司名或组织名。</li><li><code>&lt;App Name&gt;</code>：应用程序名称，指示具体的应用程序。</li><li><code>&lt;Evidence Type&gt;</code>和<code>&lt;Evidence Hash&gt;</code>：这些是关于应用程序证据（Evidence）的信息，用于标识不同应用程序的实例。证据信息可以包括应用程序的启动路径、域名等。这有助于区分不同实例的应用程序，以防止设置的冲突。</li><li><code>&lt;Version&gt;</code>：应用程序的版本号，用于标识当前设置的版本。</li></ul><h3 id="升级文件"><a href="#升级文件" class="headerlink" title="升级文件"></a>升级文件</h3><p>微软考虑的非常细致，在<code>user.config</code>路径中还有程序版本，这样当有多个版本的程序共存时，不会互相干扰。<br>但为了新版本的程序在首次运行时能够获取到旧的设置，需要先将设置文件升级</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;</span><br><span class="line"><span class="keyword">if</span> (!File.Exists(configPath))</span><br><span class="line">&#123;</span><br><span class="line">    Settings.Default.Upgrade();</span><br><span class="line">    Settings.Default.Reload();</span><br><span class="line">    Settings.Default.Save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置提供程序"><a href="#设置提供程序" class="headerlink" title="设置提供程序"></a>设置提供程序</h3><p>ApplicationSettingsBase 自身不保留也不加载设置，而是由设置提供程序（派生自 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.settingsprovider">SettingsProvider</a> 的类）完成。<br>如果 ApplicationSettingsBase 的派生类未通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.settingsproviderattribute">SettingsProviderAttribute</a> 指定设置提供程序，则默认使用提供程序 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.localfilesettingsprovider">LocalFileSettingsProvider</a>。<br>一个最小的自定义提供程序的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Specialized;</span><br><span class="line"><span class="keyword">using</span> System.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">CustomSettingsProvider</span> : <span class="title">SettingsProvider</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> SettingsPropertyValueCollection <span class="title">GetPropertyValues</span>(<span class="params">SettingsContext context, SettingsPropertyCollection collection</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">string</span> name, NameValueCollection config</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(name))</span><br><span class="line">            &#123;</span><br><span class="line">                name = <span class="keyword">nameof</span>(CustomSettingsProvider);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">base</span>.Initialize(name, config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetPropertyValues</span>(<span class="params">SettingsContext context, SettingsPropertyValueCollection collection</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> ApplicationName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;myapp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.settingsproviderattribute">SettingsProviderAttribute</a> 注解标注</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SettingsProvider(typeof(CustomSettingsProvider))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppSettings</span> : <span class="title">ApplicationSettingsBase</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非是自己需要完全控制配置文件的格式或文件路径，所以一般不需要自己实现。<br>自己实现提供程序需要考虑安全、版本等问题，比较繁琐。默认的<code>LocalFileSettingsProvider</code>已经足够应付绝大多数场景。</p><h3 id="官方的实现-Settings"><a href="#官方的实现-Settings" class="headerlink" title="官方的实现 Settings"></a>官方的实现 Settings</h3><p>微软在 Visual Studio 中提供了对<code>ApplicationSettingsBase</code>的包装，并支持可视化操作，它就是<code>Settings.settings</code>文件。<br>创建文件：可以在 Visual Studio 中右击项目，选择 “Add”（添加） -&gt; “New Item”（新建项），然后选择 “Settings File”（设置文件）。<br>VS会工程目录下生成3个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Settings.cs</span><br><span class="line">Properties\Settings.settings</span><br><span class="line">Properties\Settings.Designer.cs</span><br></pre></td></tr></table></figure><ul><li>双击<code>Settings.settings</code>文件可以进行设置的可视化编辑。</li><li><code>Settings.Designer.cs</code>文件是由编辑<code>Settings.settings</code>自动生成的，我们不应该修改它。</li><li><code>Settings.cs</code>文件下有一个名为<code>Settings</code>的类，这里的代码是可以编辑的。</li></ul><p>这个类继承自<code>ApplicationSettingsBase</code>，实行了单例模式，在程序直接使用即可。所以在实际开发中，我们按照微软的实践来即可，通常情况下不需要自己去实现<code>ApplicationSettingsBase</code>。</p><h3 id="实现自定义的类型"><a href="#实现自定义的类型" class="headerlink" title="实现自定义的类型"></a>实现自定义的类型</h3><p>在VS中编辑设置的类型，只有一些如string等等的内置类型，如果要实现自己的类型如何做呢？这就需要用到 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.typeconverter">TypeConverter</a>。<br>在 VS2022 中，<code>类型</code>的下拉框并没有自定义选项，所以需要手动编辑<code>Settings.settings</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SettingsFile</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/VisualStudio/2004/01/settings&quot;</span> <span class="attr">CurrentProfile</span>=<span class="string">&quot;(Default)&quot;</span> <span class="attr">GeneratedClassNamespace</span>=<span class="string">&quot;MyApp.Properties&quot;</span> <span class="attr">GeneratedClassName</span>=<span class="string">&quot;Settings&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Profiles</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Setting</span> <span class="attr">Name</span>=<span class="string">&quot;UserOption1&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;MyApp.MyOption&quot;</span> <span class="attr">Scope</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Value</span> <span class="attr">Profile</span>=<span class="string">&quot;(Default)&quot;</span>&gt;</span>user1<span class="tag">&lt;/<span class="name">Value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SettingsFile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>Type</code>属性修改为自定义类型的完全限定名。并且实现自己的<code>TypeConverter</code>。一个简单的例子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TypeConverter(typeof(CustomSettingConverter))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyOption</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomSettingConverter</span> : <span class="title">TypeConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvertFrom</span>(<span class="params">ITypeDescriptorContext context, Type sourceType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceType == <span class="keyword">typeof</span>(<span class="built_in">string</span>) || <span class="keyword">base</span>.CanConvertFrom(context, sourceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ConvertFrom</span>(<span class="params">ITypeDescriptorContext context, System.Globalization.CultureInfo culture, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stringValue = <span class="keyword">value</span> <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">if</span> (stringValue != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyOption() &#123; Age = <span class="number">50</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.ConvertFrom(context, culture, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, <span class="built_in">object</span>? <span class="keyword">value</span>, Type destinationType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (destinationType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> opt = <span class="keyword">value</span> <span class="keyword">as</span> MyOption;</span><br><span class="line">            <span class="keyword">return</span> opt?.Age.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.ConvertTo(context, culture, <span class="keyword">value</span>, destinationType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，就是处理字符串与自定义类型之间的转换过程。</p><h2 id="app-config"><a href="#app-config" class="headerlink" title="app.config"></a>app.config</h2><p>应用程序配置文件（app.config）是一个XML文件，用于存储应用程序的全局配置信息，例如数据库连接字符串、日志级别、应用程序设置等等。应用程序配置文件通常位于应用程序的根目录下，并且是只读的。在代码中，可以使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager">ConfigurationManager</a> 类来读取应用程序配置文件中的配置信息。<br><br>按照以下步骤来创建app.config文件：</p><ol><li>右键单击项目名称，选择“添加”-&gt;“新建项”菜单项。</li><li>在“添加新项”对话框中，选择“应用程序配置文件”模板，并指定文件名为“app.config”。</li></ol><p>文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在其中添加配置信息。在app.config文件中添加配置信息，例如数据库连接字符串、日志级别、应用程序设置等等，并在代码中使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager">ConfigurationManager</a> 类来读取app.config文件中的配置信息。</p><h3 id="AppSettings和ConnectionStrings属性"><a href="#AppSettings和ConnectionStrings属性" class="headerlink" title="AppSettings和ConnectionStrings属性"></a>AppSettings和ConnectionStrings属性</h3><p>微软在 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager">ConfigurationManager</a> 上安排了两个属性：</p><ol><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager.appsettings">AppSettings</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager.connectionstrings">ConnectionStrings</a></li></ol><p>分别对应文件中<code>AppSettingsSection</code>和<code>ConnectionStringsSection</code>两个配置节，用于存储应用程序的常规设置和数据库连接字符串信息。<br>AppSettingsSection 配置节用于存储应用程序的常规设置，例如日志级别、应用程序设置等等，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appSettings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;LogLevel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;MaxRetryCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appSettings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ConnectionStringsSection 配置节用于存储应用程序的数据库连接字符串信息，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;MyDB&quot;</span> <span class="attr">connectionString</span>=<span class="string">&quot;server=myserver;database=mydb;uid=myuser;password=mypassword&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在代码中，可以使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationmanager">ConfigurationManager</a> 类来读取 app.config 文件中的配置信息。例如，以下代码演示了如何读取名为”LogLevel”的应用程序设置和名为”MyDB”的数据库连接字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> logLevel = ConfigurationManager.AppSettings[<span class="string">&quot;LogLevel&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> connectionString = ConfigurationManager.ConnectionStrings[<span class="string">&quot;MyDB&quot;</span>].ConnectionString;</span><br></pre></td></tr></table></figure><h3 id="自定义Section"><a href="#自定义Section" class="headerlink" title="自定义Section"></a>自定义Section</h3><p>使用自定义配置节之前，我们需要在<code>app.config</code>中注册该配置节（在<code>&lt;configSections&gt;</code>下定义），以便应用程序能够识别并正确地读取该配置节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configSections</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">&quot;MySettings&quot;</span> <span class="attr">type</span>=<span class="string">&quot;System.Configuration.NameValueSectionHandler&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configSections</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MySettings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;MySetting1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;MySetting2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Value2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">MySettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：自定义配置节的名称。</li><li>type：自定义配置节的类型，C#提供了<code>System.Configuration.SingleTagSectionHandler</code>、<code>System.Configuration.DictionarySectionHandler</code>、<code>System.Configuration.NameValueSectionHandler</code>等等常用的节类型。</li></ul><p>使用很简单</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> section = (NameValueCollection)System.Configuration.ConfigurationManager.GetSection(<span class="string">&quot;MySettings&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> v1 = section[<span class="string">&quot;MySetting1&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> v2 = section[<span class="string">&quot;MySetting2&quot;</span>];</span><br></pre></td></tr></table></figure><p>键值对类型的选项可以用官方提供的 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.namevaluesectionhandler">NameValueSectionHandler</a>。<br>但如果需要更复杂的类型，可以实现自己的节类，它应该继承自 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.configuration.configurationsection">ConfigurationSection</a>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCustomSection</span> : <span class="title">ConfigurationSection</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ConfigurationProperty(<span class="string">&quot;MySetting1&quot;</span>, IsRequired = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> MySetting1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">string</span>)<span class="keyword">this</span>[<span class="string">&quot;MySetting1&quot;</span>]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>[<span class="string">&quot;MySetting1&quot;</span>] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ConfigurationProperty(<span class="string">&quot;MySetting2&quot;</span>, IsRequired = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MySetting2</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">int</span>)<span class="keyword">this</span>[<span class="string">&quot;MySetting2&quot;</span>]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>[<span class="string">&quot;MySetting2&quot;</span>] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 app.config 文件中添加一个名为”MyCustomSection”的自定义配置节：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configSections</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">&quot;MyCustomSection&quot;</span> <span class="attr">type</span>=<span class="string">&quot;MyNamespace.MyCustomSection, MyAssembly&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configSections</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyCustomSection</span> <span class="attr">MySetting1</span>=<span class="string">&quot;Value1&quot;</span> <span class="attr">MySetting2</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意<code>type</code>中的格式，前面是自定义节类型的完全名称，然后用逗号分隔，逗号后是程序集的名称。<br>这样就能得到一个自定义的类实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySection = ConfigurationManager.GetSection(<span class="string">&quot;MyCustomSection&quot;</span>) <span class="keyword">as</span> MyCustomSection;</span><br></pre></td></tr></table></figure><p>如果设置节还有子类型的话也是可以做到的，更高级的用法可以自行查阅相关资料，本文就不展开了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当项目中有 app.config 文件时，对 .settings 的编辑会自动同步到 app.config 文件中。同步过去的应用范围设置会在<code>applicationSettings</code>节点。而通过<code>ConfigurationManager.AppSettings[&#39;key&#39;]</code>这种方式访问的是<code>&lt;appSettings&gt;</code>节点，且总是字符串类型。所以我有理由相信，在今天，已经不推荐用这种方式了。<br><br>在VS中，对 .settings 支持更多，可以可视化编辑、自动生成相关代码，是强类型的。<br>所以在实际开发中，建议通过 .settings 来管理设置。如果需要给用户编辑应用范围设置的机会，如数据库连接字符串，那么就新建一个 app.config 文件，这样 .settings 中的应用级设置会同步过来，并且复制到程序目录，使得用户编辑成为可能。否则，就可以不需要 app.config 文件。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/1075204">When using a Settings.settings file in .NET, where is the config actually stored?</a><br><a href="https://stackoverflow.com/questions/23924183">Keep user’s settings after altering assembly&#x2F;file version</a><br><a href="https://learn.microsoft.com/zh-cn/previous-versions/aa730869(v=vs.80)">Using Settings in C#</a><br><a href="https://www.jianshu.com/p/b2022ec4d6c7">使用微软提供的Settings以及自定义SettingsProvider</a><br><a href="https://learn.microsoft.com/zh-cn/previous-versions/ms379611(v=vs.80)">在VisualBasic2005中使用My.Settings</a><br><a href="https://learn.microsoft.com/zh-cn/visualstudio/ide/reference/settings-page-project-designer">“设置”页面，项目设计器</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/desktop/winforms/advanced/application-settings-architecture">应用程序设置体系结构</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/desktop/winforms/advanced/application-settings-attributes">应用程序设置特性</a><br><a href="https://www.cnblogs.com/yukaizhao/archive/2011/12/02/net-web-config-costom-config-implement.html">在Web.config或App.config中的添加自定义配置</a><br><a href="http://www.blackwasp.co.uk/CustomAppSettings.aspx">Using Custom Classes with Application Settings</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 nuget 包输出位置</title>
      <link href="/2023/07/18/dotnet-probing/"/>
      <url>/2023/07/18/dotnet-probing/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，工程所引用的包在编译时会复制到输出目录。<br>这样会导致可执行文件和所有的 DLL 文件都处在同一个文件夹下，这样的目录没有层次结构，当文件过多时就难以定位程序或配置文件。<br>而我希望将所有第三方包放在子目录下，根目录只保留项目所产生的文件。</p><h2 id="NET-Framework工程的修改方法"><a href="#NET-Framework工程的修改方法" class="headerlink" title=".NET Framework工程的修改方法"></a>.NET Framework工程的修改方法</h2><p>通过用 <a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/procmon">进程监视器</a> 对可执行文件的观察，得知程序会依次从以下位置加载 DLL 文件：</p><ol><li>全局程序集缓存目录（Global Assembly Cache），共有6个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.Net\assembly\GAC_64\</span><br><span class="line">C:\Windows\Microsoft.Net\assembly\GAC_MSIL\</span><br><span class="line">C:\Windows\Microsoft.Net\assembly\GAC\</span><br><span class="line">C:\Windows\assembly\GAC_64\</span><br><span class="line">C:\Windows\assembly\GAC_MSIL\</span><br><span class="line">C:\Windows\assembly\GAC\</span><br></pre></td></tr></table></figure>从 .NET Framework 4开始，全局程序集缓存的默认位置为<code>%windir%\Microsoft.NET\assembly</code>。在早期版本的.NET Framework中，默认位置为<code>%windir%\assembly</code>。<br>不过我们并不需要关心这个东西，想要进一步了解可以查看官方文档 <a href="https://learn.microsoft.com/zh-cn/dotnet/framework/app-domains/gac">全局程序集缓存</a>。</li><li>程序工作目录，一般就是 exe 文件所在目录。</li><li><code>&#123;Package&#125;\&#123;Package&#125;.dll</code>。比如<code>HtmlAgilityPack\HtmlAgilityPack.dll</code>。</li><li><code>[appname].exe.config</code>中所配置的探测路径。比如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">runtime</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">probing</span> <span class="attr">privatePath</span>=<span class="string">&quot;libs&quot;</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>比如<code>HtmlAgilityPack.dll</code>，那么加载路径就是<code>libs\HtmlAgilityPack.dll</code>。<br>这个选项支持配置多个探测路径，详细用法查看官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/probing-element">probing 元素</a>。</li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.appdomain.assemblyresolve">AppDomain.AssemblyResolve 事件</a>。如果以上路径都未找到 DLL，那么会触发此事件<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> assemblyPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span class="string">&quot;libs&quot;</span>, <span class="keyword">new</span> AssemblyName(args.Name).Name + <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> File.Exists(assemblyPath) ? Assembly.LoadFrom(assemblyPath) : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，只有第4、5两种方法是我们需要的，一个通过配置文件，一个写死在代码中。用哪种方案根据自身喜好决定即可。</li></ol><h3 id="改变包的输出位置"><a href="#改变包的输出位置" class="headerlink" title="改变包的输出位置"></a>改变包的输出位置</h3><p>在这里找到了一个答案：<a href="https://stackoverflow.com/questions/55946010/">How to specify output folder for the referenced nuget packages?</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReferenceCopyLocalPaths</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DestinationSubDirectory</span>&gt;</span>libs\<span class="tag">&lt;/<span class="name">DestinationSubDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ReferenceCopyLocalPaths</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，所有引用的包都会复制到 libs 文件夹下，根目录清爽了。但是如果解决方案中有 DLL 工程的话，其也会复制到这个目录下去。<br>下面是改进后的版本，仅将第三方包复制到子目录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;AddDestinationSubDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;ResolveAssemblyReferences&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReferenceCopyLocalPaths</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;%(ReferenceCopyLocalPaths.ReferenceSourceTarget)&#x27; != &#x27;ProjectReference&#x27;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DestinationSubDirectory</span>&gt;</span>libs\<span class="tag">&lt;/<span class="name">DestinationSubDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ReferenceCopyLocalPaths</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法简化，效果一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;AddDestinationSubDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;ResolveAssemblyReferences&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReferenceCopyLocalPaths</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;%(ReferenceCopyLocalPaths.ReferenceSourceTarget)&#x27; != &#x27;ProjectReference&#x27;&quot;</span> <span class="attr">Update</span>=<span class="string">&quot;%(ReferenceCopyLocalPaths)&quot;</span> <span class="attr">DestinationSubDirectory</span>=<span class="string">&quot;libs\&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单说下这个任务，我们需要用 <a href="https://msbuildlog.com/">MSBuild Structured Log Viewer</a> 这个软件来分析 MSBuild 的构建过程。<br>其中 <a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/resolveassemblyreference-task">ResolveAssemblyReferences</a> 任务正是用来确定引用程序集的，文件列表就存在<code>ReferenceCopyLocalPaths</code>中。<br>所以我们的任务需要在其后执行，验证并向<code>ReferenceCopyLocalPaths</code>追加<code>DestinationSubDirectory</code>元数据即可。</p><h2 id="NET工程的修改方法"><a href="#NET工程的修改方法" class="headerlink" title=".NET工程的修改方法"></a>.NET工程的修改方法</h2><p>对于新的 .NET 工程，虽然也可以通过<code>DestinationSubDirectory</code>属性指定 nuget 包的输出位置，但是却无法再加载这些包了，因为加载路径变了。</p><h3 id="修改DLL探测位置"><a href="#修改DLL探测位置" class="headerlink" title="修改DLL探测位置"></a>修改DLL探测位置</h3><p>在编译 .NET 项目时，将在输出目录中生成一个<code>[appname].runtimeconfig.json</code>文件，这个文件中有一个<code>additionalProbingPaths</code>属性，它允许你指定一个或多个自定义探测路径，供运行时在查找程序集时使用。<br><br>但是<code>[appname].runtimeconfig.json</code>文件在工程编译时会被覆盖掉，所以我们要将配置写在一个名为<code>runtimeconfig.template.json</code>文件中，让它与工程文件在同一个目录下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;additionalProbingPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;libs&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>当然这个配置模板的文件名也可以修改，在工程文件中用<code>UserRuntimeConfig</code>指定一个新的名称。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UserRuntimeConfig</span>&gt;</span>config.template.json<span class="tag">&lt;/<span class="name">UserRuntimeConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终的<code>[appname].runtimeconfig.json</code>文件内容大概就是这个样子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;runtimeOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tfm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;framework&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Microsoft.NETCore.App&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7.0.0&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;additionalProbingPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;libs&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与传统的 NetFx 项目一样，程序首先会尝试在当前目录下加载 DLL，找不到文件时才会从<code>additionalProbingPaths</code>指定的路径中搜索。<br>不过在新的 .NET 中，并不是将 DLL 复制到子目录就完事了，因为<code>additionalProbingPaths</code>指定的只是 nuget 包的 packages 位置，子目录结构要保持和包的结构一致。<br><br>我们都知道，一个包可能含有多个不同版本的 DLL 文件，那么程序到底用的哪个 DLL 呢？可以查看<code>[appname].deps.json</code>文件。一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;runtimeTarget&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.NETCoreApp,Version=v7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilationOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.NETCoreApp,Version=v7.0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;ConsoleApp1/1.0.0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;HtmlAgilityPack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.11.51&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;ConsoleApp1.dll&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;HtmlAgilityPack/1.11.51&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;lib/netstandard2.0/HtmlAgilityPack.dll&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;assemblyVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.11.51.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fileVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.11.51.0&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;libraries&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConsoleApp1/1.0.0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;project&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;serviceable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sha512&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HtmlAgilityPack/1.11.51&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;package&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;serviceable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sha512&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha512-yRn0Vd6Smu69xGyRWIZVl/Ley2OMMCMwC9tZRR/GdXfxGYj1sGMT4KskWd8OP9dGlqaXPkyB0NzBHKejtZdbow==&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlagilitypack/1.11.51&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;hashPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlagilitypack.1.11.51.nupkg.sha512&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>探测路径就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;additionalProbingPaths&#125;\&#123;libraries.package.path&#125;\&#123;targets.package.runtime&#125;</span><br></pre></td></tr></table></figure><p>就上面的例子而言，最终加载路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libs/htmlagilitypack/1.11.51/lib/netstandard2.0/HtmlAgilityPack.dll</span><br></pre></td></tr></table></figure><h3 id="改变包的输出位置-1"><a href="#改变包的输出位置-1" class="headerlink" title="改变包的输出位置"></a>改变包的输出位置</h3><p>加载路径清楚了，那么如何让项目在编译时将 DLL 复制到子目录呢？有位网友给出了 <a href="https://stackoverflow.com/a/72044506">答案</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CreateLibs&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;AfterBuild&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NugetFiles</span> <span class="attr">Include</span>=<span class="string">&quot;@(ReferenceCopyLocalPaths-&gt;HasMetadata(&#x27;PathInPackage&#x27;))&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">OutPath</span>&gt;</span>$(OutDir)libs\%(ReferenceCopyLocalPaths.NuGetPackageId)\%(ReferenceCopyLocalPaths.NuGetPackageVersion)\%(ReferenceCopyLocalPaths.PathInPackage)<span class="tag">&lt;/<span class="name">OutPath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DeletePath</span>&gt;</span>$(OutDir)%(ReferenceCopyLocalPaths.DestinationSubPath)<span class="tag">&lt;/<span class="name">DeletePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NugetFiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Copy</span> <span class="attr">SourceFiles</span>=<span class="string">&quot;@(NugetFiles)&quot;</span> <span class="attr">DestinationFiles</span>=<span class="string">&quot;@(NugetFiles-&gt;&#x27;%(OutPath)&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">Files</span>=<span class="string">&quot;@(NugetFiles-&gt;&#x27;%(DeletePath)&#x27;)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过这个任务触发时机较晚，DLL 已经复制完成了，为了提高效率，我将它改进如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;AddDestinationSubDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;ResolveAssemblyReferences&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReferenceCopyLocalPaths</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;%(ReferenceCopyLocalPaths.ReferenceSourceTarget)&#x27; != &#x27;ProjectReference&#x27;&quot;</span> <span class="attr">Update</span>=<span class="string">&quot;%(ReferenceCopyLocalPaths)&quot;</span> <span class="attr">DestinationSubDirectory</span>=<span class="string">&quot;$([System.IO.Path]::GetDirectoryName(libs\%(ReferenceCopyLocalPaths.NuGetPackageId)\%(ReferenceCopyLocalPaths.NuGetPackageVersion)\%(ReferenceCopyLocalPaths.PathInPackage)))\&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WinUI工程的修改方法"><a href="#WinUI工程的修改方法" class="headerlink" title="WinUI工程的修改方法"></a>WinUI工程的修改方法</h2><p>在 WinUI 工程下，用以上的方法修改后程序依然运行不起来。监控后发现<code>Microsoft.Windows.SDK.NET.dll</code>和<code>WinRT.Runtime.dll</code>这两个文件不受<code>additionalProbingPaths</code>设置的影响，它们只从可执行文件的工作目录下加载。<br>解决方法也很简单，加个 Condition 验证，过滤掉这两个文件就行了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;AddDestinationSubDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;ResolveAssemblyReferences&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReferenceCopyLocalPaths</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;%(ReferenceCopyLocalPaths.ReferenceSourceTarget)&#x27; != &#x27;ProjectReference&#x27; And &#x27;%(FileName)%(Extension)&#x27; != &#x27;Microsoft.Windows.SDK.NET.dll&#x27; And &#x27;%(FileName)%(Extension)&#x27; != &#x27;WinRT.Runtime.dll&#x27;&quot;</span> <span class="attr">Update</span>=<span class="string">&quot;%(ReferenceCopyLocalPaths)&quot;</span> <span class="attr">DestinationSubDirectory</span>=<span class="string">&quot;$([System.IO.Path]::GetDirectoryName(libs\%(ReferenceCopyLocalPaths.NuGetPackageId)\%(ReferenceCopyLocalPaths.NuGetPackageVersion)\%(ReferenceCopyLocalPaths.PathInPackage)))\&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/56844233/">Additional probing paths for .NET Core 3 migration</a><br><a href="https://stackoverflow.com/questions/48650348/">additionalProbingPaths not respected after dotnet publish?</a><br><a href="https://www.imooc.com/article/299861">netcore项目生成 runtimeconfig.json 文件 &amp; additionalProbingPaths 详解</a><br><a href="https://www.cnblogs.com/TianFang/p/12420573.html">.Net core 程序Nuget包独立存放 （一）</a><br><a href="https://www.cnblogs.com/TianFang/p/12424902.html">.Net core 程序Nuget包独立存放 （二）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> MSBuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust项目文件的组织方式</title>
      <link href="/2023/07/06/rust-workspace/"/>
      <url>/2023/07/06/rust-workspace/</url>
      
        <content type="html"><![CDATA[<h2 id="创建工程的命令"><a href="#创建工程的命令" class="headerlink" title="创建工程的命令"></a>创建工程的命令</h2><p><code>cargo new hello --bin</code>：创建一个可执行文件项目。<code>--bin</code>是默认参数，可以不写。<br><code>cargo new mylib --lib</code>：创建一个静态库项目。</p><h2 id="特殊的文件与目录"><a href="#特殊的文件与目录" class="headerlink" title="特殊的文件与目录"></a>特殊的文件与目录</h2><h3 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h3><p>通过<code>cargo new hello</code>命令建立一个新工程，目录是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure><p><code>main.rs</code>就是入口文件，最终生成一个可执行文件。适合小项目，单文件。</p><h3 id="lib-rs"><a href="#lib-rs" class="headerlink" title="lib.rs"></a>lib.rs</h3><p>在<code>src</code>目录下添加一个名为<code>lib.rs</code>的文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_world</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main.rs</code>中调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello::hello_world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">hello_world</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Rust 中，同时存在 main.rs 和 lib.rs 的工程类型被称为 “Binary crate with a library”（带有库的二进制 crate）。这种类型的工程既可以作为库被其他 crate 依赖，又可以作为可执行文件被直接运行。</p><p>这种工程类型通常用于开发命令行工具或其他需要同时作为库和应用程序的工具。lib.rs 文件中定义的函数、类型和常量可以被其他 crate 导入和使用，而 main.rs 文件中则定义了可执行文件的入口函数。</p><p>需要注意的是，main.rs 和 lib.rs 文件中的代码可以相互调用，因为它们在同一个 crate 中。如果 main.rs 和 lib.rs 分别位于不同的 crate 中，那么就需要在 Cargo.toml 文件中将这两个 crate 作为依赖项，并使用 extern crate 语句将它们导入到代码中。</p><h3 id="src-bin"><a href="#src-bin" class="headerlink" title="src&#x2F;bin"></a>src&#x2F;bin</h3><p><code>src/bin</code>是一个特殊目录。它用于存放二进制文件的目录。每个位于该目录下的<code>.rs</code>文件都会被编译成一个独立的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── bin</span><br><span class="line">        ├── app1.rs</span><br><span class="line">    └── app2.rs</span><br></pre></td></tr></table></figure><p>同时，在<code>src</code>目录下也可以存在<code>main.rs</code>和<code>lib.rs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src/</span><br><span class="line">    ├── bin/</span><br><span class="line">    │   ├── app1.rs</span><br><span class="line">    │   └── app2.rs</span><br><span class="line">├── main.rs</span><br><span class="line">    └── lib.rs</span><br></pre></td></tr></table></figure><p>在这种组织方式下，src&#x2F;lib.rs 文件中定义的函数、类型和常量可以被 src&#x2F;bin 目录下的源文件导入和使用，形成一个完整的项目。</p><h2 id="workspace-案例"><a href="#workspace-案例" class="headerlink" title="workspace 案例"></a>workspace 案例</h2><p>workspace（工作区）是指一个包含多个 crate 的项目，这些 crate 可以相互依赖和共享代码。工作区可以使得多个 crate 的开发、构建和测试更加方便和高效。<br>要创建一个 workspace，可以按照以下步骤进行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo new app1</span><br><span class="line">cargo new app2</span><br><span class="line">cargo new mylib --lib</span><br><span class="line">cargo new dynlib --lib</span><br></pre></td></tr></table></figure><p>这样就创建了两个可执行文件，两个库。根目录下创建<code>Cargo.toml</code>文件，内容如下</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;app1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;app2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mylib&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dynlib&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="创建DLL动态库工程"><a href="#创建DLL动态库工程" class="headerlink" title="创建DLL动态库工程"></a>创建DLL动态库工程</h3><p>我们将<code>dynlib</code>改为动态库工程，在<code>Cargo.toml</code>文件中添加如下配置，指定输出的文件类型为 DLL</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure><p>源文件<code>lib.rs</code>中写一个导出函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的DLL接口是标准的C ABI，其他语言也是可以调用的。</p><h3 id="工程间的依赖"><a href="#工程间的依赖" class="headerlink" title="工程间的依赖"></a>工程间的依赖</h3><p>我们现在让<code>app1</code>依赖这个DLL工程并使用它，编辑<code>app1/Cargo.toml</code>文件，在<code>[dependencies]</code>下编译依赖项</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dylib</span> = &#123; path = <span class="string">&quot;../dynlib&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>调用方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link(name = <span class="string">&quot;dynlib.dll&quot;</span>, kind=<span class="string">&quot;dylib&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add = &#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">add</span>(<span class="number">5</span>, <span class="number">8</span>) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，大型工程推荐用这种结构来组织代码。<br>另外，工程类型可以是以下类型：</p><ul><li>bin：可执行文件。</li><li>lib：Rust自己的库。</li><li>staticlib：静态库，msvc会生成<code>.a</code>文件。</li><li>dylib：动态库，但是只能Rust程序用。</li><li>cdylib：动态库，标准C导出接口，所有其他程序都可以用。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://course.rs/cargo/reference/workspaces.html">工作空间 Workspace</a><br><a href="https://rustcc.cn/article?id=98b96e69-7a5f-4bba-a38e-35bdd7a0a7dd">Rust 中的 bin, lib, rlib, a, so 概念介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 序列化对象到XML</title>
      <link href="/2023/07/05/XmlSerializer/"/>
      <url>/2023/07/05/XmlSerializer/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>C#中要将一个对象序列化到XML，或从XML反序列化需要用到 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlserializer">XmlSerializer</a> 类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> MyEnum</span><br><span class="line">    &#123;</span><br><span class="line">        Enum1,</span><br><span class="line">        Enum2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _val1;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Val2;</span><br><span class="line">        <span class="keyword">public</span> MyEnum MyEnum;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Val3 &#123; <span class="keyword">get</span>; &#125; = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Val4 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span>? Val5 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Cat MyCat = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; Arr1;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> StaticVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="keyword">new</span> Student()</span><br><span class="line">            &#123;</span><br><span class="line">                Arr1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="number">10</span>,</span><br><span class="line">                    <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(obj.GetType());</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;obj.xml&quot;</span>, FileMode.Create);</span><br><span class="line">            serializer.Serialize(fs, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出XML内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Val2</span>&gt;</span>0<span class="tag">&lt;/<span class="name">Val2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyEnum</span>&gt;</span>Enum1<span class="tag">&lt;/<span class="name">MyEnum</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Val5</span> <span class="attr">xsi:nil</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyCat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Color</span>&gt;</span>0<span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">MyCat</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Arr1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>10<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>20<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Arr1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Val4</span>&gt;</span>0<span class="tag">&lt;/<span class="name">Val4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见类成员并没有完全被序列化，因为 XmlSerializer 默认不会序列化以下几种数据：</p><ol><li>静态成员，因为静态成员属于类而不是实例。</li><li>只读成员，因为只读成员在反序列化时不能被初始化。</li><li>私有成员，因为私有成员不能从外部访问，因此无法序列化和反序列化。</li></ol><h2 id="必须有默认构造函数"><a href="#必须有默认构造函数" class="headerlink" title="必须有默认构造函数"></a>必须有默认构造函数</h2><p>当类没有提供无参数构造函数时，构造 XmlSerializer 时就会抛出<code>InvalidOperationException</code>异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student 无法序列化，因为它没有无参数的构造函数。</span><br></pre></td></tr></table></figure><h2 id="实现-IXmlSerializable-接口"><a href="#实现-IXmlSerializable-接口" class="headerlink" title="实现 IXmlSerializable 接口"></a>实现 IXmlSerializable 接口</h2><p>在某些情况下，XmlSerializer类的默认行为可能无法满足需求，这时就需要实现 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.ixmlserializable">IXmlSerializable</a> 接口来控制序列化和反序列化过程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span>: <span class="title">IXmlSerializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _val1;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val2;</span><br><span class="line">    <span class="keyword">public</span> MyEnum MyEnum;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val3</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125; = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val4</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125; = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ? Val5 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Cat MyCat = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">public</span> List &lt; <span class="built_in">int</span> &gt; Arr1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> StaticVal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XmlSchema <span class="title">GetSchema</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 没用，总是返回null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadXml</span>(<span class="params">XmlReader reader</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Val2 = reader.ReadElementContentAsInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteXml</span>(<span class="params">XmlWriter writer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writer.WriteValue(Val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出XML内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Student</span>&gt;</span>0<span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一些需要实现IXmlSerializable接口的情况：</p><ol><li>控制值的输出格式。</li><li>需要序列化私有成员时。</li><li>当需要在序列化过程中执行一些自定义的操作时，例如在序列化之前或之后执行某些操作，或者在序列化期间处理异常时。</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>使用注解（Attribute）来为XML序列化和反序列化提供更多的控制和灵活性。</p><h3 id="XmlRoot"><a href="#XmlRoot" class="headerlink" title="XmlRoot"></a>XmlRoot</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlattributes.xmlroot">XmlRoot</a> 用于指定XML文档根元素名称和命名空间的注解。它可以应用于类或结构体，并且可以在序列化和反序列化过程中提供更多的控制和灵活性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">XmlRoot(<span class="string">&quot;Person&quot;</span>, Namespace = <span class="string">&quot;http://example.com&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出XML内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Alice<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XmlElement"><a href="#XmlElement" class="headerlink" title="XmlElement"></a>XmlElement</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlelementattribute">XmlElement</a> 用于将类的属性或字段序列化为XML元素的注解。它可以应用于公共字段或属性，并且可以指定XML元素的名称和命名空间。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">XmlElement(<span class="string">&quot;FullName&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">XmlElement(<span class="string">&quot;Years&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Years</span>&gt;</span>0<span class="tag">&lt;/<span class="name">Years</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，XmlElement 注解指定了节点元素的名称。更多用法参考 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlelementattribute">XmlElement</a></p><h3 id="XmlAttribute"><a href="#XmlAttribute" class="headerlink" title="XmlAttribute"></a>XmlAttribute</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlattributeattribute">XmlAttribute</a> 是用于将类的属性或字段序列化为XML属性的注解。它可以应用于公共字段或属性，并且可以指定XML属性的名称和命名空间。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">XmlAttribute(<span class="string">&quot;Years&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">Years</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Alice<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，注解将Age属性序列化为XML属性，属性名为”Years”。更多用法参考 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlattributes">XmlAttributes</a></p><h3 id="XmlArray"><a href="#XmlArray" class="headerlink" title="XmlArray"></a>XmlArray</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlarrayattribute">XmlArray</a> 用于将数组或集合属性序列化为XML数组的注解。它可以应用于公共字段或属性，并且可以指定XML数组的名称、元素名称和命名空间。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">XmlArray(<span class="string">&quot;Interests&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">XmlArrayItem(<span class="string">&quot;Interest&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] Interests &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，注解指定了生成的XML数组的名称为”Interests”。同时，XmlArrayItem注解指定了生成的XML数组元素的名称为”Interest”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Alice<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Interests</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Interest</span>&gt;</span>Reading<span class="tag">&lt;/<span class="name">Interest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Interest</span>&gt;</span>Traveling<span class="tag">&lt;/<span class="name">Interest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Interest</span>&gt;</span>Hiking<span class="tag">&lt;/<span class="name">Interest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Interests</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XmlIgnore"><a href="#XmlIgnore" class="headerlink" title="XmlIgnore"></a>XmlIgnore</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlignoreattribute">XmlIgnore</a> 用于公共字段或属性，并用于指示XmlSerializer忽略该字段或属性的序列化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">XmlIgnore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h3><p>还有一些其他不常用的注解参考官方手册 <a href="https://learn.microsoft.com/zh-cn/dotnet/standard/serialization/attributes-that-control-xml-serialization">用来控制 XML 序列化的属性</a></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/serialization/how-to-serialize-an-object">如何：序列化对象</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/serialization/introducing-xml-serialization#xml-serialization-considerations">XML 序列化注意事项</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust模块的使用</title>
      <link href="/2023/07/04/rust-mod/"/>
      <url>/2023/07/04/rust-mod/</url>
      
        <content type="html"><![CDATA[<h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><p>模块分为两种形式存在</p><h3 id="内联模块"><a href="#内联模块" class="headerlink" title="内联模块"></a>内联模块</h3><p>内敛模块就是写在源文件内部</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> mod1 &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        n + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mod1::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然是在同一个文件，但也要求函数用<code>pub</code>关键字公开才能访问。</p><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><p>默认情况下，文件模块以两种形式存在</p><ol><li><code>module_name.rs</code><br>此时文件名就是模块名。</li><li><code>module_name/mod.rs</code><br>此时文件夹名就是模块名。</li></ol><p>如果同时存在同名文件和文件夹会如何呢？这会产生歧义，编译器会发出错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0761]: file <span class="keyword">for</span> <span class="title class_">module</span> `mod2` found at both <span class="string">&quot;src\mod2.rs&quot;</span> and <span class="string">&quot;src\mod2\mod.rs&quot;</span></span><br></pre></td></tr></table></figure><p>并要求删除其中一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help: delete or rename one of them to remove the ambiguity</span><br></pre></td></tr></table></figure><p>用文件夹的方式是为了用嵌套模块，子模块文件应该在文件夹下，比如<code>parent/child.rs</code>，然后在<code>mod.rs</code>文件中导出子模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> child;</span><br></pre></td></tr></table></figure><p>不过需要注意，这个<code>mod.rs</code>的约定从 <a href="https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html#no-more-modrs">Rust 2018</a> 开始就不推荐了，因为当模块过多时将会有很多同名文件。</p><h3 id="包含子模块的模块"><a href="#包含子模块的模块" class="headerlink" title="包含子模块的模块"></a>包含子模块的模块</h3><p>从 Rust 2018 起，就不要再用<code>mod.rs</code>那样的方式组织子模块了，推荐方式是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.rs</span><br><span class="line">foo.rs</span><br><span class="line">foo/bar.rs</span><br><span class="line">foo/bar/xyz.rs</span><br></pre></td></tr></table></figure><p>这样就有3个层级</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, foo::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, foo::bar::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, foo::bar::xyz::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块引用方式"><a href="#模块引用方式" class="headerlink" title="模块引用方式"></a>模块引用方式</h2><h3 id="默认方式"><a href="#默认方式" class="headerlink" title="默认方式"></a>默认方式</h3><p>用<code>mod module_name</code>引用即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> mod2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mod2::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="path属性定位模块文件"><a href="#path属性定位模块文件" class="headerlink" title="path属性定位模块文件"></a>path属性定位模块文件</h3><p>假设有一个模块文件在<code>src/a/b/c.rs</code>文件中，那么使用时可以通过<code>path</code>属性定位，并且模块名可以自定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[path = <span class="string">&quot;a/b/c.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> mod3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mod3::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include宏包含模块"><a href="#include宏包含模块" class="headerlink" title="include宏包含模块"></a>include宏包含模块</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> mod3 &#123;</span><br><span class="line">    include!(<span class="string">&quot;a/b/c.rs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mod3::<span class="title function_ invoke__">add</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也可以自定义模块名。主要的区别是<code>include!</code>会把代码文件插入进来，这可以用于将大量的代码拆分到多个文件中，使代码更加清晰和易于维护。<br>但这样做的缺点是对IDE提示不友好，无法得知模块内提供了什么内容。</p><h2 id="模块访问权限"><a href="#模块访问权限" class="headerlink" title="模块访问权限"></a>模块访问权限</h2><p>默认情况下，模块内所有数据都是私有的，需要通过<code>pub</code>关键字公开</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将子模块公开</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开。可以从任何地方访问</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add1</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    n + <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有。本模块和子模块可访问</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) <span class="keyword">fn</span> <span class="title function_">add2</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    n + <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部。就是在当前工程内均可见</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">add3</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    n + <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父模块可见</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">add4</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    n + <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定的模块可见</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::other) <span class="keyword">fn</span> <span class="title function_">add5</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">     n + <span class="number">50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Rust</title>
      <link href="/2023/07/01/rust-setup/"/>
      <url>/2023/07/01/rust-setup/</url>
      
        <content type="html"><![CDATA[<h2 id="安装MSVC"><a href="#安装MSVC" class="headerlink" title="安装MSVC"></a>安装MSVC</h2><p>Rust 链接依赖<code>MSVC</code>或者<code>GNU</code>，而在Windows下，自然是选择MSVC了。<br>下载 Visual Studio：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p><h2 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h2><p>在安装前先修改安装源，因为中国大陆的网络大家都懂的。执行以下CMD命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setx RUSTUP_DIST_SERVER <span class="string">&quot;https://rsproxy.cn&quot;</span> /M</span><br><span class="line">setx RUSTUP_UPDATE_ROOT <span class="string">&quot;https://rsproxy.cn/rustup&quot;</span> /M</span><br><span class="line">setx RUSTUP_HOME <span class="string">&quot;D:\Rust\home&quot;</span> /M</span><br><span class="line">setx CARGO_HOME <span class="string">&quot;D:\Rust\cargo&quot;</span> /M</span><br><span class="line">setx PATH <span class="string">&quot;%PATH%%%CARGO_HOME%\bin&quot;</span> /M</span><br></pre></td></tr></table></figure><p>其中<code>RUSTUP_DIST_SERVER</code>和<code>RUSTUP_UPDATE_ROOT</code>是安装源。而<code>RUSTUP_HOME</code>和<code>CARGO_HOME</code>是指定安装目录，这个是可选的，默认会在C盘。<br>接着去 <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> 下载安装程序，有32位和64位两种版本选择。<br>32位直连地址：<a href="https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe">rustup-init.exe</a><br>64位直连地址：<a href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">rustup-init.exe</a><br><strong>注意，下载完成后不要双击启动安装程序，否则无法读到前面设置的环境变量，应该通过CMD窗口启动</strong><br>安装过程就是下一步就行了，没什么好介绍的了。<br>安装结束后重开一个CMD窗口（因为环境变量在当前窗口中还未生效）。输入命令行验证一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><p>正确的话会打印Rust版本号。</p><h2 id="修改crates源"><a href="#修改crates源" class="headerlink" title="修改crates源"></a>修改crates源</h2><p><code>crates</code>就是像<code>npm</code>那样的仓库。进入<code>cargo</code>根目录，创建一个没有扩展名，名为<code>config</code>的文件，内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="comment"># To use sparse index, change &#x27;rsproxy&#x27; to &#x27;rsproxy-sparse&#x27;</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">&#x27;rsproxy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[source.rsproxy]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;https://rsproxy.cn/crates.io-index&quot;</span></span><br><span class="line"><span class="section">[source.rsproxy-sparse]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;sparse+https://rsproxy.cn/index/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[registries.rsproxy]</span></span><br><span class="line"><span class="attr">index</span> = <span class="string">&quot;https://rsproxy.cn/crates.io-index&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[net]</span></span><br><span class="line"><span class="attr">git-fetch-with-cli</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="安装IDE"><a href="#安装IDE" class="headerlink" title="安装IDE"></a>安装IDE</h2><p>IDE可以选择用 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 或者 <a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">IntelliJ IDEA</a><br>我选择了更专业的<code>IntelliJ IDEA</code>，接着安装Rust插件：<a href="https://plugins.jetbrains.com/plugin/8182-rust">https://plugins.jetbrains.com/plugin/8182-rust</a></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>万事俱备，可以开始创建第一个工程了，新建一个文件夹，然后用<code>cargo</code>创建工程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello</span><br></pre></td></tr></table></figure><p>接着用<code>IntelliJ IDEA</code>打开刚刚创建的 hello 文件夹，首次运行IDE会自动下载相关的依赖，需要稍等片刻。<br>接着打开<code>main.rs</code>文件，按下<code>Shift + F10</code>启动第一个Rust程序吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 固定对象探索</title>
      <link href="/2023/06/28/gchandle-fixed/"/>
      <url>/2023/06/28/gchandle-fixed/</url>
      
        <content type="html"><![CDATA[<h2 id="封送数据会产生副本"><a href="#封送数据会产生副本" class="headerlink" title="封送数据会产生副本"></a>封送数据会产生副本</h2><p>最近踩了一个坑，场景是C#调用非托管DLL函数，这个函数是异步的，参数是一个结构体指针，函数需要长期持有这个指针，因为函数在运行期间会对结构进行读写，同时调用方也会对这个结构进行读写。<br>那么问题来了，在C#中，与非托管DLL交互的标准做法是通过 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure">Marshal.PtrToStructure</a> 和 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.structuretoptr">Marshal.StructureToPtr</a> 方法进行封送，<strong>但是需要注意，这两个方法的本质是将结数据创建一个副本，也就是托管内存区域一个结构，非托管内存区域一个结构，两者互不干扰。</strong><br>对于我的需求，这种方法行不通，因为在函数异步执行期间，在调用方对结构的修改反映不到非托管内存，反之亦然，这样两边的数据就是不同步的。<br>于是我想是否有办法能获得托管对象的指针地址并且保证其不被GC移动。</p><h2 id="用-GCHandle-固定对象"><a href="#用-GCHandle-固定对象" class="headerlink" title="用 GCHandle 固定对象"></a>用 GCHandle 固定对象</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.gchandle.alloc">GCHandle.Alloc</a> 是一个用于将托管对象的引用固定在内存中的方法。在.NET环境中，托管对象的内存管理是由垃圾回收器自动处理的。当托管对象不再被引用时，垃圾回收器会自动回收其内存。但是，在某些情况下，需要将对象的引用固定在内存中，以确保对象的内存不会被回收，例如：</p><ol><li>将托管对象的引用传递给非托管代码。</li><li>在使用指针操作时需要固定对象的引用。</li></ol><p>在这些情况下，可以使用 GCHandle.Alloc 方法将对象的引用固定在内存中，以确保对象的内存不会被移动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个结构体对象</span></span><br><span class="line">        MyStruct myStruct = <span class="keyword">new</span> MyStruct();</span><br><span class="line">        myStruct.x = <span class="number">10</span>;</span><br><span class="line">        myStruct.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 固定结构体引用</span></span><br><span class="line">        GCHandle handle = GCHandle.Alloc(myStruct, GCHandleType.Pinned);</span><br><span class="line">        IntPtr ptr = handle.AddrOfPinnedObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指针上执行操作</span></span><br><span class="line">        <span class="built_in">int</span>* p = (<span class="built_in">int</span>*)ptr.ToPointer();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放结构体引用</span></span><br><span class="line">        handle.Free();</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的想法是，将这个托管结构体固定住，然后将指针传递给DLL，问题不就解决了吗？事实证明我天真了，因为它只支持所谓的 <a href="https://learn.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">Blittable</a> 类型。<br>对于不支持的类型会报错：<code>Object contains non-primitive or non-blittable data</code>。<br>使用<code>GCHandle.Alloc</code>方法时，只有包含基元类型或可以直接复制到本机结构中的托管类型的实例才能被转换为<code>GCHandle</code>。<br>意味着不可以使用数组（引用类型）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyData[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myStruct = <span class="keyword">new</span> MyClass();</span><br><span class="line">GCHandle handle = GCHandle.Alloc(myStruct, GCHandleType.Pinned); <span class="comment">// System.ArgumentException: Object 包含非基元或非直接复制到本机结构中的数据。</span></span><br></pre></td></tr></table></figure><p>但在实际开发中，我们的数据结构肯定是带有数组的，所以这个方法行不通。</p><h2 id="用-fixed-固定对象"><a href="#用-fixed-固定对象" class="headerlink" title="用 fixed 固定对象"></a>用 fixed 固定对象</h2><p><code>fixed</code>关键字用于将一个变量固定在内存中，以便在指针操作期间避免垃圾回收器的干扰。<code>fixed</code>只能用于值类型的变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential)</span>]</span><br><span class="line"><span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyStruct myStruct = <span class="keyword">new</span> MyStruct();</span><br><span class="line">        myStruct.x = <span class="number">10</span>;</span><br><span class="line">        myStruct.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fixed</span> (MyStruct* pMyStruct = &amp;myStruct)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在指针上执行操作</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;</span>, pMyStruct-&gt;x, pMyStruct-&gt;y);</span><br><span class="line">            pMyStruct-&gt;x = <span class="number">30</span>;</span><br><span class="line">            pMyStruct-&gt;y = <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;</span>, myStruct.x, myStruct.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法只保证在<code>fixed</code>区域内内存不会被GC移动，所以对于我的问题，需要将DLL接口函数改为同步模式，阻塞函数防止其离开<code>fixed</code>区域。<br>当我开始尝试时，又报错了：<code>error CS1663: 固定大小的缓冲区类型必须为下列类型之一: bool、byte、short、int、long、char、sbyte、ushort、uint、ulong、float 或 double</code>。<br>因为数组也只能是基础数据类型，比如这样的结构体就编译不了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">struct</span> MyData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">fixed</span> MyData data[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以此方案也无法解决我的问题。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>C#的<code>P/Invoke</code>技术虽然已经很好用了，但仍然还是有一些局限性。就我遇到的问题可以看出来，理想情况下，数据最好是单向流动的。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://stackoverflow.com/questions/1850488">Pinning an updateble struct before passing to unmanaged code?</a><br><a href="https://stackoverflow.com/questions/3630043">Will struct modifications in C# affect unmanaged memory?</a><br><a href="https://stackoverflow.com/questions/7956355">Can C# structs coming from the unmanaged world be “live”-updating?</a><br><a href="https://stackoverflow.com/questions/18839085">Why can fixed size buffers only be of primitive types?</a><br><a href="https://stackoverflow.com/questions/36564436">Workaround on declaring a unsafe fixed custom struct array?</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/framework/interop/blittable-and-non-blittable-types">Blittable and Non-Blittable Types</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变QtVarsOutputDir输出位置</title>
      <link href="/2023/06/24/change-QtVarsOutputDir/"/>
      <url>/2023/06/24/change-QtVarsOutputDir/</url>
      
        <content type="html"><![CDATA[<p>在VS中编译Qt项目，总是会在工程目录下创建<code>x64\Debug\qmake\qtvars_x64_Debug.props</code>文件。<br>研究一番后发现，Qt工程会引入属性表文件<code>Qt.props</code>，位置在<code>C:\Users\&#123;用户名&#125;\AppData\Local\QtMsBuild</code>目录下<br>内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  /////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">  // Import private Qt property definitions</span></span><br><span class="line"><span class="comment">  // --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">&quot;Qt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(MSBuildThisFileDirectory)\qt_private.props&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ImportGroup</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  /////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">  // User-defined settings</span></span><br><span class="line"><span class="comment">  // --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">&quot;UserMacros&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Placeholder for user macros written by VS Property Manager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Placeholder for properties written by VS Property Manager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Placeholder for default metadata written by VS Property Manager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Placeholder for items written by VS Property Manager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它又导入了<code>qt_private.props</code>文件，其中包含这么一段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(QtVsProjectSettings)&#x27; == &#x27;true&#x27;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--// Path to Qt variables property file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsOutputDir</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(QtVarsOutputDir)&#x27; == &#x27;&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$([System.IO.Path]::Combine(&#x27;$(ProjectDir)&#x27;, &#x27;$(IntDir)&#x27;, &#x27;qmake&#x27;))<span class="tag">&lt;/<span class="name">QtVarsOutputDir</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsFileName</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(QtVarsFileName)&#x27; == &#x27;&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>qtvars_$(Platform.Replace(&#x27; &#x27;,&#x27;_&#x27;))_$(Configuration.Replace(&#x27; &#x27;,&#x27;_&#x27;)).props<span class="tag">&lt;/<span class="name">QtVarsFileName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsFilePath</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(QtVarsFilePath)&#x27; == &#x27;&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$(QtVarsOutputDir)\$(QtVarsFileName)<span class="tag">&lt;/<span class="name">QtVarsFilePath</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--// Path to temp work folder --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsWorkDirName</span></span></span><br><span class="line"><span class="tag">      &gt;</span>temp<span class="tag">&lt;/<span class="name">QtVarsWorkDirName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsWorkDir</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$([System.IO.Path]::Combine(&#x27;$(QtVarsOutputDir)&#x27;,&#x27;$(QtVarsWorkDirName)&#x27;))<span class="tag">&lt;/<span class="name">QtVarsWorkDir</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsWorkPath</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$(QtVarsWorkDir)\$(QtVarsFileName)<span class="tag">&lt;/<span class="name">QtVarsWorkPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsIndexPathDesignTime</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$(QtVarsWorkDir)\$(ProjectGuid.Replace(&#x27;&#123;&#x27;,&#x27;&#x27;).Replace(&#x27;&#125;&#x27;,&#x27;&#x27;)).$(ProjectName).designtime.idx<span class="tag">&lt;/<span class="name">QtVarsIndexPathDesignTime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QtVarsDesignTime</span> <span class="attr">Condition</span>=<span class="string">&quot;Exists(&#x27;$(QtVarsIndexPathDesignTime)&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>$([System.String]::Copy($([System.IO.File]::ReadAllText(&#x27;$(QtVarsIndexPathDesignTime)&#x27;))).Replace(&#x27;<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>&#x27;,&#x27;&#x27;))           <span class="tag">&lt;/<span class="name">QtVarsDesignTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>QtVarsOutputDir</code>就是这个目录的输出位置，这里用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.io.path.combine#system-io-path-combine(system-string-system-string-system-string)">Path.Combine</a> 合并成了最终路径，其中内置宏 <code>$(IntDir)</code> 指向的是<strong>中间目录</strong></p><p><img src="/images/014839.png"></p><p>也就是说<code>qmake</code>的相关临时文件应该输出到<strong>中间目录</strong>，可是在修改了中间目录后并没有起到效果，相关的临时文件还是输出到<code>x64\Debug\qmake</code>目录下了，猜测在编译工程时的<code>$(IntDir)</code>变量仍然是默认值，修改后的值并没有被采用。</p><p>折腾一番后终于发现了原因所在：顺序问题！当在VS界面中修改中间目录后，在工程文件中会多出这样一段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Debug|x64&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">IntDir</span>&gt;</span>_obj\$(Configuration)\<span class="tag">&lt;/<span class="name">IntDir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再往上翻一点肯定可以看到这个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">&quot;PropertySheets&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Debug|x64&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;exists(&#x27;$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props&#x27;)&quot;</span> <span class="attr">Label</span>=<span class="string">&quot;LocalAppDataPlatform&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(QtMsBuild)\Qt.props&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ImportGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">&quot;PropertySheets&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Release|x64&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;exists(&#x27;$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props&#x27;)&quot;</span> <span class="attr">Label</span>=<span class="string">&quot;LocalAppDataPlatform&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$(QtMsBuild)\Qt.props&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ImportGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>原因就是在导入Qt.props时，IntDir还未被解析</strong>。<br>所以解决方法有两种：</p><ol><li>在导入<code>Qt.props</code>之前设置<code>QtVarsOutputDir</code>，这样<code>qt_private.props</code>文件中的<code>Condition</code>将会为<code>false</code>。</li><li>将<code>&lt;IntDir&gt;</code>移动至Qt属性表导入之前，或者干脆就放在<code>QtSettings</code>下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Debug|x64&#x27;&quot;</span> <span class="attr">Label</span>=<span class="string">&quot;QtSettings&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtInstall</span>&gt;</span>Qt6<span class="tag">&lt;/<span class="name">QtInstall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtModules</span>&gt;</span>core;gui;widgets<span class="tag">&lt;/<span class="name">QtModules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtBuildConfig</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">QtBuildConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IntDir</span>&gt;</span>_obj\$(Configuration)\<span class="tag">&lt;/<span class="name">IntDir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Release|x64&#x27;&quot;</span> <span class="attr">Label</span>=<span class="string">&quot;QtSettings&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtInstall</span>&gt;</span>Qt6<span class="tag">&lt;/<span class="name">QtInstall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtModules</span>&gt;</span>core;gui;widgets<span class="tag">&lt;/<span class="name">QtModules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">QtBuildConfig</span>&gt;</span>release<span class="tag">&lt;/<span class="name">QtBuildConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IntDir</span>&gt;</span>_obj\$(Configuration)\<span class="tag">&lt;/<span class="name">IntDir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>如果<code>Debug</code>和<code>Release</code>的值是相同的话，也可以放在<code>Globals</code>下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">&quot;Globals&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">IntDir</span>&gt;</span>_obj\$(Configuration)\<span class="tag">&lt;/<span class="name">IntDir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://bugreports.qt.io/browse/QTVSADDINBUG-721">QtVarsOutputDir cannot be changed</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo标签丢失特殊符号的问题</title>
      <link href="/2023/06/22/hexo-tag-map/"/>
      <url>/2023/06/22/hexo-tag-map/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Hexo在生成静态文件时会忽略不合法的URL字符，典型的如<code>#</code>、<code>&amp;</code>、<code>+</code>等等。</p><p>但是在编程领域这些字符是非常常见的，如<code>C++</code>、<code>C#</code>，如果用这两个单词作为 Tag，那么最终在 URL 里会显示为 <code>site.com/tags/C</code></p><p>这就导致了两个不相关的文章被打上了同一个标签。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Hexo 提供了 <a href="https://hexo.io/docs/configuration.html#Category-amp-Tag">tag_map</a> 功能，编辑<code>_config.yml</code> 文件即可，比如这样</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">  <span class="string">C++:</span> <span class="string">c-plus-plus</span></span><br><span class="line">  <span class="string">C#:</span> <span class="string">c-sharp</span></span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://bitbadger.solutions/blog/2017/mapping-categories-and-tags-with-hexo.html">https://bitbadger.solutions/blog/2017/mapping-categories-and-tags-with-hexo.html</a></p><p><a href="https://github.com/hexojs/hexo/issues/908">https://github.com/hexojs/hexo/issues/908</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用std::function实现通用事件回调</title>
      <link href="/2023/06/17/eJTolbQy8/"/>
      <url>/2023/06/17/eJTolbQy8/</url>
      
        <content type="html"><![CDATA[<p>最近在实现一个回调功能时遇到一点小难题。基于 <code>std::function</code> 实现的回调，它没有 <code>==</code> 操作，无法比较也就无法取消订阅，查阅了些资料后总结出主流的几种解决方案</p><h2 id="如何从-vector-中移除-function"><a href="#如何从-vector-中移除-function" class="headerlink" title="如何从 vector 中移除 function"></a>如何从 vector 中移除 function</h2><p>先看看问题代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;cb1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;cb2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> MsgCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(<span class="type">const</span> MsgCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_list.<span class="built_in">push_back</span>(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(MsgCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 编译错误：error C2678: 二进制“==”: 没有找到接受“MsgCallback”类型的左操作数的运算符(或没有可接受的转换)</span></span><br><span class="line">std::<span class="built_in">erase_if</span>(_list, [&amp;](<span class="type">const</span> MsgCallback&amp; elem) &#123;<span class="keyword">return</span> cb == elem; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;MsgCallback&gt; _list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Manager mgr;</span><br><span class="line"></span><br><span class="line">Person obj&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> callback = std::<span class="built_in">bind</span>(&amp;Person::cb1, &amp;obj);</span><br><span class="line"></span><br><span class="line">mgr.<span class="built_in">subscribe</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因就在于 <code>std::function</code> 没有 <code>==</code> 操作符，不可以进行比较，如果不比较就没法取消事件订阅。<br>目前我认为可用的三种解决方案</p><h3 id="订阅时提供一个Key"><a href="#订阅时提供一个Key" class="headerlink" title="订阅时提供一个Key"></a>订阅时提供一个Key</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> MsgCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::map&lt;std::string, MsgCallback&gt; _list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>订阅者需要提供一个唯一的 key，用于取消订阅时使用。</p><h3 id="用-std-weak-ptr"><a href="#用-std-weak-ptr" class="headerlink" title="用 std::weak_ptr"></a>用 std::weak_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;MsgCallback&gt;&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_list.<span class="built_in">push_back</span>(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;std::weak_ptr&lt;MsgCallback&gt;&gt; _list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就不再需要 <code>unsubscribe</code> 方法了，订阅者只需要将指针置空即可自动取消。<br>触发事件时应该检查指针是否为空，失效的指针应当即时清理。</p><h3 id="用-vector-的索引"><a href="#用-vector-的索引" class="headerlink" title="用 vector 的索引"></a>用 vector 的索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;<span class="type">void</span>()&gt; subs;</span><br><span class="line"></span><br><span class="line">std::<span class="type">size_t</span> subscribe(std::function&lt;<span class="type">void</span>()&gt; f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = std::find(subs.begin(), subs.end(), <span class="literal">nullptr</span>); it != subs.end())</span><br><span class="line">    &#123;</span><br><span class="line">        *it = f;</span><br><span class="line">        <span class="keyword">return</span> std::distance(subs.begin(), it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        subs.push_back(f);</span><br><span class="line">        <span class="keyword">return</span> subs.size() - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> unsubscribe(std::<span class="type">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    subs[index] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和第一种方案类似，订阅者需要持有一个 key，不过这个 key 就是索引而已。我个人更喜欢这种方案。</p><h2 id="通用的事件管理器"><a href="#通用的事件管理器" class="headerlink" title="通用的事件管理器"></a>通用的事件管理器</h2><p>最后通过上面提到的第三种方式实现一个通用的事件类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Handler = std::function&lt;<span class="built_in">void</span>(Args...)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Event</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Event</span>(<span class="type">const</span> Event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">Event</span>(Event&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">move_from</span>(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">subscribe</span><span class="params">(<span class="type">const</span> Handler&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(_subscribers.<span class="built_in">begin</span>(), _subscribers.<span class="built_in">end</span>(), <span class="literal">nullptr</span>); it != _subscribers.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">*it = f;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">distance</span>(_subscribers.<span class="built_in">begin</span>(), it);</span><br><span class="line">&#125;</span><br><span class="line">_subscribers.<span class="built_in">push_back</span>(f);</span><br><span class="line"><span class="keyword">return</span> _subscribers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(std::<span class="type">size_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; _subscribers.<span class="built_in">size</span>())</span><br><span class="line">_subscribers[index] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TriggerArgs&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trigger</span><span class="params">(TriggerArgs&amp;&amp;... args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">sizeof</span>...(TriggerArgs) == <span class="keyword">sizeof</span>...(Args), <span class="string">&quot;Number of trigger arguments does not match event arguments.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subscriber : _subscribers)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subscriber != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">subscriber</span>(std::forward&lt;TriggerArgs&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event&amp; <span class="keyword">operator</span>=(Event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">Event&amp; <span class="keyword">operator</span>=(Event&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line"><span class="built_in">move_from</span>(other);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_from</span><span class="params">(Event&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_subscribers = std::<span class="built_in">move</span>(other._subscribers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Handler&gt; _subscribers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>唯一的瑕疵是使用 <code>subscribe</code> 时可以接受不同签名的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Event&lt;<span class="type">int</span>&gt; event;</span><br><span class="line"></span><br><span class="line">Person obj&#123;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cb1 = std::<span class="built_in">bind</span>(&amp;Person::cb1, &amp;obj, std::placeholders::_1);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cb2 = std::<span class="built_in">bind</span>(&amp;Person::cb2, &amp;obj);</span><br><span class="line"></span><br><span class="line">event.<span class="built_in">subscribe</span>(cb1);</span><br><span class="line">event.<span class="built_in">subscribe</span>(cb2);  <span class="comment">// 回调无参数，与Event的定义不同，但可以编译通过</span></span><br><span class="line"></span><br><span class="line">event.<span class="built_in">trigger</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 <code>std::function&lt;void(Args...)&gt;</code> 可以接受更少的参数，只要没有被使用即可。编译器不会报错，因为在调用 <code>cb2</code> 时不会传递任何实参，因此没有参数被使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/39633596/">https://stackoverflow.com/questions/39633596/</a><br><a href="https://stackoverflow.com/questions/47249465/">https://stackoverflow.com/questions/47249465/</a><br><a href="https://stackoverflow.com/questions/74089196/">https://stackoverflow.com/questions/74089196/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译Qt6</title>
      <link href="/2023/05/07/build-qt6/"/>
      <url>/2023/05/07/build-qt6/</url>
      
        <content type="html"><![CDATA[<h2 id="编译基础模块-qtbase"><a href="#编译基础模块-qtbase" class="headerlink" title="编译基础模块 qtbase"></a>编译基础模块 qtbase</h2><p>Qt 6.5.0 下载：<a href="https://download.qt.io/archive/qt/6.5/6.5.0/">https://download.qt.io/archive/qt/6.5/6.5.0/</a><br>我只需要最基础的 UI 开发功能（ Core、Gui、Widgets），因此进入 <a href="https://download.qt.io/archive/qt/6.5/6.5.0/submodules/">submodules</a> 目录，仅下载 <code>qtbase</code> 模块即可，文件名是 <a href="https://download.qt.io/archive/qt/6.5/6.5.0/submodules/qtbase-everywhere-src-6.5.0.zip">qtbase-everywhere-src-6.5.0.zip</a>。<br>解压后可以查看一下 <code>config_help.txt</code> 文件，有详细的编译命令。<br>然后创建一个 <code>_build</code> 文件夹，这是为了将临时文件都生成在这里，避免污染源码目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> _build</span><br><span class="line"><span class="built_in">cd</span> _build</span><br></pre></td></tr></table></figure><p>接着根据自身需求配置编译参数，我用的是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\configure.bat -prefix <span class="string">&quot;D:/Qt6/dist&quot;</span> -platform win32-msvc -debug-and-release -shared -nomake examples -nomake tests -opengl dynamic</span><br></pre></td></tr></table></figure><p>配置后依次运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --parallel</span><br><span class="line">cmake --install . --config Debug</span><br><span class="line">cmake --install . --config Release</span><br></pre></td></tr></table></figure><p>成功后在 <code>D:/Qt6/dist</code> 目录下就有最终的 SDK 了。</p><h2 id="配置-Visual-Studio"><a href="#配置-Visual-Studio" class="headerlink" title="配置 Visual Studio"></a>配置 Visual Studio</h2><p>安装 VS 的开发插件 <a href="https://download.qt.io/official_releases/vsaddin/2.9.1/">https://download.qt.io/official_releases&#x2F;vsaddin&#x2F;2.9.1&#x2F;</a><br>插件只需要设置一下前面编译好的 Qt 文件夹路径即可。<br>创建一个工程可正常编译运行，但是发现无法编辑 <code>.ui</code> 文件，语言文件 <code>.ts</code> 也无法编辑，这是因为我们仅编译了 <code>qtbase</code> 模块，它不包含开发工具，开发工具在单独一个模块中，需要编译。<br>所以再次进入目录 <a href="https://download.qt.io/archive/qt/6.5/6.5.0/submodules/">https://download.qt.io/archive/qt/6.5/6.5.0/submodules/</a>，下载 <a href="https://download.qt.io/archive/qt/6.5/6.5.0/submodules/qttools-everywhere-src-6.5.0.zip">qttools-everywhere-src-6.5.0.zip</a> 文件并解压。<br>然后也和 <code>qtbase</code> 模块一样，创建一个临时目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> _build</span><br><span class="line"><span class="built_in">cd</span> _build</span><br></pre></td></tr></table></figure><p>附加模块的编译方式和 <code>qtbase</code> 不同，它是通过 <code>qtbase</code> 编译生成出的 <code>qt-configure-module.bat</code> 脚本编译的，这也说明了在编译附加模块前必须先编译 <code>qtbase</code>，它是基石。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Qt6\dist\bin\qt-configure-module.bat D:\Qt6\qttools-everywhere-src-6.5.0</span><br></pre></td></tr></table></figure><p>参数是附加模块的源码目录，配置好后接着执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --parallel</span><br><span class="line">cmake --install . --config Release</span><br></pre></td></tr></table></figure><p>成功后会在 <code>bin</code> 目录下生成出 <code>designer.exe</code> 和 <code>linguist.exe</code> 文件。这样当我们在 VS 中双击 <code>.ui</code> 文件或 <code>.ts</code> 文件时会启动相应的开发工具。</p><h2 id="安装语言文件"><a href="#安装语言文件" class="headerlink" title="安装语言文件"></a>安装语言文件</h2><p>编译生成的Qt助手、Qt设计师、Qt语言家程序界面是英文的，因为缺少翻译文件。官方提供了翻译文件下载<br><a href="https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/qt6_650/qt.qt6.650.win64_msvc2019_64/">https://download.qt.io/online/qtsdkrepository/windows_x86&#x2F;desktop&#x2F;qt6_650&#x2F;qt.qt6.650.win64_msvc2019_64&#x2F;</a></p><p>找到名字包含 <code>qttranslations</code> 的压缩包就是了，打开压缩包后将 <code>translations</code> 文件夹解压到 Qt 根目录下即可。再次打开Qt助手等程序就是中文了。</p><h2 id="安装文档"><a href="#安装文档" class="headerlink" title="安装文档"></a>安装文档</h2><p>自己编译的 Qt 是没有文档的，好在官方提供了预编译好的文档，我们只需要直接下载相应的模块文档并解压到 <code>doc</code> 目录下即可。<br>文档下载：<a href="https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/qt6_650_src_doc_examples/qt.qt6.650.doc/">https://download.qt.io/online/qtsdkrepository/windows_x86&#x2F;desktop&#x2F;qt6_650_src_doc_examples&#x2F;qt.qt6.650.doc&#x2F;</a></p><h2 id="大陆地区镜像站点"><a href="#大陆地区镜像站点" class="headerlink" title="大陆地区镜像站点"></a>大陆地区镜像站点</h2><p>当网络不好时，可以从国内的镜像站点下载相关资源</p><p>阿里云：<a href="https://mirrors.aliyun.com/qt/">https://mirrors.aliyun.com/qt/</a><br>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/</a><br>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a><br>中国互联网络信息中心：<a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></p><h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><p>还有傻瓜式的在线安装方式：<a href="http://download.qt.io/official_releases/online_installers/">http://download.qt.io/official_releases&#x2F;online_installers&#x2F;</a><br>在线安装本质就是从上面的站点下载预编译好的文件到本地，目前的<code>6.5.0</code> 版本用的<code>VC 2019</code>编译的，这意味着你的项目所使用的编译器最好和预编译的Qt保持一致。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/tcjiaan/p/16575655.html">https://www.cnblogs.com/tcjiaan/p/16575655.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 CRTP 技巧实现通用的 IUnknown 实现</title>
      <link href="/2023/04/15/CRTP/"/>
      <url>/2023/04/15/CRTP/</url>
      
        <content type="html"><![CDATA[<p>最近在写一个 COM 组件，没有用 ATL 模板，而是纯C++实现。<br>碰到一件麻烦事，每个接口的实现类都要反复实现 <code>AddRef</code>、<code>Release</code> 和 <code>QueryInterface</code> 方法。</p><p>比如有两个接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IA</span> : IUnknown &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IB</span> : IUnknown &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么每个类都要实现一次 IUnknown 接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> IA</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="type">void</span>** ppv)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">AddRef</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">Release</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ULONG _ref_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> IB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="type">void</span>** ppv)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">AddRef</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">Release</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ULONG _ref_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查阅了一些资料后，发现 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> 技巧可以不错的解决计数器代码复用的需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefCounted</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RefCounted</span>()</span><br><span class="line">&#123;</span><br><span class="line">_ref_count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//::InterlockedIncrement(&amp;g_obj_count);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RefCounted</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//::InterlockedDecrement(&amp;g_obj_count);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">Query</span><span class="params">(REFIID riid, <span class="type">void</span>** ppv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (riid == IID_IUnknown)</span><br><span class="line">&#123;</span><br><span class="line">*ppv = <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">static_cast</span>&lt;IUnknown*&gt;(*ppv)-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line"><span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HRESULT hr = E_NOINTERFACE;</span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _interfaces.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (riid == _interfaces[i].first)</span><br><span class="line">&#123;</span><br><span class="line">*ppv = _interfaces[i].second;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;IUnknown*&gt;(*ppv)-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line">hr = S_OK;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG <span class="title">Increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">InterlockedIncrement</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> LONG*&gt;(&amp;_ref_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG <span class="title">Decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> ULONG ref_count = <span class="built_in">InterlockedDecrement</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> LONG*&gt;(&amp;_ref_count));</span><br><span class="line"><span class="keyword">if</span> (ref_count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> ref_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddInterface</span><span class="params">(REFIID iid, <span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_interfaces.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(iid, p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;std::pair&lt;IID, <span class="type">void</span>*&gt;&gt; _interfaces;</span><br><span class="line"><span class="keyword">volatile</span> ULONG _ref_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个派生类要实现计数器时这么用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFile</span> : </span><br><span class="line"><span class="keyword">private</span> RefCounted&lt;MyFile&gt;,</span><br><span class="line"><span class="keyword">public</span> IRead,</span><br><span class="line">    <span class="keyword">public</span> IWrite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RefCounted&lt;MyFile&gt; super;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFile</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册支持的接口</span></span><br><span class="line">        super::<span class="built_in">AddInterface</span>(__uuidof(IRead), <span class="built_in">static_cast</span>&lt;IRead*&gt;(<span class="keyword">this</span>));</span><br><span class="line">        super::<span class="built_in">AddInterface</span>(__uuidof(IWrite), <span class="built_in">static_cast</span>&lt;IWrite*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 实现 IUnknown */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="type">void</span>** ppv)</span> </span>&#123; <span class="keyword">return</span> super::<span class="built_in">Query</span>(riid, ppv); &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">AddRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> super::<span class="built_in">Increment</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONG STDMETHODCALLTYPE <span class="title">Release</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> super::<span class="built_in">Decrement</span>(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 实现 IRead */</span></span><br><span class="line">    <span class="comment">/* 实现 IWrite */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 CRTP 技巧，将计数器的实现隐藏了起来，而派生类只需要关心业务接口的实现即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> COM编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL导出符号注意事项</title>
      <link href="/2022/10/27/7HAXJIccr/"/>
      <url>/2022/10/27/7HAXJIccr/</url>
      
        <content type="html"><![CDATA[<p>导出DLL函数有两种方法：</p><ol><li>使用 <a href="https://learn.microsoft.com/en-us/cpp/build/exporting-from-a-dll-using-declspec-dllexport">__declspec(dllexport)</a> 语法。</li><li>使用 <a href="https://learn.microsoft.com/en-us/cpp/build/exporting-from-a-dll-using-def-files">.def</a> 文件。</li></ol><p>但两者是有区别的，比如有这样一个函数签名<br><code>int __stdcall Foo(int);</code></p><table><thead><tr><th align="center">方法</th><th align="center">lib符号名称</th><th align="center">dll导出名称</th></tr></thead><tbody><tr><td align="center">__declspec(dllexport)</td><td align="center">?Foo@@YGHH@Z</td><td align="center">?Foo@@YGHH@Z</td></tr><tr><td align="center">.def file</td><td align="center">?Foo@@YGHH@Z</td><td align="center">Foo</td></tr></tbody></table><p>用<code>.def</code>文件导出的函数名称是干净的，也方便其他程序调用。<br>而 <code>__declspec(dllexport)</code>导出的名称被修饰了，只适合C++程序使用。</p><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p><code>extern &quot;C&quot;</code>的主要目的就是抑制C++编译器修饰符号名称，比如将 Foo 函数签名修改如下<br><code>extern &quot;C&quot; __declspec(dllexport) int __stdcall Foo(int);</code><br>导出符号变为：</p><table><thead><tr><th align="center">方法</th><th align="center">lib符号名称</th><th align="center">dll导出名称</th></tr></thead><tbody><tr><td align="center">__declspec(dllexport)</td><td align="center">_Foo@4</td><td align="center">_Foo@4</td></tr><tr><td align="center">.def file</td><td align="center">_Foo@4</td><td align="center">Foo</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于 lib 静态库，用 <a href="https://learn.microsoft.com/en-us/cpp/build/exporting-from-a-dll-using-declspec-dllexport">__declspec(dllexport)</a> 导出，用 <a href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport">__declspec(dllimport)</a> 导入。不需要<code>extern &quot;C&quot;</code>。</li><li>对于 dll 动态库，如果需要供非C++程序使用，用<code>.def</code>文件声明导出函数，而不是<code>__declspec(dllexport)</code>。</li><li>在导出 dll 函数时，<code>EXTERN_C</code>虽然不是必须的，但是建议加上，可供C语言调用。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://stackoverflow.com/questions/36785157/how-does-extern-c-allow-c-code-in-a-c-file">how does extern “C” allow C++ code in a C file?</a><br><a href="https://learn.microsoft.com/en-us/cpp/build/importing-and-exporting">Importing and Exporting</a><br><a href="https://learn.microsoft.com/en-us/previous-versions/5x49w699(v=vs.140)">Viewing Decorated Names</a><br><a href="http://demangler.com/">GCC and MSVC C++ Demangler</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delphi 精简版下载</title>
      <link href="/2022/10/22/delphi-lite/"/>
      <url>/2022/10/22/delphi-lite/</url>
      
        <content type="html"><![CDATA[<p>盒子论坛上的一位名为 lsuper 的网友制作的精简版，开箱即用，口碑较好，做了十年以上了。<br>就是下载地址不稳定，所以自己重新整理了下。</p><h2 id="Embarcadero-Delphi-12-1"><a href="#Embarcadero-Delphi-12-1" class="headerlink" title="Embarcadero.Delphi.12.1"></a>Embarcadero.Delphi.12.1</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=686557">https://bbs.2ccc.com/topic.asp?topicid=686557</a></p><p><br>v29.0.51961.7529<br><a href="https://pan.baidu.com/s/1EhbtcRPBRFeds4mPwC3yFA?pwd=ghvt">https://pan.baidu.com/s/1EhbtcRPBRFeds4mPwC3yFA?pwd=ghvt</a></p><h2 id="Embarcadero-Delphi-12-0"><a href="#Embarcadero-Delphi-12-0" class="headerlink" title="Embarcadero.Delphi.12.0"></a>Embarcadero.Delphi.12.0</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=686557">https://bbs.2ccc.com/topic.asp?topicid=686557</a></p><p><br>29.0.51511.6924<br><a href="https://pan.baidu.com/s/15r2gm7K5PBrdzpWDPPPGLg?pwd=uhfn">https://pan.baidu.com/s/15r2gm7K5PBrdzpWDPPPGLg?pwd=uhfn</a></p><h2 id="Embarcadero-Delphi-11"><a href="#Embarcadero-Delphi-11" class="headerlink" title="Embarcadero.Delphi.11"></a>Embarcadero.Delphi.11</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=617617">https://bbs.2ccc.com/topic.asp?topicid=617617</a></p><p><br>v28.0.46141.0937<br><a href="https://pan.baidu.com/s/1Qnw2H4U28nU78q_OYMf2kQ?pwd=3s9f">https://pan.baidu.com/s/1Qnw2H4U28nU78q_OYMf2kQ?pwd&#x3D;3s9f</a></p><h2 id="Embarcadero-Delphi-10-4"><a href="#Embarcadero-Delphi-10-4" class="headerlink" title="Embarcadero.Delphi.10.4"></a>Embarcadero.Delphi.10.4</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=583797">https://bbs.2ccc.com/topic.asp?topicid=583797</a></p><p><br>v27.0.40680.4203<br><a href="http://www.uzzf.com/soft/702155.html">http://www.uzzf.com/soft/702155.html</a><br><a href="https://pan.baidu.com/s/1Dwt4xlPNe0Ni_Dk0Pl5rTA&pwd=mdtt">https://pan.baidu.com/s/1Dwt4xlPNe0Ni_Dk0Pl5rTA&amp;pwd&#x3D;mdtt</a><br><a href="https://mega.nz/folder/MskRTRIT#F0gINnIQe0u_-WX4mfAE4w">https://mega.nz/folder/MskRTRIT#F0gINnIQe0u_-WX4mfAE4w</a></p><h2 id="Embarcadero-Delphi-10-3"><a href="#Embarcadero-Delphi-10-3" class="headerlink" title="Embarcadero.Delphi.10.3"></a>Embarcadero.Delphi.10.3</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=557773">https://bbs.2ccc.com/topic.asp?topicid=557773</a></p><p><br>v26.0.36039.7899<br><a href="http://www.uzzf.com/soft/702164.html">http://www.uzzf.com/soft/702164.html</a><br><a href="https://pan.baidu.com/s/1-Fo61mEZXNtI8cYRnya85Q?pwd=w5a6">https://pan.baidu.com/s/1-Fo61mEZXNtI8cYRnya85Q?pwd=w5a6</a><br><a href="https://mega.nz/folder/FpU1CQzY#t6-FCr3VefU-d-nWJVNyuA">https://mega.nz/folder/FpU1CQzY#t6-FCr3VefU-d-nWJVNyuA</a></p><h2 id="Embarcadero-Delphi-10-2"><a href="#Embarcadero-Delphi-10-2" class="headerlink" title="Embarcadero.Delphi.10.2"></a>Embarcadero.Delphi.10.2</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=530608">https://bbs.2ccc.com/topic.asp?topicid=530608</a></p><p><br>v25.0.31059.3231<br><a href="https://pan.baidu.com/s/1mAb4u9CfRblYzoEsG9RdJw?pwd=hknk">https://pan.baidu.com/s/1mAb4u9CfRblYzoEsG9RdJw?pwd=hknk</a></p><h2 id="Embarcadero-Delphi-10-1"><a href="#Embarcadero-Delphi-10-1" class="headerlink" title="Embarcadero.Delphi.10.1"></a>Embarcadero.Delphi.10.1</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=510849">https://bbs.2ccc.com/topic.asp?topicid=510849</a></p><p><br>v24.0.25048.9432<br><a href="http://www.uzzf.com/soft/702557.html">http://www.uzzf.com/soft/702557.html</a><br><a href="https://mega.nz/#F!h5lCxYjC!u6uw-fCfOzSQgexa9o_NJg">https://mega.nz/#F!h5lCxYjC!u6uw-fCfOzSQgexa9o_NJg</a></p><h2 id="Embarcadero-Delphi-10"><a href="#Embarcadero-Delphi-10" class="headerlink" title="Embarcadero.Delphi.10"></a>Embarcadero.Delphi.10</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=497848">https://bbs.2ccc.com/topic.asp?topicid=497848</a></p><p><br>v23.0.21418.4207<br><a href="http://www.uzzf.com/soft/702550.html">http://www.uzzf.com/soft/702550.html</a><br><a href="https://mega.nz/#F!JsMBiZrY!GaWPIyugbkspcBnLSFmWGA">https://mega.nz/#F!JsMBiZrY!GaWPIyugbkspcBnLSFmWGA</a></p><h2 id="Embarcadero-Delphi-XE8"><a href="#Embarcadero-Delphi-XE8" class="headerlink" title="Embarcadero.Delphi.XE8"></a>Embarcadero.Delphi.XE8</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=476171">https://bbs.2ccc.com/topic.asp?topicid=476171</a></p><p><br>v22.0.19908.869<br><a href="http://www.uzzf.com/soft/702522.html">http://www.uzzf.com/soft/702522.html</a><br><a href="http://pan.baidu.com/share/link?shareid=3476121702&uk=1060104307">http://pan.baidu.com/share/link?shareid=3476121702&uk=1060104307</a><br>密码<code>x37m</code></p><h2 id="Embarcadero-Delphi-XE7"><a href="#Embarcadero-Delphi-XE7" class="headerlink" title="Embarcadero.Delphi.XE7"></a>Embarcadero.Delphi.XE7</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=462987">https://bbs.2ccc.com/topic.asp?topicid=462987</a></p><p><br>v21.0.17707.5020<br><a href="https://pan.baidu.com/s/1hqDvZAO">https://pan.baidu.com/s/1hqDvZAO</a></p><h2 id="Embarcadero-Delphi-XE6"><a href="#Embarcadero-Delphi-XE6" class="headerlink" title="Embarcadero.Delphi.XE6"></a>Embarcadero.Delphi.XE6</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=453225">https://bbs.2ccc.com/topic.asp?topicid=453225</a></p><p><br>v20.0.16277.1276<br><a href="http://www.uzzf.com/soft/702520.html">http://www.uzzf.com/soft/702520.html</a><br><a href="https://pan.baidu.com/s/1pLfXyh9?pwd=bwp8">https://pan.baidu.com/s/1pLfXyh9?pwd=bwp8</a></p><h2 id="Embarcadero-Delphi-XE5"><a href="#Embarcadero-Delphi-XE5" class="headerlink" title="Embarcadero.Delphi.XE5"></a>Embarcadero.Delphi.XE5</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=439320">https://bbs.2ccc.com/topic.asp?topicid=439320</a></p><p><br>v19.0.14356.6604<br><a href="http://ct.kaida.tech/dir/1041485-11089266-f06259">http://ct.kaida.tech/dir/1041485-11089266-f06259</a><br><a href="http://ct.vpan123.com/d/6116009.html">http://ct.vpan123.com/d/6116009.html</a><br><a href="https://sl.yunclass.com:201/Develop/delphi/19.0.14356.6604/">https://sl.yunclass.com:201/Develop/delphi/19.0.14356.6604/</a><br><a href="https://pan.baidu.com/s/1ATHqX07ppJgtzGj7n6AeQg?pwd=zu4l">https://pan.baidu.com/s/1ATHqX07ppJgtzGj7n6AeQg?pwd=zu4l</a><br>解压密码<code>www.delphi6.com</code></p><h2 id="Embarcadero-Delphi-XE4-Update1"><a href="#Embarcadero-Delphi-XE4-Update1" class="headerlink" title="Embarcadero.Delphi.XE4 Update1"></a>Embarcadero.Delphi.XE4 Update1</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=426730">https://bbs.2ccc.com/topic.asp?topicid=426730</a></p><p><br>v18.0.4905.60485<br><a href="http://www.uzzf.com/soft/255554.html">http://www.uzzf.com/soft/255554.html</a></p><h2 id="Embarcadero-Delphi-XE4"><a href="#Embarcadero-Delphi-XE4" class="headerlink" title="Embarcadero.Delphi.XE4"></a>Embarcadero.Delphi.XE4</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=426730">https://bbs.2ccc.com/topic.asp?topicid=426730</a></p><p><br>v18.0.4854.59655<br><a href="https://download.csdn.net/download/aqtata/89326439">https://download.csdn.net/download/aqtata/89326439</a></p><h2 id="Embarcadero-Delphi-XE3"><a href="#Embarcadero-Delphi-XE3" class="headerlink" title="Embarcadero.Delphi.XE3"></a>Embarcadero.Delphi.XE3</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=412296">https://bbs.2ccc.com/topic.asp?topicid=412296</a></p><p><br>v17.0.4770.56661<br><a href="http://www.uzzf.com/soft/255557.html">http://www.uzzf.com/soft/255557.html</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11239699">https://download.csdn.net/download/chunyangsuhao/11239699</a></p><h2 id="Embarcadero-Delphi-XE2"><a href="#Embarcadero-Delphi-XE2" class="headerlink" title="Embarcadero.Delphi.XE2"></a>Embarcadero.Delphi.XE2</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=386433">https://bbs.2ccc.com/topic.asp?topicid=386433</a></p><p><br>v16.0.4504.48759<br><a href="http://www.uzzf.com/soft/255547.html">http://www.uzzf.com/soft/255547.html</a><br><a href="ftp://uploads:uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.XE2.RTM.Inc.Update4.Hotfix1.v16.0.4504.48759.Lite.v5.6.rar">ftp://uploads:uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.XE2.RTM.Inc.Update4.Hotfix1.v16.0.4504.48759.Lite.v5.6.rar</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11250102">https://download.csdn.net/download/chunyangsuhao/11250102</a></p><h2 id="Embarcadero-Delphi-XE"><a href="#Embarcadero-Delphi-XE" class="headerlink" title="Embarcadero.Delphi.XE"></a>Embarcadero.Delphi.XE</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=362365">https://bbs.2ccc.com/topic.asp?topicid=362365</a></p><p><br>v15.0.3953.35171<br><a href="http://www.uzzf.com/soft/27297.html">http://www.uzzf.com/soft/27297.html</a><br><a href="ftp://uploads:uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.XE.RTM.Inc.Update1.v15.0.3953.35171.Lite.v4.3.rar">ftp://uploads:uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.XE.RTM.Inc.Update1.v15.0.3953.35171.Lite.v4.3.rar</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11250004">https://download.csdn.net/download/chunyangsuhao/11250004</a></p><h2 id="CodeGear-Delphi-2010"><a href="#CodeGear-Delphi-2010" class="headerlink" title="CodeGear.Delphi.2010"></a>CodeGear.Delphi.2010</h2><p>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=322619">https://bbs.2ccc.com/topic.asp?topicid=322619</a></p><p><br>v14.0.3615.26342<br><a href="ftp://uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.2010.RTM.v14.0.3615.26342.Lite.v3.8.rar">ftp:&#x2F;&#x2F;uploads@uploads.2ccc.com/lsuper_Embarcadero.Delphi.2010.RTM.v14.0.3615.26342.Lite.v3.8.rar</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11249929">https://download.csdn.net/download/chunyangsuhao/11249929</a></p><h2 id="CodeGear-Delphi-2009"><a href="#CodeGear-Delphi-2009" class="headerlink" title="CodeGear.Delphi.2009"></a>CodeGear.Delphi.2009</h2><p>第一个 Unicode 版本。<br>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=307302">https://bbs.2ccc.com/topic.asp?topicid=307302</a></p><p><br>v12.0.3420.21218<br><a href="ftp://uploads@uploads.2ccc.com/lsuper_CodeGear.Delphi.2009.RTM.Inc.Update4.v12.0.3420.21218.Lite.v2.8.rar">ftp:&#x2F;&#x2F;uploads@uploads.2ccc.com/lsuper_CodeGear.Delphi.2009.RTM.Inc.Update4.v12.0.3420.21218.Lite.v2.8.rar</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11249887">https://download.csdn.net/download/chunyangsuhao/11249887</a></p><h2 id="CodeGear-Delphi-2007"><a href="#CodeGear-Delphi-2007" class="headerlink" title="CodeGear.Delphi.2007"></a>CodeGear.Delphi.2007</h2><p>最后一个 ANSI 版本。<br>原帖：<a href="https://bbs.2ccc.com/topic.asp?topicid=341318">https://bbs.2ccc.com/topic.asp?topicid=341318</a></p><p><br>v11.0.2902.10471<br><a href="ftp://uploads@uploads.2ccc.com/lsuper_CodeGear.Delphi.2007.RTM.Inc.Update4.v11.0.2902.10471.Lite.v1.3.rar">ftp:&#x2F;&#x2F;uploads@uploads.2ccc.com/lsuper_CodeGear.Delphi.2007.RTM.Inc.Update4.v11.0.2902.10471.Lite.v1.3.rar</a><br><a href="https://download.csdn.net/download/chunyangsuhao/11249875">https://download.csdn.net/download/chunyangsuhao/11249875</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Delphi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历对象、数组的一些方法与适用场景</title>
      <link href="/2022/10/12/rFKBYYIi6/"/>
      <url>/2022/10/12/rFKBYYIi6/</url>
      
        <content type="html"><![CDATA[<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1[i]); <span class="comment">// 5, 10, 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎是任何编程语言都有的基本语法，用于遍历数组，中途可通过<code>break</code>中断遍历。</p><h2 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> arr1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的是索引，而不是元素值。它可以用来遍历对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">10</span>, <span class="attr">c</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> arr1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);  <span class="comment">// 5, 10, 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，for…in…适用于遍历对象。</p><h2 id="for…of…"><a href="#for…of…" class="headerlink" title="for…of…"></a>for…of…</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);  <span class="comment">// 5, 10, 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说是<code>for</code>循环的改进版本，不能用于遍历对象，中途可通过<code>break</code>中断遍历。<br>与下面的写法等效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">of</span> arr1.<span class="title function_">values</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);  <span class="comment">// 5, 10, 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只想获取索引，可以遍历<code>keys</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">of</span> arr1.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);  <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想同时得到索引和值，可以遍历<code>entries</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> arr1.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);  <span class="comment">// 0, 1, 2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 5, 10, 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>数组的成员方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">arr1.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`index = <span class="subst">$&#123;index&#125;</span>, value = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>可以拿到元素、索引、数组自身三个值。</li><li>支持向回调函数传递参数<code>this</code>，前提是不要使用箭头函数作为回调。</li><li>不支持中断。</li></ol><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>数组的成员方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// [20, 40, 60]</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>可以拿到元素、索引、数组自身三个值。</li><li>得到一个新数组，不影响原数组。</li><li>不支持中断。</li><li>新数组与原数组长度一致。</li><li>回调函数返回新元素。</li></ol><p><code>map</code>强调的是<strong>处理每一个元素数据并得到一个新数组</strong>。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &lt; <span class="number">25</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// [10, 20]</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>可以拿到元素、索引、数组自身三个值。</li><li>得到一个新数组，不影响原数组。</li><li>不支持中断。</li><li>新数组与原数组长度可能不一致。</li><li>回调函数返回<code>bool</code>类型决定是否将当前元素压入新数组。</li></ol><p><code>filter</code>强调的是<strong>筛选出所有符合条件的数据并得到一个新数组</strong>。</p><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">some</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &lt; <span class="number">25</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与<code>filter</code>类似，但不需要得到新数组，而是只需要知道<strong>数组中是否有任何一条数据满足条件</strong>。</p><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &lt; <span class="number">25</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>与<code>some</code>类似，不需要得到新数组，只是想知道<strong>数组中的每个元素是否都满足条件</strong>。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">find</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="number">10</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30, 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>与<code>some</code>类似，但返回的是<strong>符合条件的第一个元素值</strong>，没有任何元素符合条件则返回<code>undefined</code>。</p><h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="number">10</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30, 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>与<code>find</code>类似，但是返回的是索引，没有任何元素符合条件则返回<code>-1</code>。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">reduce</span>(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30, 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure><p>从数组第一个元素开始，每次循环将数据的处理结果传递到下一次循环，直到处理完每个元素，最终得到一个值。</p><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> tmp = arr1.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10, 20, 30, 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure><p>和<code>reduce</code>一样，不过是从数组末尾开始处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>遍历对象用<code>for...in...</code>。</li><li>遍历数组用<code>for</code>、<code>for...of...</code>、<code>forEach</code>。</li><li>期望对原数组加工处理并得到一个新数组用<code>map</code>。</li><li>期望对原数组进行筛选并得到一个筛选后的新数组，用<code>filter</code>。</li><li>找出数组中满足条件的第一个元素用<code>find</code>、<code>findIndex</code>。对标的是<code>filter</code>，不过仅仅返回一条数据。</li><li>仅需要知道数组中是否有满足条件的元素，而不需要得到元素数据，用<code>some</code>、<code>every</code>。</li><li>需要对数组中每条数据进行处理，并且每次的处理依赖上次的处理结果，用<code>reduce</code>、<code>reduceRight</code>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七麦数据请求参数analisys的算法</title>
      <link href="/2022/10/11/j0xKsEOlM/"/>
      <url>/2022/10/11/j0xKsEOlM/</url>
      
        <content type="html"><![CDATA[<p>七麦数据的APP数据是通过 xhr 动态请求的。为了反爬虫，url 中有一个名为<code>analisys</code>的参数，<br>分析过程可以参考这篇文章（<a href="https://swzhao.blog.csdn.net/article/details/124821311">【python专场】20220806 qimai爬虫请求参数加密analisys解析以及代理使用</a>）。<br>原文中的算法已经失效，不过还好新的算法改动不大。<br>我分析了一下后用 js 写出了解密方法（2022年12月2日测试有效），这样看会比较清晰，其实并不复杂，只是官方的 js 都经过混淆了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setAnalysis</span>(<span class="params">fullUrl</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> secret = <span class="string">&#x27;xyz517cda96abcd&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> diffTime = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>() - <span class="number">1661224081041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(fullUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询参数转字符串</span></span><br><span class="line">    <span class="keyword">const</span> params = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(url.<span class="property">searchParams</span>.<span class="title function_">entries</span>());</span><br><span class="line">    <span class="keyword">let</span> query = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">&#x27;analysis&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        query.<span class="title function_">push</span>(params[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    query = <span class="built_in">decodeURIComponent</span>(query.<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> temp = <span class="string">`<span class="subst">$&#123;btoa(query)&#125;</span>@#<span class="subst">$&#123;url.pathname&#125;</span>@#<span class="subst">$&#123;diffTime&#125;</span>@#3`</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(temp.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> temp) &#123;</span><br><span class="line">        <span class="keyword">const</span> i = <span class="built_in">parseInt</span>(k);</span><br><span class="line">        arr[k] = temp.<span class="title function_">charCodeAt</span>(i) ^ (secret.<span class="title function_">charCodeAt</span>((i + <span class="number">10</span>) % secret.<span class="property">length</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> analysis = <span class="title function_">btoa</span>(<span class="title class_">String</span>.<span class="property">fromCharCode</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">debug</span>(<span class="string">`analysis: <span class="subst">$&#123;temp&#125;</span> &gt; <span class="subst">$&#123;analysis&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    url.<span class="property">searchParams</span>.<span class="title function_">set</span>(<span class="string">&#x27;analysis&#x27;</span>, analysis);</span><br><span class="line">    <span class="keyword">return</span> url.<span class="property">href</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：输入一个完整URL，得到可访问的URL</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://api.qimai.cn/andapp/detail?appid=1&amp;market=1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">setAnalysis</span>(url));</span><br></pre></td></tr></table></figure><h2 id="定位算法"><a href="#定位算法" class="headerlink" title="定位算法"></a>定位算法</h2><p>算法有个固定的时间戳<code>1661224081041</code>，通过它可以定位到算法函数。官方<code>analisys</code>的计算过程如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n;</span><br><span class="line">    f || F != s || (n = (<span class="number">0</span>,</span><br><span class="line">            i[<span class="title class_">Wt</span>])(m),</span><br><span class="line">        s = c[x][k][<span class="title class_">Pt</span>] = -(<span class="number">0</span>,</span><br><span class="line">            i[<span class="title class_">Wt</span>])(l) || +<span class="keyword">new</span> z[W] - a2 * n);</span><br><span class="line">    <span class="keyword">var</span> e, r = +<span class="keyword">new</span> z[W] - (s || H) - <span class="number">1661224081041</span>,</span><br><span class="line">        a = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span> === t[<span class="title class_">Zt</span>] &amp;&amp; (t[<span class="title class_">Zt</span>] = &#123;&#125;),</span><br><span class="line">        z[Z][i7](t[<span class="title class_">Zt</span>])[M](<span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == p)</span><br><span class="line">                <span class="keyword">return</span> !B;</span><br><span class="line">            t[<span class="title class_">Zt</span>][<span class="variable constant_">N2</span>](n) &amp;&amp; a[b](t[<span class="title class_">Zt</span>][n])</span><br><span class="line">        &#125;),</span><br><span class="line">        a = a[<span class="title class_">Ot</span>]()[<span class="variable constant_">I1</span>](_),</span><br><span class="line">        a = (<span class="number">0</span>,</span><br><span class="line">            i[jt])(a),</span><br><span class="line">        a = (a += v + t[<span class="title class_">Jt</span>][T](t[<span class="title class_">Mt</span>], _)) + (v + r) + (v + <span class="number">3</span>),</span><br><span class="line">        e = (<span class="number">0</span>,</span><br><span class="line">            i[jt])((<span class="number">0</span>,</span><br><span class="line">            i[qt])(a, d)),</span><br><span class="line">        -B == t[<span class="title class_">Jt</span>][j](p) &amp;&amp; (t[<span class="title class_">Jt</span>] += (-B != t[<span class="title class_">Jt</span>][j](<span class="title class_">Rn</span>) ? <span class="title class_">Hn</span> : <span class="title class_">Rn</span>) + p + <span class="variable constant_">B1</span> + z[<span class="variable constant_">V1</span>](e)),</span><br><span class="line">        t</span><br><span class="line">&#125; <span class="keyword">catch</span> (t) &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中<code>1661224081041</code>就是时间戳，表示的是北京时间<code>2022-08-23 11:08:01</code>。</p><blockquote><p>如果以后变更算法仍然采用减去时间戳的方式，则可以在浏览器的调试器中按正则搜索”- [0-9]{13}”，这样就很容易定位到算法函数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 七麦数据 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些软件最后支持 XP 的版本</title>
      <link href="/2022/10/09/lIMzoR4Ch/"/>
      <url>/2022/10/09/lIMzoR4Ch/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-Installer"><a href="#Windows-Installer" class="headerlink" title="Windows Installer"></a>Windows Installer</h2><p>因为 Windows XP 自带的版本是<code>3.1</code>，所以有可能无法运行某些高版本的<code>.msi</code>文件，建议升级到<code>v4.5</code>版本。<br><a href="https://download.microsoft.com/download/2/6/1/261fca42-22c0-4f91-9451-0e0f2e08356d/WindowsXP-KB942288-v3-x86.exe">WindowsXP-KB942288-v3-x86.exe</a></p><h2 id="Visual-Assist"><a href="#Visual-Assist" class="headerlink" title="Visual Assist"></a>Visual Assist</h2><p>最高支持到<code>Visual Studio 2017 RC</code><br><a href="https://downloadfiles.idera.com/WholeTomato/VA_X_Setup2118.exe">https://downloadfiles.idera.com/WholeTomato/VA_X_Setup2118.exe</a></p><h2 id="Git-for-Windows"><a href="#Git-for-Windows" class="headerlink" title="Git for Windows"></a>Git for Windows</h2><p><a href="https://github.com/git-for-windows/git/releases/download/v2.10.2.windows.1/Git-2.10.2-32-bit.exe">Git-2.10.2-32-bit.exe</a><br><a href="https://github.com/git-for-windows/git/releases/tag/v2.10.1.windows.1">https://github.com/git-for-windows/git/releases/tag/v2.10.1.windows.1</a></p><h2 id="TortoiseGit"><a href="#TortoiseGit" class="headerlink" title="TortoiseGit"></a>TortoiseGit</h2><p>安装包：<a href="https://download.tortoisegit.org/tgit/1.8.16.0/TortoiseGit-1.8.16.0-32bit.msi">TortoiseGit-1.8.16.0-32bit.msi</a><br>简体中文语言文件：<a href="https://download.tortoisegit.org/tgit/1.8.16.0/TortoiseGit-LanguagePack-1.8.16.0-32bit-zh_CN.msi">TortoiseGit-LanguagePack-1.8.16.0-32bit-zh_CN.msi</a><br><a href="https://download.tortoisegit.org/tgit/1.8.16.0/">https://download.tortoisegit.org/tgit/1.8.16.0/</a></p><h2 id="WinDbg"><a href="#WinDbg" class="headerlink" title="WinDbg"></a>WinDbg</h2><p>最后一个能在 XP 上运行的版本是 6.2.9200.16384。XP 系统上安装需要先升级 Windows Installer 版本。<br><a href="https://download.microsoft.com/download/F/1/3/F1300C9C-A120-4341-90DF-8A52509B23AC/standalonesdk/Installers/X86%20Debuggers%20And%20Tools-x86_en-us.msi">X86 Debuggers And Tools-x86_en-us.msi</a><br><a href="https://download.microsoft.com/download/F/1/3/F1300C9C-A120-4341-90DF-8A52509B23AC/standalonesdk/Installers/X64%20Debuggers%20And%20Tools-x64_en-us.msi">X64 Debuggers And Tools-x64_en-us.msi</a></p><h2 id="Synergy"><a href="#Synergy" class="headerlink" title="Synergy"></a>Synergy</h2><p>在多台电脑之间共享键鼠的软件。<br>激活码：7B76313B70726F3BE5BDAC20E585B33B313B73796E313333323040676D61696C2E636F6D3B3B3B7D<br><a href="https://github.com/amankhoza/synergy-binaries/raw/master/synergy-v1.8.8-stable-Windows-x86.msi">synergy-v1.8.8-stable-Windows-x86.msi</a><br><a href="https://www.brahma.world/synergy-stable-builds/">https://www.brahma.world/synergy-stable-builds/</a><br><a href="https://github.com/amankhoza/synergy-binaries?tab=readme-ov-file#latest-stable-release-v188-stable">https://github.com/amankhoza/synergy-binaries?tab=readme-ov-file#latest-stable-release-v188-stable</a></p><h2 id="TcpView"><a href="#TcpView" class="headerlink" title="TcpView"></a>TcpView</h2><p>网络端口查看工具。v3.05<br><a href="https://www.pc6.com/softview/SoftView_47901.html">https://www.pc6.com/softview/SoftView_47901.html</a><br><a href="https://download.csdn.net/download/lhp121154867/5015730">https://download.csdn.net/download/lhp121154867/5015730</a><br><a href="https://soft.3dmgame.com/down/203592.html">https://soft.3dmgame.com/down/203592.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米手机刷入 Magisk</title>
      <link href="/2022/10/04/eHfAqLKSZ/"/>
      <url>/2022/10/04/eHfAqLKSZ/</url>
      
        <content type="html"><![CDATA[<p>国产手机ROOT真是麻烦，每次要折腾的时候总是碰到这样那样的问题，一弄就是几小时。<br>今天在此记录一下步骤，以后要折腾的话就很节约时间。</p><h2 id="手机解锁"><a href="#手机解锁" class="headerlink" title="手机解锁"></a>手机解锁</h2><p>手机解锁需要向手机厂商申请，小米的解锁申请地址：<a href="http://www.miui.com/unlock/index.html">http://www.miui.com/unlock/index.html</a></p><h2 id="打开USB调试模式"><a href="#打开USB调试模式" class="headerlink" title="打开USB调试模式"></a>打开USB调试模式</h2><p>在<code>设置 &gt; 我的设备 &gt; 全部参数 &gt; MIUI 版本</code>上点击7次即可启用开发者选项，然后打开其中的<code>USB 调试</code>。</p><h2 id="用-USB2-0-或打补丁"><a href="#用-USB2-0-或打补丁" class="headerlink" title="用 USB2.0 或打补丁"></a>用 USB2.0 或打补丁</h2><p>如果电脑用的是<code>USB 2.0</code>可以跳过此步骤。<br>如果是<code>USB 3.0</code>则需要”打补丁”，否则<code>fastboot</code>模式下无法识别手机<br>管理员方式运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\18D1D00D0100&quot; /v &quot;osvc&quot; /t REG_BINARY /d &quot;0000&quot; /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\18D1D00D0100&quot; /v &quot;SkipContainerIdQuery&quot; /t REG_BINARY /d &quot;01000000&quot; /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\18D1D00D0100&quot; /v &quot;SkipBOSDescriptorQuery&quot; /t REG_BINARY /d &quot;01000000&quot; /f</span><br></pre></td></tr></table></figure><h2 id="安装ADB驱动"><a href="#安装ADB驱动" class="headerlink" title="安装ADB驱动"></a>安装ADB驱动</h2><p>我们可以通过<code>MiFlash</code>工具来安装驱动，这个工具是线刷工具，但我们只是为了用它安装驱动而已。<br>下载地址：<a href="https://cdn.alsgp0.fds.api.mi-img.com/micomm/MiFlash2020-3-14-0.rar">MiFlash2020-3-14-0.rar</a><br>点击菜单中的<code>Driver</code>来安装驱动<br><img src="https://pic.rmb.bdstatic.com/bjh/747d6d8b8a80bfcc9aeaf336d183de70.png"></p><h2 id="下载TWRP"><a href="#下载TWRP" class="headerlink" title="下载TWRP"></a>下载TWRP</h2><p>进入TWRP官网设备页面，比如小米的是 <a href="https://twrp.me/Devices/Xiaomi/">Xiaomi</a><br>比如我的 MIX 2S 的页面是<a href="https://twrp.me/xiaomi/xiaomimimix2s.html">https://twrp.me/xiaomi/xiaomimimix2s.html</a><br>找到对应的安装包，目前适合 MIX 2S 最新的是 <a href="https://dl.twrp.me/polaris/twrp-3.6.2_9-0-polaris.img">https://dl.twrp.me/polaris/twrp-3.6.2_9-0-polaris.img</a></p><h2 id="下载-Android-SDK-Platform-Tools-工具"><a href="#下载-Android-SDK-Platform-Tools-工具" class="headerlink" title="下载 Android SDK Platform-Tools 工具"></a>下载 Android SDK Platform-Tools 工具</h2><p>下载地址：<a href="https://developer.android.google.cn/studio/releases/platform-tools.html">https://developer.android.google.cn/studio/releases/platform-tools.html</a></p><h2 id="删除各种锁屏密码"><a href="#删除各种锁屏密码" class="headerlink" title="删除各种锁屏密码"></a>删除各种锁屏密码</h2><p>为了避免后面进入<code>TWRP</code>后文件都是”乱码”，需要在手机上删除锁屏密码、PIN码、指纹。</p><h2 id="进入fastboot模式"><a href="#进入fastboot模式" class="headerlink" title="进入fastboot模式"></a>进入fastboot模式</h2><ol><li>关机。</li><li>同时按住<code>音量键-</code>和<code>电源键</code>直至看到开机画面，大概三秒左右的样子。<br>确保手机与电脑是连接的。<br>或者通过 ADB 执行命令&#96;&#96;adb.exe reboot bootloader&#96;也可以。</li></ol><h2 id="刷入TWRP"><a href="#刷入TWRP" class="headerlink" title="刷入TWRP"></a>刷入TWRP</h2><p>运行命令<code>fastboot.exe flash recovery twrp-3.6.2_9-0-polaris.img</code>，其中文件名换成自己的<br>待CMD窗口显示完成后，按住手机<code>音量+</code>键不放，电脑上输入命令<code>fastboot.exe reboot</code>重启手机。<br>进入 TWRP 后，会询问“是否保持系统分区为只读”，这里滑动按钮以允许修改，否则 MIUI 会用官方 Recovery 的替换掉 TWRP。当然如果不想刷入的话就点击“保持系统分区只读”按钮。</p><h2 id="刷入Magisk"><a href="#刷入Magisk" class="headerlink" title="刷入Magisk"></a>刷入Magisk</h2><p>下载页面：<a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a><br>下载后将文件拷贝至手机SD卡（此时手机可以用MTP模式传输文件），然后通过 TWRP 安装即可。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://onfix.cn/course/3845?bid=1&mid=45">小米（Mi） MIX 3手机刷 TWRP 方法，刷三方Recovery方法（解决卡米问题）</a><br><a href="https://www.uso.cn/post/view/30830">TWRP中无法查看文件夹，显示全是乱码的解决方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> ROOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提取微信小程序资源</title>
      <link href="/2022/10/03/x0kzSFziF/"/>
      <url>/2022/10/03/x0kzSFziF/</url>
      
        <content type="html"><![CDATA[<h2 id="解密小程序"><a href="#解密小程序" class="headerlink" title="解密小程序"></a>解密小程序</h2><p>PC微信的小程序默认存放在<code>%USERPROFILE%\Documents\WeChat Files\Applet</code>文件夹下，每个以<code>wx</code>开头的文件夹对应一个小程序。<br>进去后会发现有若干以<code>.wxapkg</code>结尾的文件，这都是小程序的包，是经过加密的。<br>已经有网友制作了解密工具 <a href="https://www.52pojie.cn/thread-1336730-1-1.html">PC微信小程序包解密工具C#版无需root或模拟器</a>。<br>解密后就会得到一个原始的<code>wxapkg</code>文件。</p><h2 id="wxapkg结构"><a href="#wxapkg结构" class="headerlink" title="wxapkg结构"></a>wxapkg结构</h2><p>类似压缩包的文件，里面存放的是小程序的代码和资源。文件结构也很简单，就是<code>Header + Index + Data</code>。<br><img src="https://pic.rmb.bdstatic.com/bjh/7e82c9067cb2877f032713d70b95a05a.jpeg"><br>我编写了一个 010 Editor 的模板文件来查看文件结构，这样更直观</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">//--- 010 Editor v12.0.1 Binary Template</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      File: </span></span><br><span class="line"><span class="comment">//   Authors: </span></span><br><span class="line"><span class="comment">//   Version: </span></span><br><span class="line"><span class="comment">//   Purpose: </span></span><br><span class="line"><span class="comment">//  Category: WeChat</span></span><br><span class="line"><span class="comment">// File Mask: *.wxapkg</span></span><br><span class="line"><span class="comment">//  ID Bytes: BE, 56 31 4D 4D 57 58</span></span><br><span class="line"><span class="comment">//   History: </span></span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  uchar firstMark &lt;format=hex&gt;;</span><br><span class="line">  uint unknown;</span><br><span class="line">  uint infoListLength;</span><br><span class="line">  uint dataLength;</span><br><span class="line">  uchar lastMark &lt;format=hex&gt;;</span><br><span class="line">  uint fileCount;</span><br><span class="line">&#125; HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  uint length;</span><br><span class="line">  <span class="type">char</span> fileName[length];</span><br><span class="line">&#125; FILE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  FILE_NAME fileName;</span><br><span class="line">  uint offset;</span><br><span class="line">  uint size;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    local int64 pos = FTell();</span><br><span class="line">    FSeek(offset);</span><br><span class="line">    uchar data[size];</span><br><span class="line">    FSeek(pos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; FILE &lt;comment=fileName.fileName&gt;;</span><br><span class="line"></span><br><span class="line">local <span class="built_in">string</span> magic = ReadString(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (magic == <span class="string">&quot;V1MMWX&quot;</span>) &#123;</span><br><span class="line">  Printf(<span class="string">&quot;无法解析加密文件&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigEndian();</span><br><span class="line">HEADER header;</span><br><span class="line"></span><br><span class="line">local <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; header.fileCount; ++i) &#123;</span><br><span class="line">  FILE file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如图<br><img src="https://pic.rmb.bdstatic.com/bjh/9a99ca1ab90160a79bd26c387a7f59c9.png"><br>可以看到，<code>wxapkg</code>也没什么神秘的，就是一个压缩包。<br>提取文件也有很多工具软件可用，见文章尾部。这里我贴一个 python3 版本的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># py2 origin author lrdcq</span></span><br><span class="line"><span class="comment"># usage python3 unwxapkg.py filename</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Integ: https://github.com./integ&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxapkgFile</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    nameLen = <span class="number">0</span></span><br><span class="line">    name = <span class="string">&quot;&quot;</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;usage: unwxapkg.py filename [output_dir]&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    root = os.path.dirname(os.path.realpath(f.name))</span><br><span class="line">    name = os.path.basename(f.name) + <span class="string">&#x27;_dir&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">        name = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#read header</span></span><br><span class="line">    firstMark = struct.unpack(<span class="string">&#x27;B&#x27;</span>, f.read(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;first header mark = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(firstMark))</span><br><span class="line"></span><br><span class="line">    info1 = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;info1 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(info1))</span><br><span class="line"></span><br><span class="line">    indexInfoLength = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;indexInfoLength = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(indexInfoLength))</span><br><span class="line"></span><br><span class="line">    bodyInfoLength = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bodyInfoLength = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(bodyInfoLength))</span><br><span class="line"></span><br><span class="line">    lastMark = struct.unpack(<span class="string">&#x27;B&#x27;</span>, f.read(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;last header mark = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(lastMark))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> firstMark != <span class="number">0xBE</span> <span class="keyword">or</span> lastMark != <span class="number">0xED</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;its not a wxapkg file!!!!!&#x27;</span>)</span><br><span class="line">        f.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    fileCount = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fileCount = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(fileCount))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#read index</span></span><br><span class="line">    fileList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fileCount):</span><br><span class="line">        data = WxapkgFile()</span><br><span class="line">        data.nameLen = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">        data.name = f.read(data.nameLen)</span><br><span class="line">        data.offset = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">        data.size = struct.unpack(<span class="string">&#x27;&gt;L&#x27;</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;readFile = &#123;&#125; at Offset = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(data.name, encoding = <span class="string">&quot;utf-8&quot;</span>), data.offset))</span><br><span class="line"></span><br><span class="line">        fileList.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#save files</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> fileList:</span><br><span class="line">        d.name = <span class="string">&#x27;/&#x27;</span> + name + <span class="built_in">str</span>(d.name, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        path = root + os.path.dirname(d.name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            os.makedirs(path)</span><br><span class="line"></span><br><span class="line">        w = <span class="built_in">open</span>(root + d.name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        f.seek(d.offset)</span><br><span class="line">        w.write(f.read(d.size))</span><br><span class="line">        w.close()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;writeFile = &#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(root, d.name))</span><br><span class="line"></span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>运行命令<code>python unwxapkg.py xxx.wxapkg</code>即可提取文件到磁盘。</p><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p><a href="https://www.52pojie.cn/thread-1336730-1-1.html">PC微信小程序包解密工具C#版无需root或模拟器</a><br><a href="https://github.com/BlackTrace/pc_wxapkg_decrypt">pc_wxapkg_decrypt</a><br><a href="https://github.com/chenrensong/SS.UnWxapkg">SS.UnWxapkg</a></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://lrdcq.com/me/read.php/66.htm">微信小程序源码阅读笔记1</a><br><a href="https://kangzubin.com/wxapp-decompile-1/">微信小程序“反编译”实战（一）：解包</a><br><a href="https://kangzubin.com/wxapp-decompile-2/">微信小程序“反编译”实战（二）：源码还原</a><br><a href="https://www.52pojie.cn/thread-1336342-1-1.html">搜索编程的艺术之C#实现小程序包解密算法</a><br><a href="https://www.1991.site/2020/11/20/%E5%8F%8D%E7%BC%96%E8%AF%91PC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">反编译PC微信小程序</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>010 Editor 模板学习笔记</title>
      <link href="/2022/10/03/ZTcV7OSD9/"/>
      <url>/2022/10/03/ZTcV7OSD9/</url>
      
        <content type="html"><![CDATA[<p>模板是个好东西，可以直观地展现出文件结构，便于分析文件。<br>平时用的不多，但要写的时候又总忘记，所以在此记录一下。</p><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><p>模板文件扩展名为<code>.bt</code>，是一个文本文件，可以自己创建一个<code>.txt</code>文件修改为<code>.bt</code>，或者通过点击菜单<code>Templates &gt; New Template</code>来创建。<br>一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//------------------------------------------------</span><br><span class="line">//--- 010 Editor v12.0.1 Binary Template</span><br><span class="line">//</span><br><span class="line">//      File: </span><br><span class="line">//   Authors: </span><br><span class="line">//   Version: </span><br><span class="line">//   Purpose: </span><br><span class="line">//  Category: WeChat</span><br><span class="line">// File Mask: *.wxapkg</span><br><span class="line">//  ID Bytes: BE, 56 31 4D 4D 57 58</span><br><span class="line">//   History: </span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">int x;</span><br></pre></td></tr></table></figure><p>文件最开始若干行用<code>//</code>注释的元信息，用于描述模板文件及如何匹配魔术数，都是可选的，可以不填写，但是强烈建议填写<code>File Mask</code>和<code>ID Bytes</code>。<br><img src="https://pic.rmb.bdstatic.com/bjh/3007acb10284992050c1cd0466b2929f.png"><br>程序会优先用<code>File Mask</code>匹配文件扩展名，再用<code>ID Bytes</code>匹配魔术数，匹配成功的话就会自动加载模板文件。<br>当然，如果你不需要自动加载模板文件这个功能的话就可以不写，通过菜单手动加载模板。<br>如果文件可能有多种扩展名，就用逗号分隔，比如<code>*.txt,*.xml</code>。<br><code>ID Bytes</code>也是一样，比如<code>ID Bytes: BE, 56 31 4D 4D 57 58</code>。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>模板是从上到下运行的，我们的主要工作就是定义各种数据结构、控制流程等等。<br>因为编写模板和开发C语言程序几乎差不多，所以我只讲一些常见的需要注意的地方。</p><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>默认情况下，所有变量都会显示在模板窗口中。比如我定义了一个<code>int x;</code><br><img src="https://pic.rmb.bdstatic.com/bjh/ee389bdc17421eaccd1a7fd333e52bc0.png"><br>可以通过<code>local</code>关键字定义变量，这样的变量默认不会显示在模板窗口中，不过用户任然可以在窗口中点击右键菜单中的<code>Show Local Variables</code>来显示局部变量。<br><a href="https://www.sweetscape.com/010editor/manual/TemplateVariables.htm#local">Local Variables</a></p><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>默认随系统，比如在 Windows 下是按照小端模式，通过<code>BigEndian</code>和<code>LittleEndian</code>来调整读取方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigEndian();    <span class="comment">// 转换为大端模式</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">LittleEndian(); <span class="comment">// 转换为小端模式</span></span><br></pre></td></tr></table></figure><p>更多内置函数查看官方手册：<a href="https://www.sweetscape.com/010editor/manual/FuncIO.htm">I&#x2F;O Functions</a></p><h3 id="停止执行脚本"><a href="#停止执行脚本" class="headerlink" title="停止执行脚本"></a>停止执行脚本</h3><p>如果在执行过程中发现脚本结构不对时可以提前结束，使用<code>return</code>语句即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local <span class="built_in">string</span> magic = ReadString(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (magic == <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  Printf(<span class="string">&quot;无法解析加密文件&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把整个脚本文件看作是一个C函数，用<code>return</code>就可以提前退出函数。</p><h3 id="结构体构造函数"><a href="#结构体构造函数" class="headerlink" title="结构体构造函数"></a>结构体构造函数</h3><p>这样是合法的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">struct</span> <span class="params">(uint offset)</span> &#123;</span><br><span class="line">  uint x;</span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE <span class="title function_">f</span><span class="params">(<span class="number">123</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体中可以有表达式"><a href="#结构体中可以有表达式" class="headerlink" title="结构体中可以有表达式"></a>结构体中可以有表达式</h3><p>有时候结构体不是固定长度，而是根据字段的值来决定的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  FILE_NAME fileName;</span><br><span class="line">  uint offset;</span><br><span class="line">  uint size;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    local int64 pos = FTell();</span><br><span class="line">    FSeek(offset);</span><br><span class="line">    uchar data[size];</span><br><span class="line">    FSeek(pos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; FILE_INFO &lt;comment=fileName.fileName&gt;;</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://www.sweetscape.com/010editor/manual/IntroTemplates.htm">Writing Templates</a><br><a href="https://www.jianshu.com/p/ba60ebd8f916">010Editor脚本语法入门</a><br><a href="https://bbs.pediy.com/thread-257797.htm">宇宙最强 010 Editor 模板开发教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 010 Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrains全家桶激活方法</title>
      <link href="/2022/09/28/s4m9WKra7/"/>
      <url>/2022/09/28/s4m9WKra7/</url>
      
        <content type="html"><![CDATA[<p>截至到目前，各个IDE最新版本是<code>2022.2</code>，亲测可以激活，比如<code>IDEA</code>。<br><a href="https://download.jetbrains.com/idea/ideaIU-2022.2.2.exe">https://download.jetbrains.com/idea/ideaIU-2022.2.2.exe</a></p><p><img src="https://pic.rmb.bdstatic.com/bjh/035508c0634ef711748af1365b8797bf.png"></p><h2 id="下载-ja-netfilter"><a href="#下载-ja-netfilter" class="headerlink" title="下载 ja-netfilter"></a>下载 ja-netfilter</h2><p>下载地址：<a href="https://gitee.com/ja-netfilter/ja-netfilter/releases">https://gitee.com/ja-netfilter/ja-netfilter/releases</a></p><p>作者对此项目的介绍：<a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">介绍一个”牛逼闪闪”开源库：ja-netfilter</a><br>一句话总结就是它可以根据用户的定义的规则来阻止IDE访问网络等。在这里就是阻止IDE在线验证。</p><h2 id="配置-ja-netfilter"><a href="#配置-ja-netfilter" class="headerlink" title="配置 ja-netfilter"></a>配置 ja-netfilter</h2><p>默认是没有任何规则的，需要自己手动添加。</p><ol><li>编辑<code>ja-netfilter\config\dns.conf</code>，将内容替换为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DNS]</span><br><span class="line">EQUAL,jetbrains.com</span><br></pre></td></tr></table></figure></li><li>编辑<code>ja-netfilter\config\url.conf</code>，将内容替换为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[URL]</span><br><span class="line">PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action</span><br></pre></td></tr></table></figure></li><li>编辑<code>idea.vmoptions</code>文件，在安装目录下<code>C:\Program Files\JetBrains\IntelliJ IDEA 2022.2.2\bin\idea64.exe.vmoptions</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:E:/ja-netfilter/ja-netfilter.jar</span><br><span class="line">--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED</span><br></pre></td></tr></table></figure>将其中<code>-javaagent</code>替换为<code>ja-netfilter.jar</code>的本地路径即可。<br>至此，就阻断了网络验证功能。但我们还需要一个可用的激活码才能离线激活</li></ol><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>下载 <a href="https://wwc.lanzoul.com/i5ffi0e76ypc">IDEAKeyGen</a>，长这样子</p><p><img src="https://pic.rmb.bdstatic.com/bjh/7a6fe404a7458ce54fe5382dd1955085.png"></p><p>点击”生成授权”即可产生两个文件，<code>key.txt</code>和<code>power.conf</code>。<br>将<code>power.conf</code>文件覆盖到<code>ja-netfilter\config\power.conf</code>文件，然后用<code>key.txt</code>文件中的激活码激活软件即可。</p><h2 id="追加注册产品"><a href="#追加注册产品" class="headerlink" title="追加注册产品"></a>追加注册产品</h2><p>KeyGen 中的内容是可以编辑的，主要看<code>products</code>字段，是个数组，每个元素都表示一个产品的注册信息，<code>code</code>表示产品代号，<br>产品代号可以从这个文件中获取：<a href="https://data.services.jetbrains.com/products">https://data.services.jetbrains.com/products</a></p><p>一些主要的产品代码如下：</p><ul><li><code>AC</code>：<a href="https://www.jetbrains.com/objc">AppCode</a></li><li><code>CL</code>：<a href="https://www.jetbrains.com/clion/">CLion</a></li><li><code>DB</code>：<a href="https://www.jetbrains.com/datagrip/">DataGrip</a></li><li><code>DS</code>：<a href="https://www.jetbrains.com/dataspell/">DataSpell</a></li><li><code>FL</code>：<a href="https://www.jetbrains.com/fleet/">Fleet</a></li><li><code>GO</code>：<a href="https://www.jetbrains.com/go/">GoLand</a></li><li><code>II</code>：<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></li><li><code>PC</code>：<a href="https://www.jetbrains.com/pycharm">PyCharm</a></li><li><code>PS</code>：<a href="https://www.jetbrains.com/phpstorm">PhpStorm</a></li><li><code>RD</code>：<a href="https://www.jetbrains.com/rider">Rider</a></li><li><code>RDCPPP</code>：<a href="https://www.jetbrains.com/lp/rider-unreal/">Rider for Unreal Engine</a></li><li><code>RM</code>：<a href="https://www.jetbrains.com/ruby">RubyMine</a></li><li><code>RSU</code>：<a href="https://www.jetbrains.com/dotnet">dotUltimate</a></li><li><code>WS</code>：<a href="https://www.jetbrains.com/webstorm">WebStorm</a></li></ul><h2 id="产品中文页面"><a href="#产品中文页面" class="headerlink" title="产品中文页面"></a>产品中文页面</h2><p><a href="https://www.jetbrains.com/zh-cn/idea/download/">IntelliJ IDEA</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">https://www.jetbrains.com/zh-cn/idea/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/webstorm/download">WebStorm</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/webstorm/download/other.html">https://www.jetbrains.com/zh-cn/webstorm/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/phpstorm/download/">PhpStorm</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/phpstorm/download/other.html">https://www.jetbrains.com/zh-cn/phpstorm/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/ruby/download/">RubyMine</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/ruby/download/other.html">https://www.jetbrains.com/zh-cn/ruby/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/datagrip/download/">DataGrip</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/datagrip/download/other.html">https://www.jetbrains.com/zh-cn/datagrip/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/pycharm/download/">PyCharm Pro</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/pycharm/download/other.html">https://www.jetbrains.com/zh-cn/pycharm/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/rider/download/">Rider</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/rider/download/other.html">https://www.jetbrains.com/zh-cn/rider/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/resharper/download/">ReSharper Ultimate</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/resharper/download/other.html">https://www.jetbrains.com/zh-cn/resharper/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/clion/download/">CLion</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/clion/download/other.html">https://www.jetbrains.com/zh-cn/clion/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/objc/download/">AppCode</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/objc/download/other.html">https://www.jetbrains.com/zh-cn/objc/download/other.html</a></p><p><a href="https://www.jetbrains.com/zh-cn/go/download/">GoLand</a><br>历史版本：<a href="https://www.jetbrains.com/zh-cn/go/download/other.html">https://www.jetbrains.com/zh-cn/go/download/other.html</a></p><h2 id="插件破解"><a href="#插件破解" class="headerlink" title="插件破解"></a>插件破解</h2><p>插件产品因为没有<code>.vmoptions</code>文件，所以不能用激活码激活，需要用破解补丁。<br>Jetbrains Resharper Ultimate 2022.x Patcher (2022&#x2F;06&#x2F;08)<br><a href="https://www.123pan.com/s/A6cA-0FAJh">https://www.123pan.com/s/A6cA-0FAJh</a><br><a href="https://423down.lanzouv.com/ifGnm09e0xvi">https://423down.lanzouv.com/ifGnm09e0xvi</a></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://bbs.pediy.com/thread-271578.htm">ja-netfilter 代理框架</a><br><a href="https://zhuanlan.zhihu.com/p/494706735">分析ja-netfilter如何破解jetbrains的IDE</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC 对话框与加速键</title>
      <link href="/2022/09/16/UnBKyM95J/"/>
      <url>/2022/09/16/UnBKyM95J/</url>
      
        <content type="html"><![CDATA[<p>当在程序中将对话框 (<a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/cdialog-class">CDialog</a>) 当作视图使用后（典型场景如Tab控件，每个页面是一个Dialog），菜单加速键会失效。<br>因为对话框设计之初是作为一个独立窗口而存在的，同时是没有菜单、状态栏的，所以也没有处理加速键(<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translateacceleratorw">TranslateAccelerator</a>)，这是设计原因，并不算是BUG。</p><p>解决思路就是拦截按键消息并直接调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translateacceleratorw">TranslateAccelerator</a></p><h2 id="在对话框中拦截按键消息"><a href="#在对话框中拦截按键消息" class="headerlink" title="在对话框中拦截按键消息"></a>在对话框中拦截按键消息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyDialog::PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pMsg-&gt;message &gt;= WM_KEYFIRST &amp;&amp; pMsg-&gt;message &lt;= WM_KEYLAST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> HACCEL accle = <span class="built_in">GetParentFrame</span>()-&gt;m_hAccelTable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (::<span class="built_in">TranslateAccelerator</span>(<span class="built_in">GetParentFrame</span>()-&gt;<span class="built_in">GetSafeHwnd</span>(), accle, pMsg))</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __super::<span class="built_in">PreTranslateMessage</span>(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个对话框中拦截，缺点就是重复性代码过多。可以的话，写一个基类，在基类中拦截消息，其他 Dialog 从这个基类继承。</p><h2 id="在主线程中拦截按键消息"><a href="#在主线程中拦截按键消息" class="headerlink" title="在主线程中拦截按键消息"></a>在主线程中拦截按键消息</h2><p>重写 <a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/cwinapp-class#processmessagefilter">CWinApp::ProcessMessageFilter</a> 函数，在按键消息到达对话框之前就处理，这样做的好处就是避免了在每个 Dialog 中去处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyApplication::ProcessMessageFilter</span><span class="params">(<span class="type">int</span> code, LPMSG lpMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pMainWnd &amp;&amp; lpMsg-&gt;message &gt;= WM_KEYFIRST &amp;&amp; lpMsg-&gt;message &lt;= WM_KEYLAST) &#123;</span><br><span class="line">        CFrameWnd* frame = (CFrameWnd*)m_pMainWnd;</span><br><span class="line">        <span class="keyword">if</span> (::<span class="built_in">IsChild</span>(frame-&gt;m_hWnd, lpMsg-&gt;hwnd) &amp;&amp; frame-&gt;m_hAccelTable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (::<span class="built_in">TranslateAccelerator</span>(frame-&gt;m_hWnd, frame-&gt;m_hAccelTable, lpMsg))</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __super::<span class="built_in">ProcessMessageFilter</span>(code, lpMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到主窗口会弹出其他对话框，所以我用了 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-ischild">IsChild</a> 函数去判断目标窗口是否为主窗口的后代，这样就能避免”误伤”模态对话框。<br>这段代码也可以放在 <a href="https://learn.microsoft.com/en-us/cpp/mfc/reference/cwnd-class#pretranslatemessage">CWnd::PreTranslateMessage</a> 中，效果是一样的。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://www.codeproject.com/Articles/1619/Keyboard-messages-accelerators-handling-in-MFC-dia">Keyboard messages&#x2F;accelerators handling in MFC dialog based applications</a><br><a href="https://www.cnblogs.com/ice-arrow/p/13724263.html">对话框不响应按键消息</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CStatusBar 禁用自动状态提示</title>
      <link href="/2022/09/14/GY06V2QbH/"/>
      <url>/2022/09/14/GY06V2QbH/</url>
      
        <content type="html"><![CDATA[<p>今天在改一个MFC程序时，在对状态栏设置文本这里耗费了两小时时间，症状是对第一栏设置文本能成功，但是程序不显示。代码大概是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UINT arr[] = &#123;</span><br><span class="line">    ID_SEPARATOR,</span><br><span class="line">    ID_SEPARATOR,</span><br><span class="line">    ID_SEPARATOR</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">SetIndicators</span>(arr, _countof(arr));</span><br><span class="line"><span class="built_in">SetPaneText</span>(<span class="number">0</span>, _T(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure><p>原来问题出在指示器上，一切源于我没有理解<code>ID_SEPARATOR</code>的含义。<br>它的值等于零，用于占位，MFC会用第一个<code>ID_SEPARATOR</code>窗格显示命令提示信息（鼠标停留在菜单、工具栏时状态栏给出的提示）</p><p>MFC在窗口初始化时会用ID为<code>AFX_IDS_IDLEMESSAGE</code>的字符串作为窗格初始内容，正好由于我的程序中未定义<code>AFX_IDS_IDLEMESSAGE</code>，导致MFC将空文本覆盖了我设置的文本。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>只要不用<code>ID_SEPARATOR</code>就行了，但我不想为了不用它就特地去定义一个字符串。<br>可以将ID指定为一个预定义的字符串，比如<code>AFX_IDS_IDLEMESSAGE</code>，但程序要在资源中给出它的定义，否则<code>SetIndicators</code>方法将会返回<code>FALSE</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UINT arr[] = &#123;</span><br><span class="line">    AFX_IDS_IDLEMESSAGE,</span><br><span class="line">    AFX_IDS_IDLEMESSAGE,</span><br><span class="line">    AFX_IDS_IDLEMESSAGE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">SetIndicators</span>(arr, _countof(arr));</span><br><span class="line"><span class="built_in">SetPaneText</span>(<span class="number">0</span>, _T(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure><p>这样就可以愉快地使用<code>SetPaneText</code>了。</p><h2 id="另类的解决方案"><a href="#另类的解决方案" class="headerlink" title="另类的解决方案"></a>另类的解决方案</h2><p>MFC强制将命令提示写到状态栏这个特性，看看源码是怎样实现的<br>在<code>winfrm.cpp</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">CFrameWnd::OnSetMessageString</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT nIDLast = m_nIDLastMessage;</span><br><span class="line">m_nFlags &amp;= ~WF_NOPOPMSG;</span><br><span class="line"></span><br><span class="line">CWnd* pMessageBar = <span class="built_in">GetMessageBar</span>();</span><br><span class="line"><span class="keyword">if</span> (pMessageBar != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LPCTSTR lpsz = <span class="literal">NULL</span>;</span><br><span class="line">CString strMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the message bar text</span></span><br><span class="line"><span class="keyword">if</span> (lParam != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(wParam == <span class="number">0</span>);    <span class="comment">// can&#x27;t have both an ID and a string</span></span><br><span class="line">lpsz = (LPCTSTR)lParam; <span class="comment">// set an explicit string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wParam != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// map SC_CLOSE to PREVIEW_CLOSE when in print preview mode</span></span><br><span class="line"><span class="keyword">if</span> (wParam == AFX_IDS_SCCLOSE &amp;&amp; m_lpfnCloseProc != <span class="literal">NULL</span>)</span><br><span class="line">wParam = AFX_IDS_PREVIEW_CLOSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get message associated with the ID indicated by wParam</span></span><br><span class="line"> <span class="comment">//NT64: Assume IDs are still 32-bit</span></span><br><span class="line"><span class="built_in">GetMessageString</span>((UINT)wParam, strMessage);</span><br><span class="line">lpsz = strMessage;</span><br><span class="line">&#125;</span><br><span class="line">pMessageBar-&gt;<span class="built_in">SetWindowText</span>(lpsz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update owner of the bar in terms of last message selected</span></span><br><span class="line">CFrameWnd* pFrameWnd = pMessageBar-&gt;<span class="built_in">GetParentFrame</span>();</span><br><span class="line"><span class="keyword">if</span> (pFrameWnd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pFrameWnd-&gt;m_nIDLastMessage = (UINT)wParam;</span><br><span class="line">pFrameWnd-&gt;m_nIDTracking = (UINT)wParam;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_nIDLastMessage = (UINT)wParam;    <span class="comment">// new ID (or 0)</span></span><br><span class="line">m_nIDTracking = (UINT)wParam;       <span class="comment">// so F1 on toolbar buttons work</span></span><br><span class="line"><span class="keyword">return</span> nIDLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的就在这一句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pMessageBar-&gt;<span class="built_in">SetWindowText</span>(lpsz);</span><br></pre></td></tr></table></figure><p>实质上就是修改状态栏控件的标题，所以我们要看看<code>CStatusBar</code>是如何处理的，在<code>barstat.cpp</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CStatusBar, CControlBar)</span><br><span class="line">  ...</span><br><span class="line"><span class="built_in">ON_MESSAGE</span>(WM_SETTEXT, &amp;CStatusBar::OnSetText)</span><br><span class="line">  ...</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT <span class="title">CStatusBar::OnSetText</span><span class="params">(WPARAM, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(::<span class="built_in">IsWindow</span>(m_hWnd));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nIndex = <span class="built_in">CommandToIndex</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nIndex &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">SetPaneText</span>(nIndex, (LPCTSTR)lParam) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明朗了，通过调用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cstatusbar-class#commandtoindex">CommandToIndex</a> 获取ID为<code>ID_SEPARATOR</code>的窗格索引，然后设置窗格内容。</p><p>回到最初的问题，我不想将指示器指向一个字符串ID，只想用<code>ID_SEPARATOR</code>占位，但又能用<code>SetPaneText</code>去设置面板文本怎么办？解决办法就是拦截<code>CStatusBar</code>控件的 <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-settext">WM_SETTEXT</a> 消息，屏蔽掉这个特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CStatusBarEx::OnWndMsg</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == WM_SETTEXT)</span><br><span class="line">    &#123;</span><br><span class="line">        *pResult = TRUE;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __super::<span class="built_in">OnWndMsg</span>(message, wParam, lParam, pResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个方法要求子类化<code>CStatusBar</code>或者继承它来拦截消息。其实自动提示这个功能的源头在<code>CFrameWnd::OnSetMessageString</code>，而它是对MFC内部消息 <a href="https://docs.microsoft.com/en-us/cpp/mfc/tn024-mfc-defined-messages-and-resources">WM_SETMESSAGESTRING</a> 的响应，所以我们也可以在 Frame 中拦截<code>WM_SETMESSAGESTRING</code>消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxpriv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MainFrame::OnWndMsg</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == WM_SETMESSAGESTRING)</span><br><span class="line"><span class="keyword">return</span> __super::<span class="built_in">OnWndMsg</span>(message, <span class="number">0</span>, <span class="number">0</span>, pResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> __super::<span class="built_in">OnWndMsg</span>(message, wParam, lParam, pResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个拦截操作将<code>wParam</code>和<code>lParam</code>参数置为0，这将导致传递给<code>SetWindowText</code>的参数是空，就能达到屏蔽状态栏自动提示的特性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash 完全覆盖机场的分组及规则</title>
      <link href="/2022/09/10/rCKN4tc4I/"/>
      <url>/2022/09/10/rCKN4tc4I/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>机场通常会提供一个通用的配置，对于普通的用户来说一般没什么问题，但如果有特别的需求还是需要自己DIY，甚至彻底抛弃机场的配置，完全自主配置。</p><p>一般有以下几种解决方案：<br>1、<a href="https://surgio.js.org/">surgio</a><br>在本机上使用，一个依赖 nodejs 的工具，在本机操作，根据模板生成出规则文件，自己再将规则文件上传至云服务器。需要懂一点 JavaScript 编程，文档还算写的比较详细。</p><p>2、<a href="https://github.com/tindy2013/subconverter">subconverter</a><br>部署在服务器上，通过特定的URL订阅，在服务器上完成转换工作，完全靠配置文件，不需要懂编程，但是文档几乎是三言两语，很多配置细节不清不楚。</p><p>3、<a href="https://docs.cfw.lbyczf.com/contents/parser.html">Parsers</a><br>Clash 自带的配置文件预处理功能，可惜的是它只在本机工作，当你有多个客户端需要设置时就不用考虑这个方案了。</p><p>4、Proxy Providers &amp; Rule Providers<br>Clash 提供了 <a href="https://github.com/Dreamacro/clash/wiki/configuration#proxy-providers">Proxy Providers</a> 和 <a href="https://github.com/Dreamacro/clash/wiki/Clash-Premium-Features#rule-providers">Rule Providers</a> 功能。<br>看名字也能知道，一个提供代理服务器信息，一个提供规则信息。有了它俩就很容易配置自己的规则文件，也是本文采用的方案。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>本文采用 Clash 内置的<code>Proxy Providers</code>和<code>Rule Providers</code>功能来配置，先直接看一个简单的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">silent</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:9090</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Auto</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">use:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysub</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line">  <span class="attr">mysub:</span> <span class="string">--</span> <span class="string">名字随便取，proxy-groups中会用到</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./profiles/mysub.yml</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://xxx.com/clash</span> <span class="string">--</span> <span class="string">机场订阅链接</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="number">600</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rule-providers:</span></span><br><span class="line">  <span class="attr">Custom:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://xxx.com/custom.txt</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/custom.txt</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">Proxy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/proxy.txt</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,Custom,Auto</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,Proxy,Auto</span></span><br></pre></td></tr></table></figure><p>这个配置文件相比原来老的方式，它没有了<code>proxies</code>字段，改由<code>proxy-providers</code>来提供代理服务器信息。</p><h3 id="代理服务器供应者"><a href="#代理服务器供应者" class="headerlink" title="代理服务器供应者"></a>代理服务器供应者</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line">  <span class="attr">mysub:</span>                         <span class="string">--</span> <span class="string">名字随便取，proxy-groups中会用到</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./profiles/mysub.yml</span>   <span class="string">--</span> <span class="string">本地路径</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://xxx.com/clash</span>   <span class="string">--</span> <span class="string">机场订阅链接</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&#x27;HK|港&#x27;</span>              <span class="string">--</span> <span class="string">筛选出香港的节点</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="number">600</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br></pre></td></tr></table></figure><p>此配置文件中定义了一个名为<code>mysub</code>的供应者，字段<code>type</code>表示用<code>http</code>方式获取，<code>url</code>表示机场的订阅地址，<code>filter</code>意味着筛选出名称中带有指定字符的节点。</p><p><code>health-check</code>表示启用自动测速，<code>interval</code>表示测速周期，单位为秒。<code>url</code>表示测速地址。<br>clash 会将机场的配置文件下载至<code>path</code>所指示的位置。</p><h3 id="自己的分组"><a href="#自己的分组" class="headerlink" title="自己的分组"></a>自己的分组</h3><p>这个和以前没什么变化，只是改用<code>use</code>来指定一个供应者</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Auto</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">use:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysub</span></span><br></pre></td></tr></table></figure><p>这里定义了一个名为<code>Auto</code>的分组，<code>type</code>为<code>url-test</code>意味着可以定期测速节点并切换至最快的节点。<code>use</code>指示使用哪个供应者提供的服务器节点，名字要和前面对应上。</p><h3 id="配置规则供应者"><a href="#配置规则供应者" class="headerlink" title="配置规则供应者"></a>配置规则供应者</h3><p><code>rule-providers</code>和<code>proxy-providers</code>的写法非常相似，<code>type</code>、<code>url</code>、<code>path</code>相信你也知道是做什么的了。主要说下<code>behavior</code>，它的值决定了规则文件是采用何种语法解析，一共有3种</p><ul><li>classical<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">payload:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;.blogger.com&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*.*.microsoft.com&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;books.itunes.apple.com&#x27;</span></span><br></pre></td></tr></table></figure></li><li>ipcidr<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">payload:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;192.168.1.0/24&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;10.0.0.0.1/32&#x27;</span></span><br></pre></td></tr></table></figure></li><li>classical<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">payload:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,google.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,google</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,ad.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SRC-IP-CIDR,192.168.1.201/32</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,127.0.0.0/8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GEOIP,CN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DST-PORT,80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SRC-PORT,7777</span></span><br><span class="line">  <span class="comment"># MATCH is not necessary here</span></span><br></pre></td></tr></table></figure>由于规则也外置了，所以不需要像以前那样在配置文件中硬编码规则，比如<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,google.com,Auto</span></span><br></pre></td></tr></table></figure>而应该用<code>RULE-SET</code>指示一个规则供应者<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,Custom,Auto</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,Proxy,Auto</span></span><br></pre></td></tr></table></figure>这里使用了开源的规则列表 <a href="https://github.com/Loyalsoldier/clash-rules">clash-rules</a>。</li></ul><h3 id="部署配置文件"><a href="#部署配置文件" class="headerlink" title="部署配置文件"></a>部署配置文件</h3><p>有服务器的可以放服务器，没有的可以考虑放在 github 这样的托管平台，不过要注意保护隐私，避免配置文件泄漏。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://blog.hifool.cn/posts/f42b65b0/">clash更新订阅时保留自己的规则</a><br><a href="https://www.920.im/clash-rule-providers-configuration/">Clash配置rule-providers实现自由搭配及自动更新规则功能</a><br><a href="https://docs.cfw.lbyczf.com/">Clash for Windows 中文手册</a><br><a href="https://github.com/Loyalsoldier/clash-rules">clash-rules</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展CListCtrl编辑框功能</title>
      <link href="/2022/08/26/16627340/"/>
      <url>/2022/08/26/16627340/</url>
      
        <content type="html"><![CDATA[<p>公共控件 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/list-view-controls-overview">ListView</a> 内置了编辑框功能，但是有个致命的缺陷：只能编辑第一列，第二列后都无法编辑。<br>为了能编辑任意单元格，所以我们需要扩展它。</p><h2 id="编辑框基本用法"><a href="#编辑框基本用法" class="headerlink" title="编辑框基本用法"></a>编辑框基本用法</h2><p>控件窗口添加 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/list-view-window-styles#lvs_editlabels">LVS_EDITLABELS</a> 样式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwStyle = _list.<span class="built_in">GetStyle</span>();</span><br><span class="line">dwStyle |= LVS_EDITLABELS;</span><br><span class="line">_list.<span class="built_in">ModifyStyle</span>(<span class="number">0</span>, LVS_EDITLABELS);</span><br></pre></td></tr></table></figure><p>然后就可以调用其成员方法 <a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/clistctrl-class#editlabel">EditLabel</a> 了。<br>相应的，取消编辑框使用 <a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/clistctrl-class#canceleditlabel">CancelEditLabel</a> 方法。</p><h2 id="ListView-内部处理过程"><a href="#ListView-内部处理过程" class="headerlink" title="ListView 内部处理过程"></a>ListView 内部处理过程</h2><p>当用户调用 <a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/clistctrl-class#editlabel">EditLabel</a> 方法时，本质就是向控件发送一个 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/lvm-editlabel">LVM_EDITLABEL</a> 消息，接着内部就创建一个 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/about-edit-controls">Edit</a> 控件。（向控件发送 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/lvm-geteditcontrol">LVM_GETEDITCONTROL</a> 消息可以获得控件句柄）</p><p>在 <a href="https://docs.microsoft.com/en-us/cpp/mfc/reference/clistctrl-class?editlabel">EditLabel</a> 执行过程中，会向其自身发送一个 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/lvn-beginlabeledit">LVN_BEGINLABELEDIT</a> 消息，预示着编辑框即将显示。<br>当编辑框失去焦点或编辑完成时，ListView 会收到 <a href="https://docs.microsoft.com/en-us/windows/win32/controls/lvn-endlabeledit">LVN_ENDLABELEDIT</a> 消息，表示编辑工作结束。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>网上有两种解决方案，一个是子类化<code>Edit</code>控件，就像这两篇文章中介绍的方法<br><a href="https://www.codeguru.com/cplusplus/editing-listview-subitems-using-lvm_geteditcontrol/">Editing listview subitems using LVM_GETEDITCONTROL</a><br><a href="https://www.codeguru.com/cplusplus/simplified-subitem-editing/">Simplified Subitem Editing</a><br>测试发现有些弊端，比如在 WinCE 系统上没有 <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-windowposchanging">ON_WM_WINDOWPOSCHANGING</a> 消息，得在其他地方改变 Edit 控件的位置。还有一个绘制问题，ListView 内部实现会使第一列内容区无效（表现为空白，可能是为了提高绘图效率），待编辑框结束后才会显示。</p><p>第二种方法就是自己创建一个 Edit 控件，这样就没有第一种方法的一些问题，实现更简单。<br>网上看到的方案都是扩展 ListView 控件，内部在单击或双击时显示 Edit 控件，完全不理会 MFC 提供的 EditLabel 等方法。<br>我稍微变化一下，自己处理几个相关的消息，这样的好处是兼容了 MFC 的接口，对外是透明的。<br>根据前面提到的知识点，源头是从 LVN_BEGINLABELEDIT 消息开始的，所以我们需要”劫持”这个消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CListCtrlEx, CListCtrl)</span><br><span class="line">    <span class="built_in">ON_NOTIFY_REFLECT_EX</span>(LVN_BEGINLABELEDIT, OnBeginLabelEdit)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br></pre></td></tr></table></figure><p>这里要做的就是将 Edit 移动到合适的位置，并填充文本内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CListCtrlEx::OnBeginLabelEdit</span><span class="params">(LPNMHDR pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// NMLVDISPINFO* pItem = reinterpret_cast&lt;NMLVDISPINFO*&gt;(pNMHDR);</span></span><br><span class="line"></span><br><span class="line">    _edit.<span class="built_in">SetWindowText</span>(<span class="built_in">GetItemText</span>(_nCurRow, _nCurCol));</span><br><span class="line">    CRect rc;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetSubItemRect</span>(_nCurRow, _nCurCol, LVIR_LABEL, rc)) &#123;</span><br><span class="line">        _edit.<span class="built_in">MoveWindow</span>(rc);</span><br><span class="line">        _edit.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        _edit.<span class="built_in">SetSel</span>(_edit.<span class="built_in">LineLength</span>());</span><br><span class="line">        _edit.<span class="built_in">SetFocus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键的两句，表示&quot;已处理&quot;该消息，这样就屏蔽了 ListView 控件的默认行为</span></span><br><span class="line">    *pResult = TRUE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着要考虑编辑框按下回车或ESC键时，不要让父窗口关闭了（基于对话框的程序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CEditEx::PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pMsg-&gt;message == WM_KEYDOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pMsg-&gt;wParam == VK_RETURN || pMsg-&gt;wParam == VK_ESCAPE) &#123;</span><br><span class="line">            <span class="built_in">PostMessage</span>(WM_KILLFOCUS);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __super::<span class="built_in">PreTranslateMessage</span>(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CListCtrlEx</code> 还要监视编辑框的退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CListCtrlEx, CListCtrl)</span><br><span class="line">    <span class="built_in">ON_EN_KILLFOCUS</span>(_IDC_EDIT, OnEditKillFocus)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CListCtrlEx::OnEditKillFocus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NMLVDISPINFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    info.hdr.hwndFrom = m_hWnd;</span><br><span class="line">    info.hdr.idFrom = _IDC_EDIT;</span><br><span class="line">    info.hdr.code = LVN_ENDLABELEDIT;</span><br><span class="line">    info.item.iItem = _nCurRow;</span><br><span class="line">    info.item.iSubItem = _nCurCol;</span><br><span class="line">    <span class="built_in">SendMessage</span>(WM_NOTIFY, _IDC_EDIT, <span class="built_in">reinterpret_cast</span>&lt;LPARAM&gt;(&amp;info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 LVN_ENDLABELEDIT 处理过程中将编辑后的内容写回对应的单元格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CListCtrlEx, CListCtrl)</span><br><span class="line">    <span class="built_in">ON_NOTIFY_REFLECT_EX</span>(LVN_ENDLABELEDIT, OnEndLabelEdit)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CListCtrlEx::OnEndLabelEdit</span><span class="params">(LPNMHDR pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _edit.<span class="built_in">ShowWindow</span>(SW_HIDE);</span><br><span class="line">    CString value;</span><br><span class="line">    _edit.<span class="built_in">GetWindowText</span>(value);</span><br><span class="line">    <span class="built_in">SetItemText</span>(_nCurRow, _nCurCol, value);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32 和 WinCE 开发的一些差异</title>
      <link href="/2022/08/23/oJiwcUVws/"/>
      <url>/2022/08/23/oJiwcUVws/</url>
      
        <content type="html"><![CDATA[<h3 id="CWinApp-ProcessMessageFilter"><a href="#CWinApp-ProcessMessageFilter" class="headerlink" title="CWinApp::ProcessMessageFilter"></a>CWinApp::ProcessMessageFilter</h3><p>WinCE 下没有 <a href="https://learn.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#processmessagefilter">CWinApp::ProcessMessageFilter</a> 函数。<br>考虑用 <a href="https://learn.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#pretranslatemessage">CWinApp::PreTranslateMessage</a> 代替。</p><h3 id="链接库文件名不同"><a href="#链接库文件名不同" class="headerlink" title="链接库文件名不同"></a>链接库文件名不同</h3><p>一些Win32函数的链接库文件名会不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32_WCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;toolhelp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="头文件定义缺少一些常量"><a href="#头文件定义缺少一些常量" class="headerlink" title="头文件定义缺少一些常量"></a>头文件定义缺少一些常量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure><p>win32下是有<code>M_PI</code>等数学符号的，wince下则没有，所以需要自己定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> M_PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M_PI  3.1415926535897931</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="没有RegOpenKey"><a href="#没有RegOpenKey" class="headerlink" title="没有RegOpenKey"></a>没有RegOpenKey</h3><p>某些老旧的函数如 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyw">RegOpenKey</a> 是没有的，只有新的版本 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexw">RegOpenKeyEx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows CE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC学习：管理程序配置</title>
      <link href="/2022/05/19/16290668/"/>
      <url>/2022/05/19/16290668/</url>
      
        <content type="html"><![CDATA[<h2 id="CWinApp-的配置管理接口"><a href="#CWinApp-的配置管理接口" class="headerlink" title="CWinApp 的配置管理接口"></a>CWinApp 的配置管理接口</h2><p><code>CWinApp</code>与设置相关的接口有<br><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#writeprofileint">CWinApp::WriteProfileInt</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#writeprofilestring">CWinApp::WriteProfileString</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#writeprofilebinary">CWinApp::WriteProfileBinary</a></p><p>看看<code>WriteProfileInt</code>的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWinApp::WriteProfileInt</span><span class="params">(LPCTSTR lpszSection, LPCTSTR lpszEntry,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(lpszSection != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(lpszEntry != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (m_pszRegistryKey != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">HKEY hSecKey = <span class="built_in">GetSectionKey</span>(lpszSection);</span><br><span class="line"><span class="keyword">if</span> (hSecKey == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">LONG lResult = <span class="built_in">RegSetValueEx</span>(hSecKey, lpszEntry, <span class="literal">NULL</span>, REG_DWORD,</span><br><span class="line">(LPBYTE)&amp;nValue, <span class="built_in">sizeof</span>(nValue));</span><br><span class="line"><span class="built_in">RegCloseKey</span>(hSecKey);</span><br><span class="line"><span class="keyword">return</span> lResult == ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(m_pszProfileName != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">TCHAR szT[<span class="number">16</span>];</span><br><span class="line">_stprintf_s(szT, _countof(szT), _T(<span class="string">&quot;%d&quot;</span>), nValue);</span><br><span class="line"><span class="keyword">return</span> ::<span class="built_in">WritePrivateProfileString</span>(lpszSection, lpszEntry, szT,</span><br><span class="line">m_pszProfileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：</p><ol><li>优先考虑写入到注册表，但如果未设置<code>m_pszRegistryKey</code>值，则会写入到 ini 文件中。</li><li><code>m_pszRegistryKey</code>默认值是<code>nullptr</code>，可以用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinapp-class#setregistrykey">CWinApp::SetRegistryKey</a> 修改它。</li><li><code>m_pszProfileName</code>是在程序启动时初始化的，默认用程序的文件名加上<code>INI</code>后缀。MFC 没有提供函数修改它，但是可以直接对其赋值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CWinApp::SetCurrentHandles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (m_pszProfileName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        Checked::<span class="built_in">tcscat_s</span>(szExeName, _countof(szExeName), _T(<span class="string">&quot;.INI&quot;</span>)); <span class="comment">// will be enough room in buffer</span></span><br><span class="line">        BOOL bEnable = <span class="built_in">AfxEnableMemoryTracking</span>(FALSE);</span><br><span class="line">        m_pszProfileName = _tcsdup(szExeName);</span><br><span class="line">        <span class="built_in">AfxEnableMemoryTracking</span>(bEnable);</span><br><span class="line">        <span class="keyword">if</span>(!m_pszProfileName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AfxThrowMemoryException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果<code>m_pszProfileName</code>仅仅只有文件名，文件会保存到<code>C:\Windows</code>目录下，所以建议用相对路径的形式<code>.\Config.ini</code>，或着绝对路径。</li><li>当使用注册表保存时，<code>m_pszProfileName</code>就变为了<code>Key</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SetRegistryKey</span>(_T(<span class="string">&quot;XX公司&quot;</span>));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">WriteProfileInt</span>(_T(<span class="string">&quot;root&quot;</span>), _T(<span class="string">&quot;entry&quot;</span>), <span class="number">123</span>);</span><br></pre></td></tr></table></figure>如果程序文件名为<code>MyApp.exe</code>，最终写入的注册表位置为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\&#123;m_pszRegistryKey&#125;\&#123;m_pszProfileName&#125;\</span><br></pre></td></tr></table></figure></li></ol><p>INI文件例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">WriteProfileInt</span>(_T(<span class="string">&quot;root&quot;</span>), _T(<span class="string">&quot;item&quot;</span>), <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>ini 内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[root]</span></span><br><span class="line"><span class="attr">item</span>=<span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="CWinAppEx-的配置管理接口"><a href="#CWinAppEx-的配置管理接口" class="headerlink" title="CWinAppEx 的配置管理接口"></a>CWinAppEx 的配置管理接口</h2><p><code>CWinAppEx</code>在<code>CWinApp</code>的基础上，扩充了一些接口，相关函数同样以<code>Write</code>开头，扩展的方法是</p><ul><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writeint">CWinAppEx::WriteInt</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writestring">CWinAppEx::WriteString</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writebinary">CWinAppEx::WriteBinary</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writeobject">CWinAppEx::WriteObject</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writesectionint">CWinAppEx::WriteSectionInt</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writesectionstring">CWinAppEx::WriteSectionString</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writesectionbinary">CWinAppEx::WriteSectionBinary</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#writesectionobject">CWinAppEx::WriteSectionObject</a></li></ul><p>方法中带<code>Section</code>的写入注册表位置是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\&#123;m_pszRegistryKey&#125;\&#123;m_pszProfileName&#125;\&#123;m_strRegSection&#125;\&#123;Section&#125;</span><br></pre></td></tr></table></figure><p>方法中不带<code>Section</code>的写入注册表位置是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\&#123;m_pszRegistryKey&#125;\&#123;m_pszProfileName&#125;\&#123;m_strRegSection&#125;\</span><br></pre></td></tr></table></figure><p>路径中<code>m_strRegSection</code>的默认值是<code>Workspace</code>，可以通过 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwinappex-class#setregistrybase">CWinAppEx::SetRegistryBase</a> 方法修改它。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>CWinApp</code>的方法可选择写入注册表或是INI文件，默认情况下写INI文件。</li><li><code>CWinAppEx</code>提供的方法只能写入注册表，所以必须填充<code>m_pszRegistryKey</code>值。</li></ul><p>对于写注册表来说，<code>m_pszRegistryKey</code>一般填入组织名称，<code>m_pszProfileName</code>填入产品名称，<code>m_strRegSection</code>填入子模块名称。<br><code>CWinApp</code>的以<code>WriteProfile</code>开头的方法虽然可以写注册表，但是因为没有<code>m_strRegSection</code>字段，没法按模块分别写入不同的位置，所以不建议使用，除非你的工程只有一个模块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XP下MFC程序本地化研究</title>
      <link href="/2022/05/18/16286455/"/>
      <url>/2022/05/18/16286455/</url>
      
        <content type="html"><![CDATA[<h2 id="MFC-的本地化方案"><a href="#MFC-的本地化方案" class="headerlink" title="MFC 的本地化方案"></a>MFC 的本地化方案</h2><p>在 MFC 程序中，本地化是通过资源文件来完成的。菜单栏、对话框、字符串，图片等等资源都支持多个语言的副本。<br><img src="https://pic.rmb.bdstatic.com/bjh/42bf226a228cc0b444c82c19daf6a806.png"><br>在框架内部，是通过 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createdialoga">CreateDialog</a>、<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-dialogboxa">DialogBox</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadmenua">LoadMenu</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadstringa">LoadString</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea">FindResource</a> 来查找资源的。比如查找字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> ATLSTRINGRESOURCEIMAGE* <span class="title">AtlGetStringResourceImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT id)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HRSRC hResource;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The and operation (&amp; static_cast&lt;WORD&gt;(~0)) protects the expression from being greater</span></span><br><span class="line"><span class="comment">than WORD - this would cause a runtime error when the application is compiled with /RTCc flag.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">hResource = ::<span class="built_in">FindResourceW</span>(hInstance, <span class="built_in">MAKEINTRESOURCEW</span>( (((id&gt;&gt;<span class="number">4</span>)+<span class="number">1</span>) &amp; <span class="built_in">static_cast</span>&lt;WORD&gt;(~<span class="number">0</span>)) ), (LPWSTR) RT_STRING);</span><br><span class="line"><span class="keyword">if</span>( hResource == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _AtlGetStringResourceImage( hInstance, hResource, id );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数有个特点：<strong>跟根据当前线程语言环境来定位资源</strong>。<br>当一个线程创建时，它使用用户语言环境，该值由 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getuserdefaultlcid">GetUserDefaultLCID</a> 返回。<br>也就是说，在默认情况下资源加载是根据用户的区域设置来的决定。</p><h2 id="改变线程语言环境"><a href="#改变线程语言环境" class="headerlink" title="改变线程语言环境"></a>改变线程语言环境</h2><p>使用 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnls/nf-winnls-setthreadlocale">SetThreadLocale</a> 可以改变当前线程的区域设置，从而改变 MFC 加载资源的语言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将语言环境改为 英语(美国)</span></span><br><span class="line">::<span class="built_in">SetThreadLocale</span>(<span class="built_in">MAKELCID</span>(<span class="built_in">MAKELANGID</span>(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)); </span><br><span class="line"></span><br><span class="line">CString title;</span><br><span class="line">title.<span class="built_in">LoadString</span>(AFX_IDS_APP_TITLE); <span class="comment">// 会尝试加载 英语(美国) 字符资源</span></span><br></pre></td></tr></table></figure><p>但是这个函数有明显的缺点，会影响所有涉及到字符串操作的地方，比如在中文系统上，线程语言改为英文，为用户提供一个通用对话框：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">SetThreadLocale</span>(<span class="built_in">MAKELCID</span>(<span class="built_in">MAKELANGID</span>(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT));</span><br><span class="line">CFileDialog dlg...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果此时用户选了一个带有中文字符的路径，对话框将会得到一些乱码路径，问题还不仅仅只是这里而已。<br><strong>所以不要使用 SetThreadLocale 来修改语言环境，除非你清楚自己在做什么。</strong><br>正确做法应该是自行通过 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> 来查找资源，这个函数不受线程语言影响，可以指定语言，但是也无法再使用 MFC 自带的一些加载资源的方法了。</p><h2 id="线程UI语言"><a href="#线程UI语言" class="headerlink" title="线程UI语言"></a>线程UI语言</h2><p>从 Vista 开始，提出了一个线程UI语言的概念，这解决了上面提到的<code>SetThreadLocale</code>影响全局的问题。通过 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> 或 <a href="https://docs.microsoft.com/zh-CN/windows/win32/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a> 来改变当前线程的UI语言，而它仅仅只影响资源加载时的语言版本，不会影响线程的语言设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LCID loc = ::<span class="built_in">GetThreadLocale</span>();  <span class="comment">// 2052</span></span><br><span class="line">::<span class="built_in">SetThreadUILanguage</span>(<span class="built_in">MAKELANGID</span>(LANG_ENGLISH, SUBLANG_ENGLISH_US));</span><br><span class="line">loc = ::<span class="built_in">GetThreadLocale</span>(); <span class="comment">// 还是 2052</span></span><br></pre></td></tr></table></figure><p>但在 XP 系统下，这个函数会同时设置<code>ThreadLocale</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LCID loc = ::<span class="built_in">GetThreadLocale</span>();  <span class="comment">// 2052</span></span><br><span class="line">::<span class="built_in">SetThreadUILanguage</span>(<span class="built_in">MAKELANGID</span>(LANG_ENGLISH, SUBLANG_ENGLISH_US));</span><br><span class="line">loc = ::<span class="built_in">GetThreadLocale</span>(); <span class="comment">// 1033</span></span><br><span class="line">::<span class="built_in">SetThreadUILanguage</span>(<span class="built_in">MAKELANGID</span>(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED));</span><br><span class="line">loc = ::<span class="built_in">GetThreadLocale</span>(); <span class="comment">// 还是 1033</span></span><br></pre></td></tr></table></figure><p>设置为英语后就改不回来了，很奇怪，抱着好奇的心态用IDA看了一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LANGID __stdcall <span class="title">SetThreadUILanguage</span><span class="params">(LANGID LangId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  UINT ConsoleOutputCP; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  LCID v4; <span class="comment">// esi</span></span><br><span class="line">  LCID v6; <span class="comment">// esi</span></span><br><span class="line">  LCID CurrentLocale; <span class="comment">// [esp+8h] [ebp-3Ch]</span></span><br><span class="line">  UINT v8; <span class="comment">// [esp+Ch] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+10h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+14h] [ebp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+18h] [ebp-2Ch]</span></span><br><span class="line">  LCID Locale; <span class="comment">// [esp+1Ch] [ebp-28h]</span></span><br><span class="line">  WCHAR LCData[<span class="number">16</span>]; <span class="comment">// [esp+20h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOWORD</span>(v1) = <span class="built_in">GetUserDefaultUILanguage</span>();</span><br><span class="line">  v11 = v1;</span><br><span class="line">  CurrentLocale = <span class="built_in">NtCurrentTeb</span>()-&gt;CurrentLocale;</span><br><span class="line">  Locale = <span class="number">1033</span>;</span><br><span class="line">  ConsoleOutputCP = <span class="built_in">GetConsoleOutputCP</span>();</span><br><span class="line">  v8 = ConsoleOutputCP;</span><br><span class="line">  <span class="keyword">if</span> ( dword_7C88593C || (v6 = gSystemLocale) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = dword_7C885938;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">GetLocaleInfoW</span>(gSystemLocale, <span class="number">0x1004</span>u, LCData, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">NlsConvertStringToIntegerW</span>(<span class="number">-1</span>, &amp;dword_7C88593C);</span><br><span class="line">    <span class="built_in">GetLocaleInfoW</span>(v6, <span class="number">0xB</span>u, LCData, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">NlsConvertStringToIntegerW</span>(<span class="number">-1</span>, &amp;dword_7C885940);</span><br><span class="line">    ConsoleOutputCP = v8;</span><br><span class="line">    v3 = v6 &amp; <span class="number">0x3FF</span>;</span><br><span class="line">    dword_7C885938 = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (<span class="type">unsigned</span> __int16)v11;</span><br><span class="line">    <span class="built_in">GetLocaleInfoW</span>((<span class="type">unsigned</span> __int16)v11, <span class="number">0x1004</span>u, LCData, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">NlsConvertStringToIntegerW</span>(<span class="number">-1</span>, &amp;v9);</span><br><span class="line">    <span class="built_in">GetLocaleInfoW</span>(v4, <span class="number">0xB</span>u, LCData, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">NlsConvertStringToIntegerW</span>(<span class="number">-1</span>, &amp;v10);</span><br><span class="line">    v3 = dword_7C885938;</span><br><span class="line">    ConsoleOutputCP = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ConsoleOutputCP</span><br><span class="line">    &amp;&amp; v3 != <span class="number">1</span></span><br><span class="line">    &amp;&amp; v3 != <span class="number">13</span></span><br><span class="line">    &amp;&amp; v3 != <span class="number">42</span></span><br><span class="line">    &amp;&amp; v3 != <span class="number">30</span></span><br><span class="line">    &amp;&amp; (ConsoleOutputCP == dword_7C88593C || ConsoleOutputCP == dword_7C885940)</span><br><span class="line">    &amp;&amp; (ConsoleOutputCP == v9 || ConsoleOutputCP == v10) )</span><br><span class="line">  &#123;</span><br><span class="line">    Locale = (<span class="type">unsigned</span> __int16)v11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( Locale != CurrentLocale &amp;&amp; !<span class="built_in">SetThreadLocale</span>(Locale) )</span><br><span class="line">    <span class="keyword">return</span> CurrentLocale;</span><br><span class="line">  <span class="keyword">return</span> Locale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间一大段不用看，看结尾两行的逻辑：只有在当前线程 LCID 不等于<code>英语(美国)</code>时才会调用<code>SetThreadLocale</code>，这解释了为什么设置为英语后就改不回去了。<br>因为<code>SetThreadUILanguage</code>在 Vista 后有不同的行为，所以也不能完全否定它的作用。</p><h2 id="XP下的多语言解决方案"><a href="#XP下的多语言解决方案" class="headerlink" title="XP下的多语言解决方案"></a>XP下的多语言解决方案</h2><p>因为 XP 系统没有将线程语言和UI语言分离，所以不可以使用<code>SetThreadLocale</code>或<code>SetThreadUILanguage</code>去解决UI多语言问题。<br>有其他两个方案选择：</p><ol><li>为每种语言单独制作一个资源型DLL，在APP初始化前用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/application-information-and-management#afxsetresourcehandle">AfxSetResourceHandle</a> 设置一下，这样之后任何资源加载都会从这个DLL中获取。</li><li>非常规手段，Hook<code>FindResource</code>、<code>LoadMenu</code>等等与资源加载的相关函数，在资源加载前设置语言环境，资源加载后还原语言环境。</li></ol><p>第一种方法属于正规手段，但是很繁琐，维护起来很麻烦。<br>第二种方法可以将所有资源集中在EXE中，维护更方便。不过除了<code>FindResourceEx</code>以外函数无法指定语言ID，所以每次加载资源时需要切换<code>ThreadLocale</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/intl/user-interface-language-management">用户界面语言管理</a><br><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnls/nf-winnls-setthreadlocale">SetThreadLocale function</a><br><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage function</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/build/creating-a-resource-only-dll">创建纯资源 DLL</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/tn057-localization-of-mfc-components">MFC 组件的本地化</a><br><a href="https://blog.csdn.net/m0_37824357/article/details/122001614">MFC基于对话框使用dll进行多语言切换</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 本地化 </tag>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFileDialog 扩展名注意事项</title>
      <link href="/2022/05/17/16282565/"/>
      <url>/2022/05/17/16282565/</url>
      
        <content type="html"><![CDATA[<p>在 MFC 中，<code>打开</code>和<code>保存</code>对话框都是用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cfiledialog-class">CFileDialog</a> 来实现的，构造函数的第一个参数决定了是”打开”还是”保存”。</p><h2 id="打开对话框"><a href="#打开对话框" class="headerlink" title="打开对话框"></a>打开对话框</h2><p>一个简单的对话框如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, _T(<span class="string">&quot;ALL|*.*||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对话框有两个问题：</p><ol><li>用户如果未输入扩展名，<code>ext</code>将为空。</li><li>允许用户输入不存在的文件名。</li></ol><h3 id="解决问题一"><a href="#解决问题一" class="headerlink" title="解决问题一"></a>解决问题一</h3><p>可以将第二个参数为默认的扩展名，当用户没有输入扩展名的时候，会自动附加默认扩展名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, _T(<span class="string">&quot;txt&quot;</span>), <span class="literal">nullptr</span>, <span class="number">0</span>, _T(<span class="string">&quot;ALL|*.*||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入<code>123</code>，会得到文件名<code>123.txt</code>。</p><ul><li>过滤器优先于默认扩展名。如果用户未输入文件名，但是选择了有效的过滤器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, _T(<span class="string">&quot;ini&quot;</span>), <span class="literal">nullptr</span>, <span class="number">0</span>, _T(<span class="string">&quot;ALL|*.*|TXT|*.txt||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果用户选择了<code>txt</code>过滤器，但是输入<code>123</code>作为文件名，将会得到<code>123.txt</code>，而不是<code>123.ini</code>。</li><li>如果过滤器有多个扩展名，则采用第一个：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, _T(<span class="string">&quot;ini&quot;</span>), <span class="literal">nullptr</span>, <span class="number">0</span>, _T(<span class="string">&quot;ALL|*.*|TXT|*.txt;*.doc||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输入了<code>123</code>作为文件名，得到<code>123.txt</code>。</li><li>当默认扩展名为<code>nullptr</code>时，即使选择了过滤器也不会追加扩展名。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, _T(<span class="string">&quot;ALL|*.*|TXT|*.txt||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>选择过滤器<code>txt</code>，输入<code>123</code>作为文件名将会得到<code>123</code>文件名，而不是<code>123.txt</code>。</li></ul><h3 id="解决问题二"><a href="#解决问题二" class="headerlink" title="解决问题二"></a>解决问题二</h3><p>可以在第四个参数上指定<code>OFN_FILEMUSTEXIST</code>，意味着必须输入一个存在的文件名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(TRUE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, OFN_FILEMUSTEXIST, _T(<span class="string">&quot;ALL|*.*||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入<code>123</code>且文件不存在就会出现警告，这样可以保证<code>DoModal</code>返回时文件名必然有效。<br><img src="https://pic.rmb.bdstatic.com/bjh/45c55e9fea121b211b903ed96a6f6c88.png"></p><h2 id="保存对话框"><a href="#保存对话框" class="headerlink" title="保存对话框"></a>保存对话框</h2><ul><li>当默认扩展名为<code>nullptr</code>时，即使选择了过滤器也不会追加扩展名。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(FALSE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, OFN_OVERWRITEPROMPT, _T(<span class="string">&quot;TXT|*.txt||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();  <span class="comment">// &quot;&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>(); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输入<code>123</code>得到<code>123</code>。</li><li>以用户输入的扩展名为准。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">dlg</span><span class="params">(FALSE, _T(<span class="string">&quot;&quot;</span>), <span class="literal">nullptr</span>, OFN_OVERWRITEPROMPT, _T(<span class="string">&quot;TXT|*.txt||&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">DoModal</span>() == IDOK) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ext = dlg.<span class="built_in">GetFileExt</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> fileName = dlg.<span class="built_in">GetFileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输入<code>123.doc</code>得到<code>123.doc</code>，而不是<code>123.txt</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果用户输入了扩展名，则以用户输入为最终值。</li><li>如果用户未输入扩展名，且设置了默认扩展名，就先采用过滤器中的扩展名，只有用户选择通配符<code>*.*</code>时才采用默认扩展名。</li><li>默认扩展名为<code>nullptr</code>时，在任何情况下都不会自动追加扩展名。</li></ol><h3 id="对于打开对话框"><a href="#对于打开对话框" class="headerlink" title="对于打开对话框"></a>对于打开对话框</h3><p>相信没有人会愿意打开不存在的文件，那么<code>OFN_FILEMUSTEXIST</code>几乎是必选项，而这正好也确保了文件名是正确的，所以默认扩展名可有可无。</p><h3 id="对于保存对话框"><a href="#对于保存对话框" class="headerlink" title="对于保存对话框"></a>对于保存对话框</h3><p>建议总是设置一个默认扩展名。如果默认扩展名为<code>nullptr</code>，即使选择了有效的过滤器，对话框则也不会追加扩展名，用户必须手动输入才行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cfiledialog-class">CFileDialog 类</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dear ImGui游戏窗口双光标问题</title>
      <link href="/2022/05/15/16273544/"/>
      <url>/2022/05/15/16273544/</url>
      
        <content type="html"><![CDATA[<h2 id="双光标问题"><a href="#双光标问题" class="headerlink" title="双光标问题"></a>双光标问题</h2><p>向游戏窗口注入 ImGui 窗口后，默认情况下就会出现双光标。<br><img src="https://pic.rmb.bdstatic.com/bjh/be508fcee683d16f23191aae290ab444.png"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>更新光标的地方在<code>imgui_impl_win32.cpp</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ImGui_ImplWin32_UpdateMouseCursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    <span class="keyword">if</span> (io.ConfigFlags &amp; ImGuiConfigFlags_NoMouseCursorChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ImGuiMouseCursor imgui_cursor = ImGui::<span class="built_in">GetMouseCursor</span>();</span><br><span class="line">    <span class="keyword">if</span> (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Hide OS mouse cursor if imgui is drawing it or if it wants no cursor</span></span><br><span class="line">        ::<span class="built_in">SetCursor</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Show OS mouse cursor</span></span><br><span class="line">        LPTSTR win32_cursor = IDC_ARROW;</span><br><span class="line">        <span class="keyword">switch</span> (imgui_cursor)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ::<span class="built_in">SetCursor</span>(::<span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, win32_cursor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码能看出，如果不希望出现光标，也就是执行<code>::SetCursor(::LoadCursor(NULL, win32_cursor))</code>这句，那么有两个地方可以修改</p><ol><li>为<code>ConfigFlags</code>加上<code>ImGuiConfigFlags_NoMouseCursorChange</code>参数，函数将完全失效。</li><li><code>io.MouseDrawCursor</code>这个值为<code>true</code>时（默认值为false）。</li></ol><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在创建 ImGui 时为<code>ConfigFlags</code>加上<code>ImGuiConfigFlags_NoMouseCursorChange</code>参数，使<code>ImGui_ImplWin32_UpdateMouseCursor</code>函数彻底失效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;</span><br></pre></td></tr></table></figure><p>接着在窗口消息处理过程中，自行决定是否渲染光标，所以需要处理<code>WM_SETCURSOR</code>消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImGui_ImplWin32_WndProcHandler</span>(hWnd, uMsg, wParam, lParam)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uMsg == WM_SETCURSOR) &#123;</span><br><span class="line">        <span class="comment">// 如果鼠标在 ImGui 窗口内就渲染一个箭头光标</span></span><br><span class="line">        ::<span class="built_in">SetCursor</span>(io.WantCaptureMouse ? ::<span class="built_in">LoadCursorW</span>(<span class="literal">nullptr</span>, IDC_ARROW) : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">CallWindowProcW</span>(_oldWndProc, hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有瑕疵<br><img src="https://pic.rmb.bdstatic.com/bjh/fc92731aba2ea18dda92dbc4356408bb.png"><br>当光标在输入框，窗口边框等情况下，它任然会显示箭头，所以还需要对每种情况进行处理，这使得工作变得复杂。<br>查看源码发现，ImGui 会在<code>ImGui_ImplWin32_WndProcHandler</code>中调用<code>ImGui_ImplWin32_UpdateMouseCursor</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMGUI_IMPL_API LRESULT <span class="title">ImGui_ImplWin32_WndProcHandler</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> WM_SETCURSOR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LOWORD</span>(lParam) == HTCLIENT &amp;&amp; <span class="built_in">ImGui_ImplWin32_UpdateMouseCursor</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以也可以换个思路，去掉<code>ImGuiConfigFlags_NoMouseCursorChange</code>设置，并在消息中拦截处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LOWORD</span>(lParam) == HTCLIENT &amp;&amp; uMsg == WM_SETCURSOR) &#123;</span><br><span class="line">        <span class="comment">// 鼠标不在外挂窗口内时不要渲染光标</span></span><br><span class="line">        <span class="keyword">if</span> (!io.WantCaptureMouse) &#123;</span><br><span class="line">            ::<span class="built_in">SetCursor</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外挂窗口隐藏时就返回，不要交给 ImGui 处理，否则会出现箭头光标</span></span><br><span class="line">        <span class="keyword">if</span> (!_show) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImGui_ImplWin32_WndProcHandler</span>(hWnd, uMsg, wParam, lParam)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">CallWindowProcW</span>(_oldWndProc, hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没完，通常外挂窗口可以通过快捷键隐藏，当通过快捷键隐藏窗口时也要处理光标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uMsg == WM_KEYUP) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wParam == VK_F4) &#123;</span><br><span class="line">        _show = !_show;</span><br><span class="line">        ::<span class="built_in">SetCursor</span>(_show ? ::<span class="built_in">LoadCursorW</span>(<span class="literal">nullptr</span>, IDC_ARROW) : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>从<code>ImGui_ImplWin32_UpdateMouseCursor</code>的逻辑看，当<code>io.MouseDrawCursor</code>为<code>true</code>时，ImGui 就不会使用系统光标，而是自行绘制光标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange; <span class="comment">// 屏蔽系统光标</span></span><br><span class="line">io.MouseDrawCursor = <span class="literal">true</span>;  <span class="comment">// ImGui 自行绘制</span></span><br></pre></td></tr></table></figure><p>此时就需要在每一帧创建后指定光标类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"><span class="keyword">if</span> (!io.WantCaptureMouse)</span><br><span class="line">    ImGui::<span class="built_in">SetMouseCursor</span>(ImGuiMouseCursor_None);</span><br></pre></td></tr></table></figure><p>工作一切正常，很完美，实现起来比方式一更简单。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ocornut/imgui/issues/2479">SDL2 hide cursor</a><br><a href="https://www.unknowncheats.me/forum/counterstrike-global-offensive/295275-panorama-cursor-fix-imgui.html">Panorama cursor fix (imgui)</a><br><a href="https://www.unknowncheats.me/forum/direct3d/190472-imgui-mouse-cursor.html">ImGUI mouse cursor problem</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Dear ImGui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comctl32公共控件</title>
      <link href="/2022/05/10/16251848/"/>
      <url>/2022/05/10/16251848/</url>
      
        <content type="html"><![CDATA[<h2 id="Comctl32-是什么？"><a href="#Comctl32-是什么？" class="headerlink" title="Comctl32 是什么？"></a>Comctl32 是什么？</h2><p><code>Comctl</code>的全称是<code>Common Controls</code>，也就是公共控件的意思，属于Windows系统的一部分，提供了一组标准的UI控件，如<code>Button</code>、<code>ListView</code>等等。<br>微软工具 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=4635">Control Spy</a> 用于查看所有公共控件。<br><img src="https://pic.rmb.bdstatic.com/bjh/b9b960fa5c60a68914f6d648f6670337.png"></p><h2 id="Comctl32-版本"><a href="#Comctl32-版本" class="headerlink" title="Comctl32 版本"></a>Comctl32 版本</h2><h3 id="v5和v6的区别"><a href="#v5和v6的区别" class="headerlink" title="v5和v6的区别"></a>v5和v6的区别</h3><p>主要有两个大版本，<code>v5</code>和<code>v6</code>，最明显的两个区别：</p><ol><li>外观，一个是古老的<code>Windows 98</code>风格，一个是跟随系统的风格。<br><code>5.X</code>的控件样式，是固定的样式。<br><img src="https://pic.rmb.bdstatic.com/bjh/2af67dda865e6188452bb5ed4fb16705.png"><br><code>6.X</code>的控件样式，会随着系统主题变化。<br><img src="https://pic.rmb.bdstatic.com/bjh/838afc5f0b2d9af9e5c54abb5b8535e1.png"></li><li>兼容性，<code>6.0</code>以后的某些控件对<code>多字节字符集</code>的应用存在兼容性问题。</li></ol><h3 id="获取正在使用的-Comctl32-版本号"><a href="#获取正在使用的-Comctl32-版本号" class="headerlink" title="获取正在使用的 Comctl32 版本号"></a>获取正在使用的 Comctl32 版本号</h3><p>Comctl32.dll有一个导出函数<code>DllGetVersion</code>可以获取当前版本号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetVersion</span><span class="params">(HMODULE h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwVersion = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> pDllGetVersion = <span class="built_in">reinterpret_cast</span>&lt;DLLGETVERSIONPROC&gt;(<span class="built_in">GetProcAddress</span>(h, <span class="string">&quot;DllGetVersion&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (pDllGetVersion) &#123;</span><br><span class="line">        DLLVERSIONINFO dvi&#123;&#125;;</span><br><span class="line">        dvi.cbSize = <span class="built_in">sizeof</span>(dvi);</span><br><span class="line">        HRESULT hr = (*pDllGetVersion)(&amp;dvi);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">            dwVersion = <span class="built_in">MAKELONG</span>(dvi.dwMajorVersion, dvi.dwMinorVersion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwVer = <span class="built_in">GetVersion</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ComCtl32.dll&quot;</span>));</span><br></pre></td></tr></table></figure><p>在<code>Windows XP SP3</code>上得到的值是<code>0x00050052</code>，意味版本号是<code>5.82</code><br><img src="https://pic.rmb.bdstatic.com/bjh/66f87196c66a7afba2f4242f4e0c4639.png"></p><h3 id="链接指定的-Comctl32-版本"><a href="#链接指定的-Comctl32-版本" class="headerlink" title="链接指定的 Comctl32 版本"></a>链接指定的 Comctl32 版本</h3><p>在新建一个 MFC 工程时，默认会生成这样一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _M_IX86</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/manifestdependency:\&quot;type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;x86&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _M_X64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/manifestdependency:\&quot;type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;amd64&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/manifestdependency:\&quot;type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>通过编译器指令添加了清单文件以支持链接到指定的 Comctl32 版本。注意这里判断了程序使用 Unicode 字符集时才会生效，原因上面说过了，因为<code>v6</code>对<code>多字节字符集</code>存在兼容性问题，所以不建议使用，<code>多字节字符集</code>的程序最好用<code>v5</code>，不过这意味着程序无法使用现代的UI。</p><p>当程序指定链接到<code>v6</code>或更高版本后，还需要在程序内定义一个宏<code>_WIN32_IE</code>，如果没有定义它，编译时会将这个值设置为<code>0x500</code>，这将影响程序正在使用的与控件有关的结构体大小。<br>试想一下，如果程序链接到<code>v6</code>版的 Comctl32，但因为没有定义<code>_WIN32_IE</code>宏而使用了较旧的SDK，这可能会引起程序异常。<br><code>_WIN32_IE</code>所有支持的值看这里：<a href="https://docs.microsoft.com/en-us/windows/win32/controls/common-control-versions#project-versions">https://docs.microsoft.com/en-us/windows/win32/controls/common-control-versions#project-versions</a></p><p><code>Windows XP SP3</code>已经自带了<code>v6</code>版，所以我们可以放心的将程序链接到<code>v6</code>版本。<br><img src="https://pic.rmb.bdstatic.com/bjh/8c28fd17f2310383ce6466ae69f666ec.png"></p><h2 id="InitCommonControlsEx"><a href="#InitCommonControlsEx" class="headerlink" title="InitCommonControlsEx"></a>InitCommonControlsEx</h2><p>在新建一个 MFC 工程时，初始化的第一行代码就是对公共控件初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">InitCtrls.dwSize = <span class="built_in">sizeof</span>(InitCtrls);</span><br><span class="line">InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line"><span class="built_in">InitCommonControlsEx</span>(&amp;InitCtrls);</span><br></pre></td></tr></table></figure><p>但在今天，初始化行为并不是必须的，因为在首次创建控件时，Comctl32 内部会自动注册相关控件类，历史原因可以看文章末尾的链接。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/controls/common-controls-intro">关于公共控件</a><br><a href="https://www.geoffchappell.com/studies/windows/shell/comctl32/api/commctrl/initcommoncontrolsex.htm">InitCommonControlsEx</a><br><a href="https://stackoverflow.com/questions/20078118/is-common-control-6-supported-in-mbcs-applications">Is common control 6 supported in MBCS applications?</a><br><a href="https://stackoverflow.com/questions/60790673/cedit-works-in-comctrl32-version-5-82-but-not-with-6-10">CEdit works in ComCtrl32 Version 5.82 but not with 6.10</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dear ImGui学习：组件ID</title>
      <link href="/2022/05/08/16246612/"/>
      <url>/2022/05/08/16246612/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn1 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn2 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击第二个按钮是没有效果的，谷歌了一番后找到了原因，因为 Dear ImGui 有一个栈机制。<br>在内部 Dear ImGui 需要靠唯一的ID来追踪组件，而 Dear ImGui 默认将组件的<code>Label</code>参数当作是唯一ID，所以当有相同的<code>Label</code>时就产生了冲突。</p><p>在 Demo 中有个 Stack Tool 可以直观地查看栈情况。<br><img src="https://pic.rmb.bdstatic.com/bjh/22a617af8ac5edbe7194e4a5ca8f6844.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：用-来标记唯一ID"><a href="#方法一：用-来标记唯一ID" class="headerlink" title="方法一：用##来标记唯一ID"></a>方法一：用<code>##</code>来标记唯一ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1##id1&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn1 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1##id2&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn2 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>##</code>后面的字符串不会显示在组件上，这样就保证了栈里的ID是唯一的。</p><h3 id="方法二：使用-PushID-PopID-方法"><a href="#方法二：使用-PushID-PopID-方法" class="headerlink" title="方法二：使用 PushID&#x2F;PopID 方法"></a>方法二：使用 PushID&#x2F;PopID 方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">PushID</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn1 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::<span class="built_in">PopID</span>();</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">PushID</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Test1&quot;</span>)) &#123;</span><br><span class="line">    ::<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Btn2 clicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::<span class="built_in">PopID</span>();</span><br></pre></td></tr></table></figure><p><code>PushID</code>和<code>PopID</code>成对使用，参数可以是数字，也可以是字符串，要保证唯一性。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>只有可交互式的组件才需要ID，比如<code>Button</code>、<code>Input</code>等等。</li><li>不同窗口之间的相同ID不会冲突。</li><li>如果需要一个空<code>Label</code>就必须设置一个ID。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Button</span>(<span class="string">&quot;##id&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>使用<code>###</code>来禁止将<code>Label</code>部分纳入为ID。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;My game (%f FPS)###MyGame&quot;</span>, fps);</span><br><span class="line"><span class="built_in">Begin</span>(buf);</span><br></pre></td></tr></table></figure>这样在栈里的实际ID是”MyGame”，而不是整个字符串。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ocornut/imgui/issues/74">Buttons with identical labels do not work</a><br><a href="https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system">About the ID Stack system</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Dear ImGui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC学习：设置窗口标题</title>
      <link href="/2022/05/07/16244353/"/>
      <url>/2022/05/07/16244353/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，MFC的主窗口标题由<strong>文档标题和Frame标题组成</strong>，格式为：<code>file - frame</code>。</p><h2 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h2><p>设置窗口标题用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cwnd-class#setwindowtext">CWnd::SetWindowText</a> 方法。</p><h2 id="设置文档标题"><a href="#设置文档标题" class="headerlink" title="设置文档标题"></a>设置文档标题</h2><p>新建一个文档时，MFC 会使用字符串资源<code>AFX_IDS_UNTITLED</code>作为文档的默认标题，接着会触发 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdocument-class#onnewdocument">CDocument::OnNewDocument</a> 方法，我们可以在文件新建成功后使用 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdocument-class#settitle">CDocument::SetTitle</a> 方法来设置标题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCApplication2Doc::OnNewDocument</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CDocument::<span class="built_in">OnNewDocument</span>())</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">SetTitle</span>(_T(<span class="string">&quot;新文件&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是<code>打开文档</code>就不能在 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdocument-class#onopendocument">CDocument::OnOpenDocument</a> 中处理，因为 MFC 在打开文档后会使用文件名作为标题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TCHAR szTitle[_MAX_FNAME];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">AfxGetFileTitle</span>(szFullPath, szTitle, _MAX_FNAME) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">SetTitle</span>(szTitle);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最早的修改时机是在 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdocument-class#setpathname">CDocument::SetPathName</a> 中，我们可以重载它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPathName</span><span class="params">(LPCTSTR lpszPathName, BOOL bAddToMRU)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDocument::<span class="built_in">SetPathName</span>(lpszPathName, bAddToMRU);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">SetTitle</span>(_T(<span class="string">&quot;new title&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是更建议在 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdocument-class#ondocumentevent">CDocument::OnDocumentEvent</a> 中处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDocumentEvent</span><span class="params">(DocumentEvent deEvent)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deEvent == onAfterNewDocument || deEvent == onAfterOpenDocument) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">SetTitle</span>(_T(<span class="string">&quot;new title&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="固定窗口标题"><a href="#固定窗口标题" class="headerlink" title="固定窗口标题"></a>固定窗口标题</h2><p>我们有时候希望应用程序标题是固定的，不会随着文档变化，可以通过以下几种方式来做。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>因为文档在设置标题后会触发 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cframewndex-class#onupdateframetitle">CFrameWndEx::OnUpdateFrameTitle</a> 方法，而这个方法会改变窗口标题，所以我们覆盖它即可避免被影响。<br>在 <a href="CFrameWndEx::OnCreate">CFrameWndEx::OnCreate</a> 中设置固定标题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;title&quot;</span>));</span><br></pre></td></tr></table></figure><p>重载 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cframewndex-class#onupdateframetitle">CFrameWndEx::OnUpdateFrameTitle</a> 方法，不调用父类操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMainFrame::OnUpdateFrameTitle</span><span class="params">(BOOL bAddToTitle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>跟进<code>OnUpdateFrameTitle</code>后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFrameWnd::OnUpdateFrameTitle</span><span class="params">(BOOL bAddToTitle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">GetStyle</span>() &amp; FWS_ADDTOTITLE) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// leave it alone!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow hook to set the title (used for OLE support)</span></span><br><span class="line">    <span class="keyword">if</span> (m_pNotifyHook != <span class="literal">NULL</span> &amp;&amp; m_pNotifyHook-&gt;<span class="built_in">OnUpdateFrameTitle</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    CDocument* pDocument = <span class="built_in">GetActiveDocument</span>();</span><br><span class="line">    <span class="keyword">if</span> (bAddToTitle &amp;&amp; pDocument != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">UpdateFrameTitleForDocument</span>(pDocument-&gt;<span class="built_in">GetTitle</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">UpdateFrameTitleForDocument</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发现了一个新东西<code>FWS_ADDTOTITLE</code>，如果窗口样式不包含它的话就退出函数了，所以我们也可以在创建<code>Frame</code>时去除这个Flag</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMainFrame::PreCreateWindow</span><span class="params">(CREATESTRUCT&amp; cs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CFrameWndEx::<span class="built_in">PreCreateWindow</span>(cs))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    cs.style &amp;= ~FWS_ADDTOTITLE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个方式和方式一是一样的，本质上就是忽略<code>OnUpdateFrameTitle</code>的默认行为。</p><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>继续跟进源码，创建窗口的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWnd::CreateEx</span><span class="params">(DWORD dwExStyle, LPCTSTR lpszClassName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpszWindowName, DWORD dwStyle,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> nWidth, <span class="type">int</span> nHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(lpszClassName == <span class="literal">NULL</span> || <span class="built_in">AfxIsValidString</span>(lpszClassName) ||</span><br><span class="line">        <span class="built_in">AfxIsValidAtom</span>(lpszClassName));</span><br><span class="line">    <span class="built_in">ENSURE_ARG</span>(lpszWindowName == <span class="literal">NULL</span> || <span class="built_in">AfxIsValidString</span>(lpszWindowName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow modification of several common create parameters</span></span><br><span class="line">    CREATESTRUCT cs;</span><br><span class="line">    cs.dwExStyle = dwExStyle;</span><br><span class="line">    cs.lpszClass = lpszClassName;</span><br><span class="line">    cs.lpszName = lpszWindowName;</span><br><span class="line">    cs.style = dwStyle;</span><br><span class="line">    cs.x = x;</span><br><span class="line">    cs.y = y;</span><br><span class="line">    cs.cx = nWidth;</span><br><span class="line">    cs.cy = nHeight;</span><br><span class="line">    cs.hwndParent = hWndParent;</span><br><span class="line">    cs.hMenu = nIDorHMenu;</span><br><span class="line">    cs.hInstance = <span class="built_in">AfxGetInstanceHandle</span>();</span><br><span class="line">    cs.lpCreateParams = lpParam;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PreCreateWindow</span>(cs)) &#123;</span><br><span class="line">        <span class="built_in">PostNcDestroy</span>();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AfxHookWindowCreate</span>(<span class="keyword">this</span>);</span><br><span class="line">    HWND hWnd = <span class="built_in">CreateWindowEx</span>(cs.dwExStyle, cs.lpszClass,</span><br><span class="line">        cs.lpszName, cs.style, cs.x, cs.y, cs.cx, cs.cy,</span><br><span class="line">        cs.hwndParent, cs.hMenu, cs.hInstance, cs.lpCreateParams);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Window creation failed: GetLastError returns 0x%8.8X\n&quot;</span>,</span><br><span class="line">            <span class="built_in">GetLastError</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxUnhookWindowCreate</span>())</span><br><span class="line">        <span class="built_in">PostNcDestroy</span>();        <span class="comment">// cleanup if CreateWindowEx fails too soon</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">ASSERT</span>(hWnd == m_hWnd); <span class="comment">// should have been set in send msg hook</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>CreateWindowEx</code>创建窗口之前调用过了一次<code>PreCreateWindow</code>，然后用<code>cs.lpszName</code>作为窗口标题，那么就可以在<code>PreCreateWindow</code>中设置固定标题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMainFrame::PreCreateWindow</span><span class="params">(CREATESTRUCT&amp; cs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CFrameWnd::<span class="built_in">PreCreateWindow</span>(cs))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在整个创建窗口过程中，PreCreateWindow 会被调用两次。仅在第二次实际创建窗口前再操作</span></span><br><span class="line">    <span class="keyword">if</span> (cs.hInstance) &#123;</span><br><span class="line">        cs.style &amp;= ~FWS_ADDTOTITLE; <span class="comment">// 禁止被文档改变标题</span></span><br><span class="line">        cs.lpszName = _T(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比前两种方式简单直观，推荐使用这种方式。</p><h2 id="Frame-默认标题从哪来？"><a href="#Frame-默认标题从哪来？" class="headerlink" title="Frame 默认标题从哪来？"></a>Frame 默认标题从哪来？</h2><p>如果我们不做任何设置，Frame 始终会有一个默认标题，这个标题字符串从哪来？还是看源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CFrameWnd::LoadFrame</span><span class="params">(UINT nIDResource, DWORD dwDefaultStyle,</span></span></span><br><span class="line"><span class="params"><span class="function">    CWnd* pParentWnd, CCreateContext* pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    CString strFullString;</span><br><span class="line">    <span class="keyword">if</span> (strFullString.<span class="built_in">LoadString</span>(nIDResource))</span><br><span class="line">        <span class="built_in">AfxExtractSubString</span>(m_strTitle, strFullString, <span class="number">0</span>);    <span class="comment">// first sub-string</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来在创建 MFC 工程时，资源文件中生成了它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STRINGTABLE</span><br><span class="line">BEGIN</span><br><span class="line">    IDR_MAINFRAME    &quot;MFCApplication2\n\nMFCApplication2\n\n\nMFCApplication2.Document\nMFCApplication2.Document&quot;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这是一个用<code>\n</code>分隔的字符串列表，第一个子串就是默认标题。<br>关于其他子串的解释可以查看 <a href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cdoctemplate-class#getdocstring">CDocTemplate::GetDocString</a> 的解释。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS 与 UTF-8 编码</title>
      <link href="/2022/05/05/16226233/"/>
      <url>/2022/05/05/16226233/</url>
      
        <content type="html"><![CDATA[<h2 id="与编码有关的几个地方"><a href="#与编码有关的几个地方" class="headerlink" title="与编码有关的几个地方"></a>与编码有关的几个地方</h2><ul><li>源文件编码。</li><li>工程设置中的<code>字符集</code>选项。</li><li>编译选项<code>/source-charset</code>和<code>/execution-charset</code>。</li><li>编译指令<code>#pragma execution_character_set(&quot;utf-8&quot;) </code>，已过时。</li></ul><p>实际上<code>字符集</code>设置只是决定双引号字符要不要加上<code>L</code>前缀，比如指定为<code>Unicode</code>字符集时，<code>&quot;Hello&quot;</code>将变为<code>L&quot;Hello&quot;</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>经过一番试验后得出：</p><ul><li>源文件编码不影响可执行文件编码，编译器默认使用本机编码识别源文件，或者<code>UTF-8 BOM</code>也可以。其他编码则需要通过编译选项<code>/source-charset</code>告知编译器，比如<code>UTF-8</code>则需要添加选项<code>/source-charset:utf-8</code>。</li><li>宽字符总是<code>UTF-16</code>编码，不受任何选项影响。</li><li>窄字符采用<code>/execution-charset</code>选项指定的编码，未指定时则采用本机编码。</li><li><code>/utf-8</code>选项等于同时设置<code>/source-charset:utf-8</code>和<code>/execution-charset:utf-8</code>。</li><li>在<code>Visual Studio 2013</code>及以下版本中，使用<code>#pragma execution_character_set(&quot;utf-8&quot;) </code>指令设置窄字符的编码方式，仅支持<code>UTF-8</code>。</li></ul><h2 id="使用-UTF-8-版-Win32-API"><a href="#使用-UTF-8-版-Win32-API" class="headerlink" title="使用 UTF-8 版 Win32 API"></a>使用 UTF-8 版 Win32 API</h2><p>当可执行文件字符编码为<code>UTF-8</code>时，与 Win32 API 交互就会出现乱码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">MessageBoxA</span>(m_hWnd, <span class="string">&quot;123456你好&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic.rmb.bdstatic.com/bjh/012c753ce92ff7709dfd79b87b914972.png"><br>因为历史原因，Windows 不支持<code>UTF-8</code>字符集，不过在较新的<code>Windows 10 1903</code>上已经开始支持了，但需要程序显示指明编码方式。<br>为程序添加一个特别的清单文件，这会告知 Windows 系统，程序使用了<code>UTF-8</code>字符集。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">manifestVersion</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">type</span>=<span class="string">&quot;win32&quot;</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">version</span>=<span class="string">&quot;6.0.0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">windowsSettings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeCodePage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/SMI/2019/WindowsSettings&quot;</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">activeCodePage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">windowsSettings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，它仅在<code>Windows 10 1903</code>以上的系统上有效。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>不需要跨平台时，将源文件保存为<code>UTF-8 BOM</code>编码。</li><li>不需要跨平台时，尽量使用宽字符，因为有少数 Win32 API 仅有宽字符的版本，而且 COM 接口都是宽字符。在需要与<code>UTF-8</code>交互的地方用 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a> 转换。</li><li>需要跨平台时，将源文件保存为<code>UTF-8</code>编码，并添加<code>/utf-8</code>选项，在与 Win32 API 交互的地方用 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> 转换。</li></ul><p>在未来某年 Windows 7 彻底消失后，就可以为程序添加 UTF-8 清单文件，将程序全面转换到 UTF-8。</p><h2 id="VS扩展"><a href="#VS扩展" class="headerlink" title="VS扩展"></a>VS扩展</h2><p>VS总是使用本机编码保存文件，我们可以通过第三方扩展来强制保存为<code>UTF-8 BOM</code>。<br>For VS2015-2019：<a href="https://marketplace.visualstudio.com/items?itemName=WinstonFeng.FormatonSave">Format on Save</a><br>For VS2022：<a href="https://marketplace.visualstudio.com/items?itemName=WinstonFeng.VSFormatOnSave2022">Format on Save for VS2022</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/source-charset-set-source-character-set">设置源字符集</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/execution-charset-set-execution-character-set">设置执行字符集</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8">将源和执行字符集设置为 UTF-8</a><br><a href="https://docs.microsoft.com/zh-cn/windows/apps/design/globalizing/use-utf8-code-page">在 Windows 应用中使用 UTF-8 代码页</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/execution-character-set">execution_character_set</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> UTF-8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gettext 使用方法</title>
      <link href="/2022/04/28/16205078/"/>
      <url>/2022/04/28/16205078/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Windows版下载地址：<a href="https://mlocati.github.io/articles/gettext-iconv-windows.html">https://mlocati.github.io/articles/gettext-iconv-windows.html</a></p><h2 id="翻译流程"><a href="#翻译流程" class="headerlink" title="翻译流程"></a>翻译流程</h2><ol><li>在软件源码中使用相应的库将需要翻译的文字标记起来。比如C语言的<code>libintl</code>，适合C++的 <a href="https://www.boost.org/doc/libs/release/libs/locale/doc/html/index.html">Boost.locale</a>。</li><li>使用<code>xgettext.exe</code>工具提取源代码中被标记的语句，生成 pot（portable object template）文件。</li><li>使用<code>msginit.exe</code>工具将 pot 文件转化成一个特定语言版本的 po（portable object）文件。或者使用<code>msgmerge.exe</code>将更新了的 pot 文件与旧的 po 文件合并生成新的 po 文件。</li><li>编辑 po 文件（可使用 <a href="https://poedit.net/">Poedit</a> 等工具），开始翻译工作。</li><li>使用<code>msgfmt.exe</code>工具将<code>.po</code>文件转换成<code>.mo</code>（machine object)文件。</li></ol><h2 id="提取原文"><a href="#提取原文" class="headerlink" title="提取原文"></a>提取原文</h2><p>从源码中提取原文用到的工具是<code>xgettext</code>。</p><h3 id="0x01-基本用法"><a href="#0x01-基本用法" class="headerlink" title="0x01 基本用法"></a>0x01 基本用法</h3><p>在源码中标记需要翻译的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = boost::locale::<span class="built_in">gettext</span>(<span class="string">&quot;Love&quot;</span>);</span><br></pre></td></tr></table></figure><p>提取命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgettext.exe --from-code=&quot;UTF-8&quot; -o my.pot main.cpp</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong></p><ol><li>工具默认提取关键字<code>gettext</code>标记的字符串。</li><li>工具默认认为源文件是 ASCII 文件。</li></ol><p>但既然是要做国际化支持，建议将源码文件改为 UTF-8 编码，通过参数<code>--from-code</code>来指示源文件的编码即可。生成的 pot 文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># SOME DESCRIPTIVE TITLE.</span><br><span class="line"># Copyright (C) YEAR THE PACKAGE&#x27;S COPYRIGHT HOLDER</span><br><span class="line"># This file is distributed under the same license as the PACKAGE package.</span><br><span class="line"># FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: PACKAGE VERSION\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2022-04-00 00:00+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n&quot;</span><br><span class="line">&quot;Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: LANGUAGE &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text/plain; charset=CHARSET\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: C:/Demo/main.cpp:15</span><br><span class="line">msgid &quot;Love&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="0x02-自定义提取关键字"><a href="#0x02-自定义提取关键字" class="headerlink" title="0x02 自定义提取关键字"></a>0x02 自定义提取关键字</h3><p><code>xgettext.exe</code>默认仅识别<code>gettext</code>关键字，但可以用<code>--keyword</code>参数指示额外的关键字以满足扩展需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _(STRING) boost::locale::gettext(STRING)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> str1 = _(<span class="string">&quot;underline&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> str2 = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;boost&quot;</span>);</span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgettext --from-code=&quot;UTF-8&quot; --keyword=_ --keyword=translate -o gettext.pot main.cpp</span><br></pre></td></tr></table></figure><h2 id="生成-po-文件"><a href="#生成-po-文件" class="headerlink" title="生成 po 文件"></a>生成 po 文件</h2><p>生成 po 文件用到的工具是<code>msginit</code>。</p><h3 id="0x01-基本用法-1"><a href="#0x01-基本用法-1" class="headerlink" title="0x01 基本用法"></a>0x01 基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msginit -i gettext.pot -o gettext.po</span><br></pre></td></tr></table></figure><p>得到po文件内容大概如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Chinese translations for PACKAGE package</span><br><span class="line"># PACKAGE 软件包的简体中文翻译.</span><br><span class="line"># Copyright (C) 2022 THE PACKAGE&#x27;S COPYRIGHT HOLDER</span><br><span class="line"># This file is distributed under the same license as the PACKAGE package.</span><br><span class="line"># &lt;EMAIL@ADDRESS&gt;, 2022.</span><br><span class="line">#</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: PACKAGE VERSION\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2022-04-01 08:57+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: 2022-04-01 09:16+0800\n&quot;</span><br><span class="line">&quot;Last-Translator: &lt;EMAIL@ADDRESS&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: Chinese (simplified)\n&quot;</span><br><span class="line">&quot;Language: zh_CN\n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text/plain; charset=GBK\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line">&quot;Plural-Forms: nplurals=1; plural=0;\n&quot;</span><br><span class="line"></span><br><span class="line">#: C:/Demo/Application.cpp:45</span><br><span class="line">msgid &quot;Love&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line"></span><br><span class="line">#: C:/Demo/Application.cpp:46</span><br><span class="line">msgid &quot;underline&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line"></span><br><span class="line">#: C:/Demo/Application.cpp:47</span><br><span class="line">msgid &quot;boost&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="0x02-指示目标语言及编码"><a href="#0x02-指示目标语言及编码" class="headerlink" title="0x02 指示目标语言及编码"></a>0x02 指示目标语言及编码</h3><p>输出的 po 文件默认使用本机区域设置，比如简体中文是<code>zh_CN.GBK</code>。<br>可以通过<code>--locale</code>参数指示 po 文件的语言和编码。格式遵循 <a href="https://baike.baidu.com/item/ISO%20639-1">ISO 639-1</a> 和 <a href="https://baike.baidu.com/item/ISO%203166-1/5269555">ISO 3166-1</a> 标准。<br>比如我想创建一个针对简体中文的翻译文件并采用 UTF-8 编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msginit --locale=zh_CN.UTF-8 -i gettext.pot -o zh_CN.po</span><br></pre></td></tr></table></figure><p>但是<code>charset</code>却依然是GBK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;Content-Type: text/plain; charset=GBK\n&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>google找到了答案：因为 pot 文件没有编码信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Content-Type: text/plain; charset=CHARSET\n&quot;</span><br></pre></td></tr></table></figure><p>明明在 xgettext 参数中指定了 UTF-8，为什么 pot 文件没有信息？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgettext.exe --from-code=&quot;UTF-8&quot;</span><br></pre></td></tr></table></figure><p>因为 xgettext 在提取原文过程中没有发现任何非 ASCII 字符，就会忽略掉 charset，也算是个BUG了。<br>当我手动修改 pot 文件编码后，再次生成 po 文件，charset 就变为了 UTF-8，但文件内容其实还是GBK。。。<br><img src="https://pic.rmb.bdstatic.com/bjh/63597676b81cbde2eab69189c966bba1.png"><br>所以，解决这个问题需要做两件事</p><ol><li>修改 po 文件的<code>charset</code>为UTF-8</li><li>修改 po 文件编码为 UTF-8</li></ol><p>每次去手动修改有点傻，我们可以在源码中标记一个UTF-8字符，但是翻译的时候忽略它，这样就能保证 pot、po文件的<code>charset</code>为UTF-8。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TRANSLATOR:无需翻译</span></span><br><span class="line">boost::locale::<span class="built_in">pgettext</span>(<span class="string">&quot;IGNORE&quot;</span>, <span class="string">&quot;ø&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样就解决了<code>charset</code>的问题。文件自身编码问题可以用<code>iconv.exe</code>来转换，它已经包含在<code>gettext</code>工具包中了，所以最终的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msginit -i test.pot -o zh_CN.po.tmp</span><br><span class="line">iconv -t utf-8 zh_CN.po.tmp &gt; zh_CN.po</span><br><span class="line">del zh_CN.po.tmp</span><br></pre></td></tr></table></figure><h2 id="生成-mo-语言文件"><a href="#生成-mo-语言文件" class="headerlink" title="生成 mo 语言文件"></a>生成 mo 语言文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgfmt -o test.mo zh_CN.po</span><br></pre></td></tr></table></figure><h2 id="更新-po-文件"><a href="#更新-po-文件" class="headerlink" title="更新 po 文件"></a>更新 po 文件</h2><p>在软件升级迭代的过程中，待翻译原文也会发生变化，如增加、删除等，这就需要将 pot 文件中变动的内容更新至 po 文件，而不是重新生成一个新的 po 文件。这就需要用到<code>msgmerge</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgmerge -U zh_CN.po test.pot</span><br></pre></td></tr></table></figure><p><code>-U</code>表示更新现有 po 文件，按位置看，第一个文件就是被更新的目标文件。<br>当然也可以用<code>-o</code>参数创建一个新的 po 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgmerge -o new.po zh_CN.po test.pot</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong></p><ol><li>新文件中词条如果有译文，任何情况下都不会被覆盖。</li><li>通过<code>compendium</code>参数指定翻译文件对空词条进行填充。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgmerge --compendium dict.po -U target.po new.pot</span><br></pre></td></tr></table></figure><p>注意，引用的文件可以是 pot 文件，也可以是 po 文件。</p><h2 id="合并多个-po-文件"><a href="#合并多个-po-文件" class="headerlink" title="合并多个 po 文件"></a>合并多个 po 文件</h2><p>一个软件项目可能含有多个模块，每个模块都有自己的翻译文件，有大量重叠的内容，完全可以将多个 po 文件合并为一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgcat -o all.po 1.po 2.po</span><br></pre></td></tr></table></figure><p>默认合并规则：</p><ul><li>对于相同的原文，如果仅有一个被翻译了，则采用它。</li><li>对于相同的原文，如果有不同的翻译，则会合并所有的翻译，需要人工处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#: main.cpp:21 main.cpp:25</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;Love&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;#-#-#-#-#  1.po  #-#-#-#-#\n&quot;</span><br><span class="line">&quot;爱情\n&quot;</span><br><span class="line">&quot;#-#-#-#-#  2.po  #-#-#-#-#\n&quot;</span><br><span class="line">&quot;爱&quot;</span><br></pre></td></tr></table></figure><img src="https://pic.rmb.bdstatic.com/bjh/a6c4215b2b72a9ba139b57ff419faab2.png"><br>如果想避免重复的翻译内容被合并，可以使用<code>use-first</code>参数，表示采用找到的第一个可用的翻译。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgcat --use-first -o all.po 1.po 2.po</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.gnu.org/software/gettext/manual/html_node/msginit-Invocation.html">msginit</a><br><a href="https://blog.csdn.net/haiiiiiyun/article/details/104970005">GNU gettext工具简介</a><br><a href="https://www.helywin.com/posts/20200814061352/">gettext使用</a><br><a href="https://peter.bloomfield.online/generate-utf-8-dictionaries-using-gettext/">Generate UTF-8 dictionaries using gettext</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> gettext </tag>
            
            <tag> 本地化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Boost.Locale 使软件支持多国语言</title>
      <link href="/2022/04/27/16200732/"/>
      <url>/2022/04/27/16200732/</url>
      
        <content type="html"><![CDATA[<p>用过Qt的人都知道它自带有多语言支持的功能，只要在源码中将需要翻译的字符串用<code>tr</code>包裹起来，就可以很轻松的利用其提供的 Qt Linguist 软件进行文字翻译。<br>如果我们的工程并非Qt项目，那么可以考虑使用 <a href="https://www.gnu.org/software/gettext/">gettext</a> 解决方案。其实现库<code>libintl</code>是C语言开发的，在 linux 系统上用的比较多。<br>在C++中，更适合使用 <a href="https://www.boost.org/doc/libs/release/libs/locale/doc/html/index.html">Boost.Locale</a>，用于替代<code>libintl</code>。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>需要了解的是，Boost.Locale 只是一个运行时，它本身并不生成语言文件。我们需要使用<code>gettext</code>的相关工具去进行提取和翻译工作。</p><blockquote><p>文本假设你已经知道了如何制作.mo等语言文件。</p></blockquote><p>一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/locale.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::locale::generator gen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定多语言文件的根目录</span></span><br><span class="line">    gen.<span class="built_in">add_messages_path</span>(<span class="string">R&quot;(.\languages)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应语言文件名，不需要写扩展名。等同于 foo.mo</span></span><br><span class="line">    gen.<span class="built_in">add_messages_domain</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generator 会去对应的文件夹下找语言文件。这里会尝试从 zh 和 zh_CN 文件夹下寻找文件</span></span><br><span class="line">    std::locale loc = gen.<span class="built_in">generate</span>(<span class="string">&quot;zh_CN.GBK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置全局locale</span></span><br><span class="line">    std::locale::<span class="built_in">global</span>(loc);</span><br><span class="line"></span><br><span class="line">    std::string str1 = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;Love&quot;</span>).<span class="built_in">str</span>();</span><br><span class="line">    std::string str2 = boost::locale::<span class="built_in">gettext</span>(<span class="string">&quot;Love&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的例子，以下文件路径都是合法的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\languages\zh\LC_MESSAGES\foo.mo</span><br><span class="line">\languages\zh_CN\LC_MESSAGES\foo.mo</span><br></pre></td></tr></table></figure><p>generate 方法使用空字符串作为参数时将采用<code>系统默认区域 + UTF8</code>编码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载了 () 操作符，等同于调用 generate 方法</span></span><br><span class="line">std::locale loc = <span class="built_in">gen</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">auto</span>&amp; info = std::<span class="built_in">use_facet</span>&lt;boost::locale::info&gt;(loc);</span><br><span class="line">std::string v1 = info.<span class="built_in">name</span>();     <span class="comment">// zh_CN.UTF-8</span></span><br><span class="line">std::string v2 = info.<span class="built_in">language</span>(); <span class="comment">// zh</span></span><br><span class="line">std::string v3 = info.<span class="built_in">country</span>();  <span class="comment">// CN</span></span><br><span class="line">std::string v4 = info.<span class="built_in">encoding</span>(); <span class="comment">// utf-8</span></span><br><span class="line"><span class="type">bool</span> v5 = info.<span class="built_in">utf8</span>();            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>翻译字符串主要是两个静态方法<code>translate</code>和<code>gettext</code>。<br><code>translate</code>返回的是一个模板类<code>basic_message</code>，它允许原文延迟翻译，也就是只有在需要<code>string</code>的时候才会翻译。<br>而<code>gettext</code>方法是建立在<code>basic_message</code>之上的，它会立即构造一个<code>basic_message</code>并且调用<code>str()</code>方法得到字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType&gt;</span></span><br><span class="line"><span class="function">std::basic_string&lt;CharType&gt; <span class="title">gettext</span><span class="params">(CharType <span class="type">const</span> *id, std::locale <span class="type">const</span> &amp;loc=std::locale())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">basic_message</span>&lt;CharType&gt;(id).<span class="built_in">str</span>(loc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是想立即得到译文，用<code>gettext</code>就够了。</p><h2 id="gettext"><a href="#gettext" class="headerlink" title="gettext"></a>gettext</h2><ol><li>获得译文，没有译文就返回原文<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str = boost::locale::<span class="built_in">gettext</span>(<span class="string">&quot;Love&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>第二个参数可以指定 locale<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str = boost::locale::<span class="built_in">gettext</span>(<span class="string">&quot;Love&quot;</span>, de);</span><br></pre></td></tr></table></figure></li></ol><h3 id="dgettext"><a href="#dgettext" class="headerlink" title="dgettext"></a>dgettext</h3><p>从指定的 domain(文件) 中获取译文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = boost::locale::<span class="built_in">dgettext</span>(<span class="string">&quot;foo2&quot;</span>, <span class="string">&quot;Love&quot;</span>);</span><br><span class="line">std::string str2 = boost::locale::<span class="built_in">dgettext</span>(<span class="string">&quot;foo2&quot;</span>, <span class="string">&quot;Love&quot;</span>, gbk);</span><br></pre></td></tr></table></figure><h3 id="ngettext"><a href="#ngettext" class="headerlink" title="ngettext"></a>ngettext</h3><p><code>ngettext</code>用于处理某些语言的复数形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> str = fmt::format(boost::locale::<span class="built_in">ngettext</span>(<span class="string">&quot;1 file&quot;</span>, <span class="string">&quot;&#123;&#125; files&quot;</span>, count), count); <span class="comment">// 1 file</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">2</span>;</span><br><span class="line">str = fmt::format(boost::locale::<span class="built_in">ngettext</span>(<span class="string">&quot;1 file&quot;</span>, <span class="string">&quot;&#123;&#125; files&quot;</span>, count), count); <span class="comment">// 2 files</span></span><br></pre></td></tr></table></figure><h3 id="pgettext"><a href="#pgettext" class="headerlink" title="pgettext"></a>pgettext</h3><p>根据上下文获得译文。上下文功能在某些场景下是有用的，它可以使同一个原文返回不同的译文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = boost::locale::<span class="built_in">pgettext</span>(<span class="string">&quot;ctx1&quot;</span>, <span class="string">&quot;Love&quot;</span>);</span><br><span class="line">std::string str2 = boost::locale::<span class="built_in">pgettext</span>(<span class="string">&quot;ctx2&quot;</span>, <span class="string">&quot;Love&quot;</span>, gbk);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>gettext</code>是高级别的方法，使用简单。还有扩展的的方法如<code>dgettext</code>、<code>ngettext</code>、<code>pgettext</code>等等。我们只要记住三个字母：</p><ol><li><code>d</code>表示<code>domain</code>，支持指定域（语言文件）。</li><li><code>n</code>表示<code>number</code>，用于处理复数形式。</li><li><code>p</code>表示<code>specific</code>，表示处理特定语境下的语句。</li></ol><p><code>gettext</code>所有的方法如下，看字母就知道怎么用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boost::locale::<span class="built_in">gettext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// d 开头</span></span><br><span class="line">boost::locale::<span class="built_in">dgettext</span>()</span><br><span class="line">boost::locale::<span class="built_in">dngettext</span>()</span><br><span class="line">boost::locale::<span class="built_in">dnpgettext</span>()</span><br><span class="line">boost::locale::<span class="built_in">dpgettext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 开头</span></span><br><span class="line">boost::locale::<span class="built_in">ngettext</span>()</span><br><span class="line">boost::locale::<span class="built_in">npgettext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 开头</span></span><br><span class="line">boost::locale::<span class="built_in">pgettext</span>();</span><br></pre></td></tr></table></figure><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>前面说过，<code>translate</code>才是底层的API，主要用于需要延迟翻译的时候，使用方法和<code>gettext</code>差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::string str = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;Love&quot;</span>).<span class="built_in">str</span>();</span><br><span class="line"><span class="comment">// 等同于 gettext</span></span><br><span class="line"></span><br><span class="line">std::string str = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;Love&quot;</span>).<span class="built_in">str</span>(<span class="string">&quot;domain&quot;</span>);</span><br><span class="line"><span class="comment">// 等同于 dgettext</span></span><br><span class="line"></span><br><span class="line">std::string str = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;1 files&quot;</span>, <span class="string">&quot;N files&quot;</span>, <span class="number">1</span>).<span class="built_in">str</span>();</span><br><span class="line"><span class="comment">// 等同于 ngettext</span></span><br><span class="line"></span><br><span class="line">std::string str = boost::locale::<span class="built_in">translate</span>(<span class="string">&quot;ctx&quot;</span>, <span class="string">&quot;Love&quot;</span>).<span class="built_in">str</span>();</span><br><span class="line"><span class="comment">// 等同于 pgettext</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>软件首次运行时一般有三种选择</p><ol><li>默认采用英文显示。</li><li>有安装程序的，在安装过程中让用户决定使用的语言。</li><li>跟随系统区域设置决定使用哪种语言。</li></ol><p>对于第三种方式，我们需要获取计算机的区域设置。上面说过<code>generator</code>支持用空字符串来生成系统默认区域的locale，但是编码是用的UTF-8。<br>如果我们想获取系统的区域设置，可以用boost完成这项工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string localeStr = boost::locale::util::<span class="built_in">get_system_locale</span>();</span><br><span class="line"><span class="comment">// 在简体中文Windows上，结果为 zh_CN.windows-936</span></span><br></pre></td></tr></table></figure><p>然后将结果告诉<code>generator</code>，这样程序首次运行时将使用系统默认的语言显示了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::locale loc = boost::locale::<span class="built_in">generator</span>().<span class="built_in">generate</span>(localeStr);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.helywin.com/posts/20200814061352/">gettext使用</a><br><a href="https://www.boost.org/doc/libs/release/libs/locale/doc/html/locale_gen.html">Locale Generation</a><br><a href="https://www.boost.org/doc/libs/release/libs/locale/doc/html/messages_formatting.html">Messages Formatting (Translation)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Boost </tag>
            
            <tag> gettext </tag>
            
            <tag> 本地化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dear ImGui学习：使用 WantCaptureMouse 检查鼠标消息</title>
      <link href="/2022/04/23/16183345/"/>
      <url>/2022/04/23/16183345/</url>
      
        <content type="html"><![CDATA[<p><code>WantCaptureMouse</code>是类<code>ImGuiIO</code>的成员方法，源码中对于<code>WantCaptureMouse</code>的注释是这么写的：</p><blockquote><p>Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game&#x2F;application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).</p></blockquote><p>简单地说就是可以用来它判断鼠标是否在 imgui 窗口内，大部分使用场景是用来覆盖游戏引擎自身的鼠标数据。<br>比如我在游戏内show出窗口时，默认情况下鼠标在窗口上的点击都会传递给游戏处理，而此时我需要避免将 imgui 的鼠标事件传递给游戏处理，那么就可以通过<code>WantCaptureMouse</code>来判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImGui_ImplWin32_WndProcHandler</span>(hWnd, uMsg, wParam, lParam)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    <span class="keyword">if</span> (io.WantCaptureMouse &amp;&amp; (uMsg == WM_LBUTTONDOWN || uMsg == WM_LBUTTONUP || uMsg == WM_RBUTTONDOWN || uMsg == WM_RBUTTONUP || uMsg == WM_MBUTTONDOWN || uMsg == WM_MBUTTONUP || uMsg == WM_MOUSEWHEEL || uMsg == WM_MOUSEMOVE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallWindowProcW</span>(g_pOldWindowProc, hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标在 imgui 窗口外时，imgui 默认会渲染指针样式，再加上游戏引擎渲染的指针样式，就出现了游戏内同时有两个指针的问题，所以我们在渲染时也可以通过<code>WantCaptureMouse</code>来检查，避免在 imgui 窗口外二次渲染指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ImGui_ImplDX11_NewFrame</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplWin32_NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标不在imgui窗口内就不要渲染指针了</span></span><br><span class="line"><span class="type">const</span> ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line"><span class="keyword">if</span> (!io.WantCaptureMouse) &#123;</span><br><span class="line">    ImGui::<span class="built_in">SetMouseCursor</span>(ImGuiMouseCursor_None);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Demo&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;FPS:%.1f&quot;</span>, io.Framerate);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Render</span>();</span><br></pre></td></tr></table></figure><p><strong>注意，永远不要手动去设置 WantCaptureMouse。</strong></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ocornut/imgui/issues/4593">io.WantCaptureMouse is not working. So im using an alternative bool. But i still want to understand what im doing wrong.</a><br><a href="https://github.com/ocornut/imgui/issues/5061">How to use imgui in an existing win32 dx11 application properly.</a><br><a href="https://www.unknowncheats.me/forum/direct3d/340355-mouse-input-imgui-window.html">Mouse input going through ImGui window</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Dear ImGui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Workstation 下载地址</title>
      <link href="/2022/04/22/VMware-Workstation/"/>
      <url>/2022/04/22/VMware-Workstation/</url>
      
        <content type="html"><![CDATA[<p>最新版本：<a href="https://www.vmware.com/go/getworkstation-win">https://www.vmware.com/go/getworkstation-win</a></p><h2 id="v17"><a href="#v17" class="headerlink" title="v17"></a>v17</h2><p>VMware-workstation-full-17.5.2-23775571.exe<br><a href="https://download3.vmware.com/software/WKST-1751-WIN/VMware-workstation-full-17.5.1-23298084.exe">VMware-workstation-full-17.5.1-23298084.exe</a><br><a href="https://download3.vmware.com/software/WKST-1750-WIN/VMware-workstation-full-17.5.0-22583795.exe">VMware-workstation-full-17.5.0-22583795.exe</a><br><a href="https://download3.vmware.com/software/WKST-1702-WIN/VMware-workstation-full-17.0.2-21581411.exe">VMware-workstation-full-17.0.2-21581411.exe</a><br><a href="https://download3.vmware.com/software/WKST-1701-WIN/VMware-workstation-full-17.0.1-21139696.exe">VMware-workstation-full-17.0.1-21139696.exe</a><br><a href="https://download3.vmware.com/software/WKST-1700-WIN/VMware-workstation-full-17.0.0-20800274.exe">VMware-workstation-full-17.0.0-20800274.exe</a></p><hr><h2 id="v16"><a href="#v16" class="headerlink" title="v16"></a>v16</h2><p><a href="https://download3.vmware.com/software/WKST-1624-WIN/VMware-workstation-full-16.2.4-20089737.exe">VMware-workstation-full-16.2.4-20089737.exe</a><br><a href="https://download3.vmware.com/software/WKST-1623-WIN-New/VMware-workstation-full-16.2.3-19376536.exe">VMware-workstation-full-16.2.3-19376536.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.2.2-19200509.exe">VMware-workstation-full-16.2.2-19200509.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.2.1-18811642.exe">VMware-workstation-full-16.2.1-18811642.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.2.0-18760230.exe">VMware-workstation-full-16.2.0-18760230.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.1.2-17966106.exe">VMware-workstation-full-16.1.2-17966106.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.1.1-17801498.exe">VMware-workstation-full-16.1.1-17801498.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.1.0-17198959.exe">VMware-workstation-full-16.1.0-17198959.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.0.0-16894299.exe">VMware-workstation-full-16.0.0-16894299.exe</a></p><hr><h2 id="v15"><a href="#v15" class="headerlink" title="v15"></a>v15</h2><p><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.6-16341506.exe">VMware-workstation-full-15.5.6-16341506.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.5-16285975.exe">VMware-workstation-full-15.5.5-16285975.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.2-15785246.exe">VMware-workstation-full-15.5.2-15785246.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe">VMware-workstation-full-15.5.1-15018445.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe">VMware-workstation-full-15.5.0-14665864.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe">VMware-workstation-full-15.1.0-13591040.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.4-12990004.exe">VMware-workstation-full-15.0.4-12990004.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.3-12422535.exe">VMware-workstation-full-15.0.3-12422535.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.2-10952284.exe">VMware-workstation-full-15.0.2-10952284.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.1-10737736.exe">VMware-workstation-full-15.0.1-10737736.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.0-10134415.exe">VMware-workstation-full-15.0.0-10134415.exe</a></p><hr><h2 id="v14"><a href="#v14" class="headerlink" title="v14"></a>v14</h2><p><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.8-14921873.exe">VMware-workstation-full-14.1.8-14921873.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.7-12989993.exe">VMware-workstation-full-14.1.7-12989993.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.6-12368378.exe">VMware-workstation-full-14.1.6-12368378.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.5-10950780.exe">VMware-workstation-full-14.1.5-10950780.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.4-10722678.exe">VMware-workstation-full-14.1.4-10722678.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe">VMware-workstation-full-14.1.3-9474260.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.2-8497320.exe">VMware-workstation-full-14.1.2-8497320.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.1-7528167.exe">VMware-workstation-full-14.1.1-7528167.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.0-7370693.exe">VMware-workstation-full-14.1.0-7370693.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.0.0-6661328.exe">VMware-workstation-full-14.0.0-6661328.exe</a></p><hr><h2 id="v12"><a href="#v12" class="headerlink" title="v12"></a>v12</h2><p><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe">VMware-workstation-full-12.5.9-7535481.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.8-7098237.exe">VMware-workstation-full-12.5.8-7098237.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.7-5813279.exe">VMware-workstation-full-12.5.7-5813279.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.6-5528349.exe">VMware-workstation-full-12.5.6-5528349.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.5-5234757.exe">VMware-workstation-full-12.5.5-5234757.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.4-5192485.exe">VMware-workstation-full-12.5.4-5192485.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.3-5115892.exe">VMware-workstation-full-12.5.3-5115892.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.2-4638234.exe">VMware-workstation-full-12.5.2-4638234.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.1-4542065.exe">VMware-workstation-full-12.5.1-4542065.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.0-4352439.exe">VMware-workstation-full-12.5.0-4352439.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.1.1-3770994.exe">VMware-workstation-full-12.1.1-3770994.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.1.0-3272444.exe">VMware-workstation-full-12.1.0-3272444.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.0.1-3160714.exe">VMware-workstation-full-12.0.1-3160714.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.0.0-2985596.exe">VMware-workstation-full-12.0.0-2985596.exe</a></p><hr><h2 id="v11"><a href="#v11" class="headerlink" title="v11"></a>v11</h2><p><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.1.4-3848939.exe">VMware-workstation-full-11.1.4-3848939.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.1.3-3206955.exe">VMware-workstation-full-11.1.3-3206955.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.1.2-2780323.exe">VMware-workstation-full-11.1.2-2780323.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.1.1-2771112.exe">VMware-workstation-full-11.1.1-2771112.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.1.0-2496824.exe">VMware-workstation-full-11.1.0-2496824.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-11.0.0-2305329.exe">VMware-workstation-full-11.0.0-2305329.exe</a></p><hr><h2 id="v10"><a href="#v10" class="headerlink" title="v10"></a>v10</h2><p><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe">VMware-workstation-full-10.0.7-2844087.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.6-2700073.exe">VMware-workstation-full-10.0.6-2700073.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.5-2443746.exe">VMware-workstation-full-10.0.5-2443746.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.4-2249910.exe">VMware-workstation-full-10.0.4-2249910.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.3-1895310.exe">VMware-workstation-full-10.0.3-1895310.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.2-1744117.exe">VMware-workstation-full-10.0.2-1744117.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.1-1379776.exe">VMware-workstation-full-10.0.1-1379776.exe</a><br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.0-1295980.exe">VMware-workstation-full-10.0.0-1295980.exe</a></p><hr><h2 id="v9"><a href="#v9" class="headerlink" title="v9"></a>v9</h2><p><a href="https://download2.vmware.com/software/wkst/VMware-workstation-full-9.0.4-1945795.exe">VMware-workstation-full-9.0.4-1945795.exe</a><br><a href="https://download2.vmware.com/software/wkst/VMware-workstation-full-9.0.3-1410761.exe">VMware-workstation-full-9.0.3-1410761.exe</a><br><a href="https://download2.vmware.com/software/wkst/VMware-workstation-full-9.0.2-1031769.exe">VMware-workstation-full-9.0.2-1031769.exe</a><br><a href="https://download2.vmware.com/software/wkst/VMware-workstation-full-9.0.1-894247.exe">VMware-workstation-full-9.0.1-894247.exe</a><br><a href="https://download2.vmware.com/software/wkst/VMware-workstation-full-9.0.0-812388.exe">VMware-workstation-full-9.0.0-812388.exe</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/201853910/VMwareWorkstation/releases">https://github.com/201853910/VMwareWorkstation/releases</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio 下载地址</title>
      <link href="/2022/04/20/16170572/"/>
      <url>/2022/04/20/16170572/</url>
      
        <content type="html"><![CDATA[<h2 id="Visual-Studio-2022"><a href="#Visual-Studio-2022" class="headerlink" title="Visual Studio 2022"></a>Visual Studio 2022</h2><p>专业版：<a href="https://aka.ms/vs/17/release/vs_professional.exe">https://aka.ms/vs/17/release/vs_professional.exe</a><br>企业版：<a href="https://aka.ms/vs/17/release/vs_enterprise.exe">https://aka.ms/vs/17/release/vs_enterprise.exe</a></p><hr><h2 id="Visual-Studio-2019"><a href="#Visual-Studio-2019" class="headerlink" title="Visual Studio 2019"></a>Visual Studio 2019</h2><p>专业版：<a href="https://aka.ms/vs/16/release/vs_professional.exe">https://aka.ms/vs/16/release/vs_professional.exe</a><br>企业版：<a href="https://aka.ms/vs/16/release/vs_enterprise.exe">https://aka.ms/vs/16/release/vs_enterprise.exe</a></p><hr><h2 id="Visual-Studio-2017"><a href="#Visual-Studio-2017" class="headerlink" title="Visual Studio 2017"></a>Visual Studio 2017</h2><p>专业版：<a href="https://aka.ms/vs/15/release/vs_professional.exe">https://aka.ms/vs/15/release/vs_professional.exe</a><br>企业版：<a href="https://aka.ms/vs/15/release/vs_enterprise.exe">https://aka.ms/vs/15/release/vs_enterprise.exe</a></p><hr><p><strong>Visual Studio 2015 及以前的版本是离线安装包，对于有Update的仅列出最新的链接地址。</strong></p><h2 id="Visual-Studio-2015"><a href="#Visual-Studio-2015" class="headerlink" title="Visual Studio 2015"></a>Visual Studio 2015</h2><h3 id="包含-Update-3-更新"><a href="#包含-Update-3-更新" class="headerlink" title="包含 Update 3 更新"></a>包含 Update 3 更新</h3><p>英文专业版：<a href="http://download.microsoft.com/download/e/b/c/ebc2c43f-3821-4a0b-82b1-d05368af1604/vs2015.3.pro_enu.iso">http://download.microsoft.com/download/e/b/c/ebc2c43f-3821-4a0b-82b1-d05368af1604/vs2015.3.pro_enu.iso</a><br>中文专业版：<a href="http://download.microsoft.com/download/5/4/b/54bf5736-8429-4c81-b1b3-79de06dfe756/vs2015.3.pro_chs.iso">http://download.microsoft.com/download/5/4/b/54bf5736-8429-4c81-b1b3-79de06dfe756/vs2015.3.pro_chs.iso</a></p><hr><h2 id="Visual-Studio-2013"><a href="#Visual-Studio-2013" class="headerlink" title="Visual Studio 2013"></a>Visual Studio 2013</h2><h3 id="包含-Update-5-更新"><a href="#包含-Update-5-更新" class="headerlink" title="包含 Update 5 更新"></a>包含 Update 5 更新</h3><p>英文专业版：<a href="http://download.microsoft.com/download/F/2/E/F2EFF589-F7D7-478E-B3AB-15F412DA7DEB/vs2013.5_pro_enu.iso">http://download.microsoft.com/download/F/2/E/F2EFF589-F7D7-478E-B3AB-15F412DA7DEB/vs2013.5_pro_enu.iso</a><br>中文专业版：<a href="http://download.microsoft.com/download/6/F/2/6F297D22-B6A5-428F-AFC3-5A887FF036BE/vs2013.5_pro_chs.iso">http://download.microsoft.com/download/6/F/2/6F297D22-B6A5-428F-AFC3-5A887FF036BE/vs2013.5_pro_chs.iso</a></p><p>英文旗舰版：<a href="http://download.microsoft.com/download/E/2/A/E2ADF1BE-8FA0-4436-A260-8780444C8355/vs2013.5_ult_enu.iso">http://download.microsoft.com/download/E/2/A/E2ADF1BE-8FA0-4436-A260-8780444C8355/vs2013.5_ult_enu.iso</a><br>中文旗舰版：<a href="http://download.microsoft.com/download/9/3/E/93EA27FF-DB02-4822-8771-DCA0238957E9/vs2013.5_ult_chs.iso">http://download.microsoft.com/download/9/3/E/93EA27FF-DB02-4822-8771-DCA0238957E9/vs2013.5_ult_chs.iso</a></p><hr><h2 id="Visual-Studio-2012"><a href="#Visual-Studio-2012" class="headerlink" title="Visual Studio 2012"></a>Visual Studio 2012</h2><p>英文专业版：<a href="download.microsoft.com/download/d/e/8/de8e42d8-7598-4f4e-93d4-bb011094e2f9/vs2012_pro_enu.iso">download.microsoft.com&#x2F;download&#x2F;d&#x2F;e&#x2F;8&#x2F;de8e42d8-7598-4f4e-93d4-bb011094e2f9&#x2F;vs2012_pro_enu.iso</a><br>中文专业版：<a href="http://download.microsoft.com/download/B/2/8/B2801FEE-9A60-4AFA-8657-0E8AB0A373F0/VS2012_PRO_chs.iso">http://download.microsoft.com/download/B/2/8/B2801FEE-9A60-4AFA-8657-0E8AB0A373F0/vs2012_pro_chs.iso</a></p><p>英文旗舰版：<a href="http://download.microsoft.com/download/D/B/0/DB03922C-FF91-4845-B7F2-FC68595AB730/VS2012_ULT_enu.iso">http://download.microsoft.com/download/D/B/0/DB03922C-FF91-4845-B7F2-FC68595AB730/vs2012_ult_enu.iso</a><br>中文旗舰版：<a href="http://download.microsoft.com/download/B/0/F/B0F589ED-F1B7-478C-849A-02C8395D0995/VS2012_ULT_chs.iso">http://download.microsoft.com/download/B/0/F/B0F589ED-F1B7-478C-849A-02C8395D0995/vs2012_ult_chs.iso</a></p><h3 id="Update-4-更新包"><a href="#Update-4-更新包" class="headerlink" title="Update 4 更新包"></a>Update 4 更新包</h3><p><a href="http://download.microsoft.com/download/D/4/8/D48D1AC2-A297-4C9E-A9D0-A218E6609F06/VSU4/VS2012.4.iso">http://download.microsoft.com/download/D/4/8/D48D1AC2-A297-4C9E-A9D0-A218E6609F06/VSU4/VS2012.4.iso</a></p><hr><h2 id="Visual-Studio-2010"><a href="#Visual-Studio-2010" class="headerlink" title="Visual Studio 2010"></a>Visual Studio 2010</h2><p>中文专业版：<a href="http://download.microsoft.com/download/1/4/3/143B7583-6225-474F-88D5-5811FBC470FD/X16-57473VS2010ProTrialCHS.iso">http://download.microsoft.com/download/1/4/3/143B7583-6225-474F-88D5-5811FBC470FD/X16-57473VS2010ProTrialCHS.iso</a><br>英文专业版：<a href="http://download.microsoft.com/download/4/0/E/40EFE5F6-C7A5-48F7-8402-F3497FABF888/X16-42555VS2010ProTrial1.iso">http://download.microsoft.com/download/4/0/E/40EFE5F6-C7A5-48F7-8402-F3497FABF888/X16-42555VS2010ProTrial1.iso</a></p><p>中文旗舰版：<a href="http://download.microsoft.com/download/E/0/4/E0427BB8-8490-4C7F-A05B-AFEA0FC3EA80/X16-60997VS2010UltimTrialCHS.iso">http://download.microsoft.com/download/E/0/4/E0427BB8-8490-4C7F-A05B-AFEA0FC3EA80/X16-60997VS2010UltimTrialCHS.iso</a><br>英文旗舰版：<a href="http://download.microsoft.com/download/2/4/7/24733615-AA11-42E9-8883-E28CDCA88ED5/X16-42552VS2010UltimTrial1.iso">http://download.microsoft.com/download/2/4/7/24733615-AA11-42E9-8883-E28CDCA88ED5/X16-42552VS2010UltimTrial1.iso</a></p><h3 id="SP1-更新包"><a href="#SP1-更新包" class="headerlink" title="SP1 更新包"></a>SP1 更新包</h3><p><a href="http://download.microsoft.com/download/E/B/A/EBA0A152-F426-47E6-9E3F-EFB686E3CA20/VS2010SP1dvd1.iso">http://download.microsoft.com/download/E/B/A/EBA0A152-F426-47E6-9E3F-EFB686E3CA20/VS2010SP1dvd1.iso</a></p><hr><h2 id="Visual-Studio-2008"><a href="#Visual-Studio-2008" class="headerlink" title="Visual Studio 2008"></a>Visual Studio 2008</h2><p>英文专业版：<a href="http://download.microsoft.com/download/8/1/d/81d3f35e-fa03-485b-953b-ff952e402520/VS2008ProEdition90dayTrialENUX1435622.iso">http://download.microsoft.com/download/8/1/d/81d3f35e-fa03-485b-953b-ff952e402520/VS2008ProEdition90dayTrialENUX1435622.iso</a><br>中文专业版：<a href="http://download.microsoft.com/download/e/7/7/e777851c-c1a4-4979-86b3-6886953b32e9/VS2008ProEdition90DayTrialCHSX1435983.iso">http://download.microsoft.com/download/e/7/7/e777851c-c1a4-4979-86b3-6886953b32e9/VS2008ProEdition90DayTrialCHSX1435983.iso</a> </p><h3 id="SP1-更新包-1"><a href="#SP1-更新包-1" class="headerlink" title="SP1 更新包"></a>SP1 更新包</h3><p>英文版：<a href="http://download.microsoft.com/download/a/3/7/a371b6d1-fc5e-44f7-914c-cb452b4043a9/VS2008SP1ENUX1512962.iso">http://download.microsoft.com/download/a/3/7/a371b6d1-fc5e-44f7-914c-cb452b4043a9/VS2008SP1ENUX1512962.iso</a><br>中文版：<a href="http://download.microsoft.com/download/1/9/d/19d22169-a4b2-455f-8c28-ed137bd91487/VS2008SP1CHSX1512981.iso">http://download.microsoft.com/download/1/9/d/19d22169-a4b2-455f-8c28-ed137bd91487/VS2008SP1CHSX1512981.iso</a> </p><hr><h2 id="Visual-Studio-2005"><a href="#Visual-Studio-2005" class="headerlink" title="Visual Studio 2005"></a>Visual Studio 2005</h2><p>英文专业版：<a href="http://download.microsoft.com/download/e/0/4/e04de840-8f6b-4fe5-ac3d-d3ad8e4c2443/En_vs_2005_Pro_90_Trial.img">http://download.microsoft.com/download/e/0/4/e04de840-8f6b-4fe5-ac3d-d3ad8e4c2443/En_vs_2005_Pro_90_Trial.img</a><br>中文专业版：<a href="http://download.microsoft.com/download/5/c/2/5c2840fd-8b03-492e-bd61-6fc2820b8ba3/chs_vs_2005_Pro_90_Trial.img">http://download.microsoft.com/download/5/c/2/5c2840fd-8b03-492e-bd61-6fc2820b8ba3/chs_vs_2005_Pro_90_Trial.img</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在.NET 2.0中使用C#新特性</title>
      <link href="/2022/04/15/16151315/"/>
      <url>/2022/04/15/16151315/</url>
      
        <content type="html"><![CDATA[<p>我们有时有这样的需求：在.NET Framework 2.0中用上较新的C#特性，以提高开发效率及幸福感。<br>现代C#的某些特性需要框架支持，而微软官方已经放弃对.NET Framework 2.0的支持，某些特性甚至完全不支持.NET Framework。<br>为了在.NET Framework 2.0中使用上新特性，可以使用第三方库。</p><p><strong>改变语言版本</strong></p><p>在开始介绍之前，我们最好将语言版本改至最高。<br>默认情况下，.NET Framework使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history#c-version-73">C# 7.3</a> 版本。为了用上最新的语言特性，我们编辑工程文件<code>.csproj</code>，添加<code>&lt;LangVersion&gt;</code>属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">LangVersion</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">LangVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>latest</code>意味着使用编译器支持的最高语言版本</p><blockquote><p>若要了解当前使用的语言版本，请在代码中添加 #error version（区分大小写）。 这样做可使编译器报告编译器错误 CS8304，并显示一条消息，其中包含正在使用的编译器版本和当前选择的语言版本。</p></blockquote><hr><h2 id="NET-Framework-3-5-特性"><a href="#NET-Framework-3-5-特性" class="headerlink" title=".NET Framework 3.5 特性"></a>.NET Framework 3.5 特性</h2><h3 id="无参数Action委托"><a href="#无参数Action委托" class="headerlink" title="无参数Action委托"></a>无参数Action委托</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.action?view=netframework-3.5">https://docs.microsoft.com/zh-cn/dotnet/api/system.action?view=netframework-3.5</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a><br>解决方案2：<a href="https://www.nuget.org/packages/NetLegacySupport.Action/">NetLegacySupport.Action</a></p><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a><br>解决方案2：<a href="https://www.nuget.org/packages/DevLib.Legacy">DevLib.Legacy</a></p><hr><h2 id="NET-Framework-4-0-特性"><a href="#NET-Framework-4-0-特性" class="headerlink" title=".NET Framework 4.0 特性"></a>.NET Framework 4.0 特性</h2><h3 id="Tuple类"><a href="#Tuple类" class="headerlink" title="Tuple类"></a>Tuple类</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.tuple?view=netframework-4.0">https://docs.microsoft.com/zh-cn/dotnet/api/system.tuple?view=netframework-4.0</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a><br>解决方案2：<a href="https://www.nuget.org/packages/NetLegacySupport.Tuple">NetLegacySupport.Tuple</a></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>介绍：<br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadlocal-1">https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadlocal-1</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a></p><hr><h2 id="NET-Framework-4-7-特性"><a href="#NET-Framework-4-7-特性" class="headerlink" title=".NET Framework 4.7 特性"></a>.NET Framework 4.7 特性</h2><h3 id="ValueTuple-结构"><a href="#ValueTuple-结构" class="headerlink" title="ValueTuple 结构"></a>ValueTuple 结构</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.valuetuple?view=netframework-4.7">https://docs.microsoft.com/zh-cn/dotnet/api/system.valuetuple?view=netframework-4.7</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-tuples">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-tuples</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a><br>解决方案2：<a href="https://www.nuget.org/packages/Portable.System.ValueTuple">Portable.System.ValueTuple</a></p><hr><h2 id="不支持-NET-Framework-的特性"><a href="#不支持-NET-Framework-的特性" class="headerlink" title="不支持 .NET Framework 的特性"></a>不支持 .NET Framework 的特性</h2><h3 id="Range-结构"><a href="#Range-结构" class="headerlink" title="Range 结构"></a>Range 结构</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.range">https://docs.microsoft.com/zh-cn/dotnet/api/system.range</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a></p><h3 id="Index-结构"><a href="#Index-结构" class="headerlink" title="Index 结构"></a>Index 结构</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.index">https://docs.microsoft.com/zh-cn/dotnet/api/system.index</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a></p><h3 id="仅初始化属性（Init-only-properties）"><a href="#仅初始化属性（Init-only-properties）" class="headerlink" title="仅初始化属性（Init-only properties）"></a>仅初始化属性（Init-only properties）</h3><p>介绍：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9#init-only-setters">https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9#init-only-setters</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/init">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/init</a></p><p>解决方案1：<a href="https://www.nuget.org/packages/Theraot.Core">Theraot.Core</a><br>解决方案2：<a href="https://www.nuget.org/packages/IsExternalInit">IsExternalInit</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/configure-language-version">C# 语言版本控制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译时检测.NET Framework框架版本</title>
      <link href="/2022/04/15/16150088/"/>
      <url>/2022/04/15/16150088/</url>
      
        <content type="html"><![CDATA[<p>在新的.NET框架下，官方自带了一些用于判断框架版本的条件变量（<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives">C#预处理器指令</a>）</p><p>但是在老的编译系统上没有此功能，所以只能模拟实现。</p><p>终于在 stackoverflow 上找到了答案，思路很不错，在<code>.csproj</code>工程文件中利用框架的<code>System.Version</code>去动态比较版本号，然后定义相关的条件变量。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在原答案的基础上修改了一下，兼容了微软官方的条件变量。</p><p>创建一个新文件<code>FrameworkSymbols.Common.prop</code>，内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.8&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET48;NET48_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.7.2&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET472;NET472_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.7.1&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET471;NET471_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.7&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET47;NET47_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.6.2&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET462;NET462_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.6.1&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET461;NET461_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.6&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET46;NET46_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.5.2&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET452;NET452_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.5.1&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET451;NET451_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.5&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET45;NET45_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;4.0&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET40;NET40_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;3.5&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET35;NET35_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;3.0&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET30;NET30_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefineConstants</span> <span class="attr">Condition</span>=<span class="string">&quot;$([System.Version]::Parse(&#x27;$(TargetFrameworkVersion.Substring(1))&#x27;).CompareTo($([System.Version]::Parse(&#x27;2.0&#x27;)))) <span class="symbol">&amp;gt;</span>= 0&quot;</span>&gt;</span>$(DefineConstants);NET20;NET20_OR_GREATER<span class="tag">&lt;/<span class="name">DefineConstants</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在工程文件中导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;FrameworkSymbols.Common.prop&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> NET20</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;NET20&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NET35_OR_GREATER</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;NET35_OR_GREATER&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/3436526/detect-target-framework-version-at-compile-time">Detect target framework version at compile time</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives">C#预处理器指令</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Framework 安装包下载地址</title>
      <link href="/2022/04/07/netfx-installer/"/>
      <url>/2022/04/07/netfx-installer/</url>
      
        <content type="html"><![CDATA[<p>部分下载地址已经失效，可以尝试用迅雷下载。</p><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><table><thead><tr><th>版本</th><th>离线安装程序</th><th>语言包</th><th>发行说明</th><th>备注</th></tr></thead><tbody><tr><td>4.8.1</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2203305">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=2203215">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net481/dotnet481-changes.md">Release notes</a></td><td>要求 Win10 21H2 及以上系统</td></tr><tr><td>4.8</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2088631">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=2053984">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net48/dotnet48-changes.md">Release notes</a></td><td>最后一个支持 Win7 的版本</td></tr><tr><td>4.7.2</td><td><a href="https://go.microsoft.com/fwlink/?linkid=863265">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=863258">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net472/dotnet472-changes.md">Release notes</a></td><td></td></tr><tr><td>4.7.1</td><td><a href="https://go.microsoft.com/fwlink/?LinkID=2099383">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=852086">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net471/dotnet471-changes.md">Release notes</a></td><td></td></tr><tr><td>4.7</td><td><a href="https://download.microsoft.com/download/D/D/3/DD35CC25-6E9C-484B-A746-C5BE0C923290/NDP47-KB3186497-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=825305">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net47/dotnet47-changes.md">Release notes</a></td><td></td></tr><tr><td>4.6.2</td><td><a href="https://download.microsoft.com/download/F/9/4/F942F07D-F26F-4F30-B4E3-EBD54FABA377/NDP462-KB3151800-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=780603">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net462/dotnet462-changes.md">Release notes</a></td><td></td></tr><tr><td>4.6.1</td><td><a href="https://download.microsoft.com/download/E/4/1/E4173890-A24A-4936-9FC9-AF930FE3FA40/NDP461-KB3102436-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=671731">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net461/dotnet461-changes.md">Release notes</a></td><td></td></tr><tr><td>4.6</td><td><a href="https://download.microsoft.com/download/C/3/A/C3A5200B-D33C-47E9-9D70-2F7C65DAAD94/NDP46-KB3045557-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=528315">CHS</a></td><td><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net46/dotnet46-changes.md">Release notes</a></td><td></td></tr><tr><td>4.5.2</td><td><a href="https://download.microsoft.com/download/E/2/1/E21644B5-2DF2-47C2-91BD-63C560427900/NDP452-KB2901907-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=328839">CHS</a></td><td><a href="https://devblogs.microsoft.com/dotnet/announcing-the-net-framework-4-5-2/">Announcing the .NET Framework 4.5.2</a></td><td></td></tr><tr><td>4.5.1</td><td><a href="https://download.microsoft.com/download/1/6/7/167F0D79-9317-48AE-AEDB-17120579F8E2/NDP451-KB2858728-x86-x64-AllOS-ENU.exe">Full</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=321330">CHS</a></td><td></td><td></td></tr><tr><td>4.5</td><td><a href="https://download.microsoft.com/download/b/a/4/ba4a7e71-2906-4b2d-a0e1-80cf16844f5f/dotnetfx45_full_x86_x64.exe">Full</a></td><td><a href="https://download.microsoft.com/download/E/3/B/E3B0BB03-0E05-4DA1-A244-124E0A2E5910/chs_netfx/x64/dotnetfx45lp_full_x86_x64zh-hans.exe">CHS</a></td><td></td><td></td></tr><tr><td>4.0.3</td><td><a href="https://download.microsoft.com/download/3/3/9/3396A3CA-BFE8-4C9B-83D3-CADAE72C17BE/NDP40-KB2600211-x86.exe">x86</a>、<a href="https://download.microsoft.com/download/3/3/9/3396A3CA-BFE8-4C9B-83D3-CADAE72C17BE/NDP40-KB2600211-x86-x64.exe">Full</a></td><td></td><td><a href="https://devblogs.microsoft.com/dotnet/update-4-0-3-for-the-microsoft-net-framework-4/">Update 4.0.3 for the Microsoft .NET Framework 4</a></td><td><a href="http://support.microsoft.com/help/2600211">KB2600211</a>。需要先安装 v4.0.0。最后一个支持 XP 的版本</td></tr><tr><td>4.0 Client</td><td><a href="https://download.microsoft.com/download/3/1/8/318161B8-9874-48E4-BB38-9EB82C5D6358/dotNetFx40_Client_x86.exe">x86</a>、<a href="https://download.microsoft.com/download/a/f/6/af62a6d3-d867-44b1-b00a-37790c59a8bc/dotnetfx40_client_x86_x64.exe">Full</a></td><td></td><td></td><td></td></tr><tr><td>4.0</td><td><a href="https://download.microsoft.com/download/5/6/4/5641DA81-E6FA-4550-9F80-A1D862D9CFAA/dotNetFx40_Full_x86.exe">x86</a>、<a href="https://download.microsoft.com/download/9/5/A/95A9616B-7A37-4AF6-BC36-D6EA96C8DAAE/dotNetFx40_Full_x86_x64.exe">Full</a></td><td><a href="https://download.microsoft.com/download/2/9/7/29765F48-D253-4691-92FF-F95CA714D3DA/dotNetFx40LP_Full_x86_x64zh-Hans.exe">CHS</a></td><td></td><td></td></tr><tr><td>3.5 SP1</td><td><a href="https://download.microsoft.com/download/2/0/E/20E90413-712F-438C-988E-FDAA79A8AC3D/dotnetfx35.exe">下载</a></td><td><a href="https://download.microsoft.com/download/7/7/B/77B96978-C805-4674-A9B0-43351E86B41F/dotnetfx35langpack_x86zh-CHS.exe">x86-CHS</a>、<a href="https://download.microsoft.com/download/7/7/B/77B96978-C805-4674-A9B0-43351E86B41F/dotnetfx35langpack_x64zh-CHS.exe">x64-CHS</a></td><td></td><td></td></tr><tr><td>3.5 Client</td><td><a href="https://download.microsoft.com/download/c/d/c/cdc0f321-4f72-4a08-9bac-082f3692ecd9/DotNetFx35Client.exe">Full</a></td><td></td><td></td><td></td></tr><tr><td>3.5</td><td><a href="https://download.microsoft.com/download/6/0/f/60fc5854-3cb8-4892-b6db-bd4f42510f28/dotnetfx35.exe">下载</a></td><td><a href="http://go.microsoft.com/fwlink/?linkid=92417">CHS</a></td><td></td><td></td></tr><tr><td>3.0 SP1</td><td><a href="https://download.microsoft.com/download/8/F/E/8FEEE89D-9E4F-4BA3-993E-0FFEA8E21E1B/NetFx30SP1_x86.exe">x86</a>、<a href="https://download.microsoft.com/download/E/C/A/ECA7A7F5-2F36-40D8-AC72-8DC6FE3B48D9/NetFx30SP1_x64.exe">x64</a></td><td><a href="https://download.microsoft.com/download/5/B/9/5B9CB205-5A7E-494A-9361-189C5074A352/NetFx30SP1_x86zh-CHS.exe">x86</a>、<a href="https://download.microsoft.com/download/5/B/9/5B9CB205-5A7E-494A-9361-189C5074A352/NetFx30SP1_x64zh-CHS.exe">x64</a></td><td></td><td></td></tr><tr><td>3.0</td><td><a href="http://download.microsoft.com/download/3/F/0/3F0A922C-F239-4B9B-9CB0-DF53621C57D9/dotnetfx3.exe">x86</a>、<a href="http://download.microsoft.com/download/3/F/0/3F0A922C-F239-4B9B-9CB0-DF53621C57D9/dotnetfx3_x64.exe">x64</a></td><td><a href="http://download.microsoft.com/download/a/9/a/a9a5f57a-fd2d-44e8-ba87-2f11c1e102bc/dotnetfx3langpackzh-CHS.exe">x86</a>、<a href="http://download.microsoft.com/download/2/2/5/2258AB80-89B9-4323-8DCA-CA59FF2553EC/dotnetfx3langpack_x64zh-CHS.exe">x64</a></td><td></td><td></td></tr><tr><td>2.0 SP2</td><td><a href="https://download.microsoft.com/download/c/6/e/c6e88215-0178-4c6c-b5f3-158ff77b1f38/NetFx20SP2_x86.exe">x86</a>、<a href="https://download.microsoft.com/download/c/6/e/c6e88215-0178-4c6c-b5f3-158ff77b1f38/NetFx20SP2_x64.exe">x64</a></td><td><a href="https://download.microsoft.com/download/E/1/C/E1CC8D28-99EE-402F-A2E2-375D1BE9DE6B/netfx20sp2_x86zh-CHS.exe">x86</a>、<a href="https://download.microsoft.com/download/A/7/5/A7528991-22C6-4194-A048-741156AB6549/netfx20sp2_x64zh-CHS.exe">x64</a></td><td></td><td></td></tr><tr><td>2.0 SP1</td><td><a href="https://download.microsoft.com/download/0/8/C/08C19FA4-4C4F-4FFB-9D6C-150906578C9E/NetFx20SP1_x86.exe">x86</a>、<a href="https://download.microsoft.com/download/9/8/6/98610406-C2B7-45A4-BDC3-9DB1B1C5F7E2/NetFx20SP1_x64.exe">x64</a></td><td>-</td><td></td><td></td></tr><tr><td>2.0</td><td><a href="https://download.microsoft.com/download/5/6/7/567758a3-759e-473e-bf8f-52154438565a/dotnetfx.exe">CHS(x86)</a>、<a href="https://download.microsoft.com/download/a/3/f/a3f1bf98-18f3-4036-9b68-8e6de530ce0a/NetFx64.exe">ENU(x64)</a></td><td>-</td><td></td><td></td></tr><tr><td>1.1 SP1</td><td><a href="https://download.microsoft.com/download/8/b/4/8b4addd8-e957-4dea-bdb8-c4e00af5b94b/NDP1.1sp1-KB867460-X86.exe">x86</a></td><td></td><td></td><td></td></tr><tr><td>1.1</td><td><a href="https://download.microsoft.com/download/7/b/9/7b90644d-1af0-42b9-b76d-a2770319a568/dotnetfx.exe">CHS</a>、<a href="https://download.microsoft.com/download/a/a/c/aac39226-8825-44ce-90e3-bf8203e74006/dotnetfx.exe">ENU</a></td><td></td><td></td><td></td></tr><tr><td>1.0a</td><td><a href="https://download.microsoft.com/download/c/3/5/c35a549e-1d9d-4efd-8da6-12ca5e360273/dotnetredist.exe">CHS</a></td><td></td><td></td><td></td></tr></tbody></table><h2 id="开发包"><a href="#开发包" class="headerlink" title="开发包"></a>开发包</h2><table><thead><tr><th>版本</th><th>离线安装程序</th><th>语言包</th><th>备注</th></tr></thead><tbody><tr><td>4.8.1</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2203306">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=2203214">CHS</a></td><td></td></tr><tr><td>4.8</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2088517">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=2085167">CHS</a></td><td></td></tr><tr><td>4.7.2</td><td><a href="https://go.microsoft.com/fwlink/?linkid=874338">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=863261">CHS</a></td><td></td></tr><tr><td>4.7.1</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2099382">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=852102">CHS</a></td><td></td></tr><tr><td>4.7</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2099465">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=825318">CHS</a></td><td></td></tr><tr><td>4.6.2</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2099466">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=780616">CHS</a></td><td></td></tr><tr><td>4.6.1</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2099470">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=690705">CHS</a></td><td></td></tr><tr><td>4.6</td><td><a href="https://go.microsoft.com/fwlink/?linkid=2099469">下载</a></td><td><a href="https://go.microsoft.com/fwlink/?LinkId=615276">CHS</a></td><td></td></tr><tr><td>4.5.2</td><td><a href="https://go.microsoft.com/fwlink/?linkid=397673">下载</a></td><td>-</td><td></td></tr><tr><td>4.5.1</td><td><a href="https://go.microsoft.com/fwlink/?linkid=321335">下载</a></td><td>-</td><td></td></tr><tr><td>4.5.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/03097ab1-852b-45d3-abbb-c0bcf640cd6f/4a22b5f5449d1e1182e17c0348b159ad/netfx45_dtp.cab">netfx45_dtp.cab</a>、<a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/ccc6eff9c0f4488e8f3bf5d1237684cbb67ff381b9784f9f7f653504a5d74ee2/netfx45_dtp.msi">netfx45_dtp.msi</a></td><td>-</td><td>安装命令：netfx45_dtp.msi EXTUI&#x3D;1</td></tr><tr><td>4.0.3</td><td><a href="https://download.microsoft.com/download/3/B/2/3B229A81-1413-45C6-9BFE-259D90606FD6/netfx_403mtpack.exe">下载</a></td><td></td><td><a href="http://support.microsoft.com/help/2600213">KB2600213</a>。更新包，需要先安装 v4.0.0</td></tr><tr><td>4.0.0</td><td><a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/db247b7cd2a31606711c71b2b8205a48a305537c5e79d85117ed2785c8392256/netfx_dtp.cab">netfx_dtp.cab</a>、<a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/0d167e6469622c73eaaf82567d9cef5d8cba3a819abf36e32f1d463891cf7bda/netfx_dtp.msi">netfx_dtp.msi</a></td><td>-</td><td>安装命令：netfx_dtp.msi EXTUI&#x3D;1</td></tr><tr><td>2.0</td><td><a href="https://download.microsoft.com/download/c/4/b/c4b15d7d-6f37-4d5a-b9c6-8f07e7d46635/setup.exe">ENU</a>、<a href="https://download.microsoft.com/download/b/e/a/bea35549-7804-4e28-beef-a7d9d1675f4c/setup.exe">CHS</a></td><td></td><td></td></tr><tr><td>1.1</td><td><a href="https://download.microsoft.com/download/5/2/0/5202f918-306e-426d-9637-d7ee26fbe507/setup.exe">ENU</a>、<a href="https://download.microsoft.com/download/0/f/e/0fecf85c-fb50-4ca9-adf2-c4be7ec9b454/setup.exe">CHS</a></td><td></td><td></td></tr></tbody></table><h2 id="关于-NET-Framework-v4-0-开发包"><a href="#关于-NET-Framework-v4-0-开发包" class="headerlink" title="关于 .NET Framework v4.0 开发包"></a>关于 .NET Framework v4.0 开发包</h2><p>v4.0 特殊一些，没有提供单个的开发包安装程序。最后仅在 VS2019 中提供安装选项，而 VS2022 中已经不提供安装选项了。<br>所以我们只需要得知 VS2019 是从哪里下载的即可，利用安装程序的下载功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_Professional.exe --layout D:\VSLayout --lang zh-CN --add Microsoft.Net.Component.4.TargetingPack</span><br></pre></td></tr></table></figure><p>控制台窗口中显示了下载地址：<br><a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/db247b7cd2a31606711c71b2b8205a48a305537c5e79d85117ed2785c8392256/netfx_dtp.cab">https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/db247b7cd2a31606711c71b2b8205a48a305537c5e79d85117ed2785c8392256/netfx_dtp.cab</a><br><a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/0d167e6469622c73eaaf82567d9cef5d8cba3a819abf36e32f1d463891cf7bda/netfx_dtp.msi">https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/0d167e6469622c73eaaf82567d9cef5d8cba3a819abf36e32f1d463891cf7bda/netfx_dtp.msi</a><br>然后通过命令<code>netfx_dtp.msi EXTUI=1</code>安装。</p><h2 id="关于-NET-Framework-v4-5-开发包"><a href="#关于-NET-Framework-v4-5-开发包" class="headerlink" title="关于 .NET Framework v4.5 开发包"></a>关于 .NET Framework v4.5 开发包</h2><p>同 v4.0 一样，没有单独的安装程序，需要从 VS2019 安装程序中抓取连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_Professional.exe --layout D:\VSLayout --lang zh-CN --add Microsoft.Net.Component.4.5.TargetingPack</span><br></pre></td></tr></table></figure><p><a href="https://download.visualstudio.microsoft.com/download/pr/03097ab1-852b-45d3-abbb-c0bcf640cd6f/4a22b5f5449d1e1182e17c0348b159ad/netfx45_dtp.cab">https://download.visualstudio.microsoft.com/download/pr/03097ab1-852b-45d3-abbb-c0bcf640cd6f/4a22b5f5449d1e1182e17c0348b159ad/netfx45_dtp.cab</a><br><a href="https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/ccc6eff9c0f4488e8f3bf5d1237684cbb67ff381b9784f9f7f653504a5d74ee2/netfx45_dtp.msi">https://download.visualstudio.microsoft.com/download/pr/aa968ee4-54e7-4773-a9a5-bd09d7ca9924/ccc6eff9c0f4488e8f3bf5d1237684cbb67ff381b9784f9f7f653504a5d74ee2/netfx45_dtp.msi</a></p><p>然后通过命令<code>netfx45_dtp.msi EXTUI=1</code>安装。</p><h2 id="其他安装方法"><a href="#其他安装方法" class="headerlink" title="其他安装方法"></a>其他安装方法</h2><ol><li>安装低版本的 Visual Studio，其中包含对应版本的的开发包。</li><li>从<code>nuget</code>中提取文件并解压到本地，参考 <a href="https://stackoverflow.com/questions/70022194">这篇帖子</a>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Dykimy/p/16051670.html">VS2022 安装.NET 3.5&#x2F;.NET 4&#x2F;.NET 4.5&#x2F;.NET 4.5.1目标包的方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 工具软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态壁纸实现原理</title>
      <link href="/2021/09/25/RMrCXIzEz/"/>
      <url>/2021/09/25/RMrCXIzEz/</url>
      
        <content type="html"><![CDATA[<h2 id="桌面窗口层次关系"><a href="#桌面窗口层次关系" class="headerlink" title="桌面窗口层次关系"></a>桌面窗口层次关系</h2><p>桌面窗口层次是这样的<br><img src="/images/1632581286029.png"></p><h2 id="检查系统是否开启了Aero"><a href="#检查系统是否开启了Aero" class="headerlink" title="检查系统是否开启了Aero"></a>检查系统是否开启了Aero</h2><p>动态壁纸技术需要系统开启Aero才行，原因下面会讲到。<br>检测系统是否开启了Aero可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/dwmapi/nf-dwmapi-dwmiscompositionenabled">DwmIsCompositionEnabled</a> 函数。<br>只有在Win7及以前的系统上需要检测，Win8后这个函数总是返回 TRUE。</p><h2 id="未公开的消息"><a href="#未公开的消息" class="headerlink" title="未公开的消息"></a>未公开的消息</h2><p>桌面窗口内部有一个神秘的消息：<code>WM_USER + 300</code>，数值为<code>0x52C</code>。<br>它收到这个消息后就会在其上创建两个窗口，并将图标层移动上去，然后窗口层次就变成这样了<br><img src="/images/1632583220300.png"><br>如果系统没有开启Aero，它收到消息后就不会创建这两个窗口，也就无法实现动态壁纸了，这就是系统必须开启Aero的原因。</p><h2 id="创建壁纸窗口"><a href="#创建壁纸窗口" class="headerlink" title="创建壁纸窗口"></a>创建壁纸窗口</h2><p>最后一步就是创建一个Win32窗口了，然后将其父窗口设置为上面提到的Worker窗口（靠下面的那一个）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">createWindow</span><span class="params">(HWND hParent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取父窗口尺寸</span></span><br><span class="line">RECT rect;</span><br><span class="line"><span class="built_in">GetWindowRect</span>(hParent, &amp;rect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态壁纸窗口并挂到&quot;Worker&quot;窗口下</span></span><br><span class="line">HWND hWnd = <span class="built_in">CreateWindowExW</span>(<span class="number">0</span>, CLASSNAME, <span class="string">L&quot;DynamicWallpaper&quot;</span>, WS_CHILDWINDOW, <span class="number">0</span>, <span class="number">0</span>, rect.right, rect.bottom, hParent, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hWnd, SW_SHOWNOACTIVATE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hWnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个细节要注意，当动态壁纸窗口销毁时需要将父窗口刷新一下，因为父窗口的扩展样式用到了<code>WS_EX_TRANSPARENT</code>，这是一个透明窗口，如果不刷新的话，动态壁纸窗口的残影会一直留在桌面上。<br>最简单的刷新办法是隐藏它，我们在窗口消息过程中处理即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 上次隐藏了，这次再显示出来</span></span><br><span class="line">HWND hParent = <span class="built_in">GetParent</span>(hWnd);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hParent, SW_SHOWNOACTIVATE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 隐藏父窗口，避免残影</span></span><br><span class="line">HWND hParent = <span class="built_in">GetParent</span>(hWnd);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hParent, SW_HIDE);</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, uMsg, wParam, lparam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是在窗口上播放一个短视频了。还有的人甚至在上面放置浏览器，这不是一个好注意，浏览器太占用内存资源，会比较卡。<br>至此，一个简单的动态壁纸功能就实现了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果要使软件更加完美，还需要考虑以下问题<br>1、当桌面窗口大小变化时（修改分辨率），壁纸也要跟着变化。<br>2、用户执行全屏程序时，应停止播放动态壁纸以便节省系统资源。<br>3、交互功能，一般不用实现交互功能，如果要做，可以考虑HOOK、消息钩子的手段。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/37877070">如何实现一个 windows 桌面动态壁纸</a><br><a href="https://zhuanlan.zhihu.com/p/45204045">自定义·自制HTML壁纸</a><br><a href="https://www.codeproject.com/Articles/856020/Draw-Behind-Desktop-Icons-in-Windows-plus">Draw Behind Desktop Icons in Windows 8+</a><br><a href="https://stackoverflow.com/questions/56132584/draw-on-windows-10-wallpaper-in-c">Draw on Windows 10 wallpaper in C++</a><br><a href="https://stackoverflow.com/questions/1683791/drawing-on-the-desktop-background-as-wallpaper-replacement-windows-c">Drawing on the desktop background as wallpaper replacement (Windows&#x2F;C#)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 原版系统镜像</title>
      <link href="/2021/08/21/windows-iso/"/>
      <url>/2021/08/21/windows-iso/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-8-1"><a href="#Windows-8-1" class="headerlink" title="Windows 8.1"></a>Windows 8.1</h2><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ul><li><p>Windows 8.1 Enterprise with Update (x86)<br><a href="ed2k://|file|cn_windows_8.1_enterprise_with_update_x86_dvd_6050645.iso|3199901696|0209A1FDE82A5AC7A248B4CA3F860F2B|/">cn_windows_8.1_enterprise_with_update_x86_dvd_6050645.iso</a></p></li><li><p>Windows 8.1 Enterprise with Update (x64)<br><a href="ed2k://|file|cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso|4317065216|AC8215A13817CC0EC4EA42E5C92E88B7|/">cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso</a></p></li><li><p>Windows 8.1 Pro VL with Update (x86)<br><a href="ed2k://|file|cn_windows_8.1_pro_vl_with_update_x86_dvd_6050910.iso|3200301056|B078A986993B7EDD474FD09EB6FF7E1B|/">cn_windows_8.1_pro_vl_with_update_x86_dvd_6050910.iso</a></p></li><li><p>Windows 8.1 Pro VL with Update (x64)<br><a href="ed2k://|file|cn_windows_8.1_pro_vl_with_update_x64_dvd_6050873.iso|4317507584|B0888275B5BD40E67D3F178B84B9A874|/">cn_windows_8.1_pro_vl_with_update_x64_dvd_6050873.iso</a></p></li><li><p>Windows 8.1 Professional VL with Update (x86)<br><a href="ed2k://|file|cn_windows_8.1_professional_vl_with_update_x86_dvd_4048630.iso|3086659584|41CAAB5DAC5643F6E0048576D609C19A|/">cn_windows_8.1_professional_vl_with_update_x86_dvd_4048630.iso</a></p></li><li><p>Windows 8.1 Professional VL with Update (x64)<br><a href="ed2k://|file|cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso|4136626176|4D2363F9E06BFD50A78B1E6464702959|/">cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso</a></p></li></ul><h3 id="RTM"><a href="#RTM" class="headerlink" title="RTM"></a>RTM</h3><ul><li><p>Windows 8.1 Pro VL (x86)<br><a href="ed2k://|file|cn_windows_8_1_pro_vl_x86_dvd_2972620.iso|3049981952|5B396C3A0BA99617647D9AFE8403AFA5|/">cn_windows_8_1_pro_vl_x86_dvd_2972620.iso</a></p></li><li><p>Windows 8.1 Pro VL (x64)<br><a href="ed2k://|file|cn_windows_8_1_pro_vl_x64_dvd_2971907.iso|4032598016|1FDA520B3E8880E2FB00B20439E0826E|/">cn_windows_8_1_pro_vl_x64_dvd_2971907.iso</a></p></li><li><p>Windows 8.1 Enterprise (x86)<br><a href="ed2k://|file|cn_windows_8_1_enterprise_x86_dvd_2972257.iso|3050842112|6B60ABF8282F943FE92327463920FB67|/">cn_windows_8_1_enterprise_x86_dvd_2972257.iso</a></p></li><li><p>Windows 8.1 Enterprise (x64)<br><a href="ed2k://|file|cn_windows_8_1_enterprise_x64_dvd_2971863.iso|4039327744|08BAF18320B8FFC58D4C35BCC7A32012|/">cn_windows_8_1_enterprise_x64_dvd_2971863.iso</a></p></li></ul><hr><h2 id="Windows-8"><a href="#Windows-8" class="headerlink" title="Windows 8"></a>Windows 8</h2><ul><li><p>Windows 8 (x86)<br><a href="ed2k://|file|cn_windows_8_x86_dvd_915414.iso|2679801856|9AF10141BFD61BC66D9D6459758D7749|/">cn_windows_8_x86_dvd_915414.iso</a></p></li><li><p>Windows 8 (x64)<br><a href="ed2k://|file|cn_windows_8_x64_dvd_915407.iso|3652950016|5C7F8C212BD3A1827866563773A431C2|/">cn_windows_8_x64_dvd_915407.iso</a></p></li><li><p>Windows 8 Pro VL (x86)<br><a href="ed2k://|file|cn_windows_8_pro_vl_x86_dvd_917720.iso|2595137536|E87CEF7B8B4EFB12B0A7397795209301|/">cn_windows_8_pro_vl_x86_dvd_917720.iso</a></p></li><li><p>Windows 8 Pro VL (x64)<br><a href="ed2k://|file|cn_windows_8_pro_vl_x64_dvd_917773.iso|3558014976|7956620A80428F37D4F2989CB5CF3B5A|/">cn_windows_8_pro_vl_x64_dvd_917773.iso</a></p></li><li><p>Windows 8 Enterprise (x86)<br><a href="ed2k://|file|cn_windows_8_enterprise_x86_dvd_917682.iso|2597502976|7B6541942A16EB54BC81E84558DF09DF|/">cn_windows_8_enterprise_x86_dvd_917682.iso</a></p></li><li><p>Windows 8 Enterprise (x64)<br><a href="ed2k://|file|cn_windows_8_enterprise_x64_dvd_917570.iso|3560837120|8CAE8064C4B8F9CD84941B4FF4A34722|/">cn_windows_8_enterprise_x64_dvd_917570.iso</a></p></li></ul><hr><h2 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h2><h3 id="Windows-Thin-PC"><a href="#Windows-Thin-PC" class="headerlink" title="Windows Thin PC"></a>Windows Thin PC</h3><p><a href="ed2k://|file|en_windows_thin_pc_x86_697681.iso|1576980480|2D0E6A048EB3F314F556B4F0834A95E2|/">en_windows_thin_pc_x86_697681.iso</a><br><a href="http://download.microsoft.com/download/C/D/7/CD789C98-6C1A-43D6-87E9-F7FDE3806950/ThinPC_110415_EVAL_x86fre.iso">ThinPC_110415_EVAL_x86fre.iso</a><br>两个文件一样。</p><p>简体中文语言包：<a href="https://download.microsoft.com/download/8/6/1/8616D57C-1163-45FB-832A-15FA60571002/SP1/Chinese%20(Simplified)%20Language%20Pack%20-%20Windows%20Embedded%20Standard%207%20SP1/lp.cab">lp.cab</a></p><h3 id="Service-Pack-1"><a href="#Service-Pack-1" class="headerlink" title="Service Pack 1"></a>Service Pack 1</h3><ul><li><p>Windows 7 Enterprise with Service Pack 1<br><a href="ed2k://|file|cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso|3265574912|E9DB2607EA3B3540F3FE2E388F8C53C4|/">cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso</a></p></li><li><p>Windows 7 Enterprise with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_enterprise_with_sp1_x86_dvd_u_677716.iso|2502856704|B3C25EA4DD88D7E54F22D3C3E78C410B|/">cn_windows_7_enterprise_with_sp1_x86_dvd_u_677716.iso</a></p></li><li><p>Windows 7 Ultimate with Service Pack 1 (x64)<br><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/">cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso</a></p></li><li><p>Windows 7 Ultimate with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/">cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso</a></p></li><li><p>Windows 7 Professional with Service Pack 1, VL Build (x64)<br><a href="ed2k://|file|cn_windows_7_professional_with_sp1_vl_build_x64_dvd_u_677816.iso|3266004992|5A52F4CCEFA71797D58389B397038B2F|/">cn_windows_7_professional_with_sp1_vl_build_x64_dvd_u_677816.iso</a></p></li><li><p>Windows 7 Professional with Service Pack 1, VL Build (x86)<br><a href="ed2k://|file|cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso|2502909952|935E5B4B754527BE3C238FA6ABDD9B86|/">cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso</a></p></li><li><p>Windows 7 Professional with Service Pack 1 (x64)<br><a href="ed2k://|file|cn_windows_7_professional_with_sp1_x64_dvd_u_677031.iso|3420557312|430BEDC0F22FA18001F717F7AF08C9D5|/">cn_windows_7_professional_with_sp1_x64_dvd_u_677031.iso</a></p></li><li><p>Windows 7 Professional with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_professional_with_sp1_x86_dvd_u_677162.iso|2653276160|08F65018BD9B5BC8D77C1C7C5615A329|/">cn_windows_7_professional_with_sp1_x86_dvd_u_677162.iso</a></p></li><li><p>Windows 7 Home Premium with Service Pack 1 (x64)<br><a href="ed2k://|file|cn_windows_7_home_premium_with_sp1_x64_dvd_u_676691.iso|3420557312|1A3CF44F3F5E0BE9BBC1A938706A3471|/">cn_windows_7_home_premium_with_sp1_x64_dvd_u_676691.iso</a></p></li><li><p>Windows 7 Home Premium with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_home_premium_with_sp1_x86_dvd_u_676770.iso|2653276160|A8E8BD4421174DF34BD14D60750B3CDB|/">cn_windows_7_home_premium_with_sp1_x86_dvd_u_676770.iso</a></p></li><li><p>Windows 7 Home Basic with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_home_basic_with_sp1_x86_dvd_u_676500.iso|2653276160|843E7A78F2126FAC726CF5342710082D|/">cn_windows_7_home_basic_with_sp1_x86_dvd_u_676500.iso</a></p></li><li><p>Windows 7 Home Basic with Service Pack 1 (x86) - DVD (English)<br><a href="ed2k://|file|en_windows_7_home_basic_with_sp1_x86_dvd_u_676470.iso|2564476928|D81F244E43E2341765653AB0A52AE7B8|/">en_windows_7_home_basic_with_sp1_x86_dvd_u_676470.iso</a></p></li><li><p>Windows 7 Starter with Service Pack 1 (x86)<br><a href="ed2k://|file|cn_windows_7_starter_with_sp1_x86_dvd_u_678536.iso|2653276160|B0A788EA28B2491B4587A561A8CB5B19|/">cn_windows_7_starter_with_sp1_x86_dvd_u_678536.iso</a></p></li></ul><h3 id="RTM-1"><a href="#RTM-1" class="headerlink" title="RTM"></a>RTM</h3><ul><li><p>Windows 7 Enterprise (x64)<br><a href="ed2k://|file|cn_windows_7_enterprise_x64_dvd_x15-70741.iso|3203516416|876DCF115C2EE28D74B178BE1A84AB3B|/">cn_windows_7_enterprise_x64_dvd_x15-70741.iso</a></p></li><li><p>Windows 7 Enterprise (x86)<br><a href="ed2k://|file|cn_windows_7_enterprise_x86_dvd_x15-70737.iso|2465783808|41ABFA74E57353B2F35BC33E56BD5202|/">cn_windows_7_enterprise_x86_dvd_x15-70737.iso</a></p></li><li><p>Windows 7 Ultimate (x64)<br><a href="ed2k://|file|cn_windows_7_ultimate_x64_dvd_x15-66043.iso|3341268992|7DD7FA757CE6D2DB78B6901F81A6907A|/">cn_windows_7_ultimate_x64_dvd_x15-66043.iso</a></p></li><li><p>Windows 7 Ultimate (x86)<br><a href="ed2k://|file|cn_windows_7_ultimate_x86_dvd_x15-65907.iso|2604238848|D6F139D7A45E81B76199DDCCDDC4B509|/">cn_windows_7_ultimate_x86_dvd_x15-65907.iso</a></p></li><li><p>Windows 7 Professional, VL Build (x64)<br><a href="ed2k://|file|cn_windows_7_professional_vl_build_x64_dvd_x15-71029.iso|3203971072|23155387CBD0771CFBA528CB1E7B170F|/">cn_windows_7_professional_vl_build_x64_dvd_x15-71029.iso</a></p></li><li><p>Windows 7 Professional, VL Build (x86)<br><a href="ed2k://|file|cn_windows_7_professional_vl_build_x86_dvd_x15-71025.iso|2466107392|9EA7E0C2594B5A236FD09D572CA39770|/">cn_windows_7_professional_vl_build_x86_dvd_x15-71025.iso</a></p></li><li><p>Windows 7 Professional (x64)<br><a href="ed2k://|file|cn_windows_7_professional_x64_dvd_x15-65791.iso|3341268992|3474800521D169FBF3F5E527CD835156|/">cn_windows_7_professional_x64_dvd_x15-65791.iso</a></p></li><li><p>Windows 7 Professional (x86)<br><a href="ed2k://|file|cn_windows_7_professional_x86_dvd_x15-65790.iso|2604238848|E812FBE758F05B485C5A858C22060785|/">cn_windows_7_professional_x86_dvd_x15-65790.iso</a></p></li><li><p>Windows 7 Home Premium (x64)<br><a href="ed2k://|file|cn_windows_7_home_premium_x64_dvd_x15-65718.iso|3341268992|9F976045631A6A2162ABE32FC77C8ACC|/">cn_windows_7_home_premium_x64_dvd_x15-65718.iso</a></p></li><li><p>Windows 7 Home Premium (x86)<br><a href="ed2k://|file|cn_windows_7_home_premium_x86_dvd_x15-65717.iso|2604238848|98E1EB474F92343B06737F227665DF1C|/">cn_windows_7_home_premium_x86_dvd_x15-65717.iso</a></p></li><li><p>Windows 7 Home Basic (x86)<br><a href="ed2k://|file|cn_windows_7_home_basic_x86_dvd_x15-65975.iso|2604238848|AF82993DCF8F3D7AA08D54693691BB48|/">cn_windows_7_home_basic_x86_dvd_x15-65975.iso</a></p></li><li><p>Windows 7 Starter (x86)<br><a href="ed2k://|file|cn_windows_7_starter_x86_dvd_x15-69303.iso|2604238848|5A6796B2B6A97B3E372F7C37D3A42AA4|/">cn_windows_7_starter_x86_dvd_x15-69303.iso</a></p></li></ul><hr><h2 id="Windows-Vista"><a href="#Windows-Vista" class="headerlink" title="Windows Vista"></a>Windows Vista</h2><h3 id="Service-Pack-2"><a href="#Service-Pack-2" class="headerlink" title="Service Pack 2"></a>Service Pack 2</h3><ul><li><p>Windows Vista Enterprise with Service Pack 2 (x86)<br><a href="ed2k://|file|cn_windows_vista_enterprise_with_sp2_x86_dvd_x15-40257.iso|2348410880|A567A6C970038233C0B2B7F130ADEF23|/">cn_windows_vista_enterprise_with_sp2_x86_dvd_x15-40257.iso</a></p></li><li><p>Windows Vista Enterprise with Service Pack 2 (x64)<br><a href="ed2k://|file|cn_windows_vista_enterprise_with_sp2_x64_dvd_x15-40402.iso|3104415744|D0CF708192BF9596CC603DF53ABDB76D|/">cn_windows_vista_enterprise_with_sp2_x64_dvd_x15-40402.iso</a></p></li><li><p>Windows Vista with Service Pack 2 (x86)<br><a href="ed2k://|file|cn_windows_vista_with_sp2_x86_dvd_x15-36285.iso|3078893568|F50709974F03C63BB41B5CA0D406160D|/">cn_windows_vista_with_sp2_x86_dvd_x15-36285.iso</a></p></li><li><p>Windows Vista with Service Pack 2 (x64)<br><a href="ed2k://|file|cn_windows_vista_with_sp2_x64_dvd_x15-36322.iso|3817512960|3719CEC49ECC2D73FCF7AF152A42049A|/">cn_windows_vista_with_sp2_x64_dvd_x15-36322.iso</a></p></li></ul><h3 id="Service-Pack-1-1"><a href="#Service-Pack-1-1" class="headerlink" title="Service Pack 1"></a>Service Pack 1</h3><ul><li><p>Windows Vista with Service Pack 1 (x86)<br><a href="ed2k://|file|zh-hans_windows_vista_with_service_pack_1_x86_dvd_x14-30732.iso|2948851712|78927112D52EA2B1D4357583F041A20E|/">zh-hans_windows_vista_with_service_pack_1_x86_dvd_x14-30732.iso</a></p></li><li><p>Windows Vista with Service Pack 1 (x64)<br><a href="ed2k://|file|zh-hans_windows_vista_with_service_pack_1_x64_dvd_x14-30733.iso|3926849536|67C15BF7CCF3130B31F49223D3F485FD|/">zh-hans_windows_vista_with_service_pack_1_x64_dvd_x14-30733.iso</a></p></li><li><p>Windows Vista Enterprise with Service Pack 1 (x86)<br><a href="ed2k://|file|zh-hans_windows_vista_enterprise_with_service_pack_1_x86_dvd_x14-55727.iso|2255577088|C7EB8C68B6D9D72988DE7F57670B2EC1|/">zh-hans_windows_vista_enterprise_with_service_pack_1_x86_dvd_x14-55727.iso</a></p></li><li><p>Windows Vista Enterprise with Service Pack 1 (x64)<br><a href="ed2k://|file|zh-hans_windows_vista_enterprise_with_service_pack_1_x64_dvd_x14-55848.iso|2969976832|B4F450ED55F14D48EBA1A76129903A9A|/">zh-hans_windows_vista_enterprise_with_service_pack_1_x64_dvd_x14-55848.iso</a></p></li></ul><h3 id="RTM-2"><a href="#RTM-2" class="headerlink" title="RTM"></a>RTM</h3><ul><li><p>Windows Vista (x86)<br><a href="ed2k://|file|cn_windows_vista_x86_dvd_X12-59648.iso|2613229568|DBC16B06681EE44AA2DA0A8F95192C8F|/">cn_windows_vista_x86_dvd_X12-59648.iso</a></p></li><li><p>Windows Vista (x64)<br><a href="ed2k://|file|cn_windows_vista_x64_dvd_X12-63216.iso|3536730112|73EF8E235F3AD1A359546C89EDE7E4FC|/">cn_windows_vista_x64_dvd_X12-63216.iso</a></p></li></ul><hr><h2 id="Windows-Server-2003"><a href="#Windows-Server-2003" class="headerlink" title="Windows Server 2003"></a>Windows Server 2003</h2><h3 id="Service-Pack-2-1"><a href="#Service-Pack-2-1" class="headerlink" title="Service Pack 2"></a>Service Pack 2</h3><ul><li>Windows Server 2003 Service Pack 2 (x86)（非系统镜像）<br><a href="ed2k://|file|cn_windows_server_2003_sp2_x86_cd.iso|390135808|4C38E53EF100F80683810CAC1044CA70|/">cn_windows_server_2003_sp2_x86_cd.iso</a></li></ul><h3 id="Service-Pack-1-2"><a href="#Service-Pack-1-2" class="headerlink" title="Service Pack 1"></a>Service Pack 1</h3><ul><li><p>Windows Server 2003 Standard Edition with Service Pack 1<br><a href="ed2k://|file|sc_ws_2003_std_with_sp1.iso|607655936|B298D534F3A90A55D19551B1F5D38695|/">sc_ws_2003_std_with_sp1.iso</a></p></li><li><p>Windows Server 2003 Standard Edition with Service Pack 1 - VL<br><a href="ed2k://|file|sc_ws_2003_std_with_sp1_vl.iso|607655936|BE3C75720319D0E90261D6E54B219CDA|/">sc_ws_2003_std_with_sp1_vl.iso</a></p></li><li><p>Windows Server 2003 Enterprise Edition with SP1<br><a href="ed2k://|file|sc_ws_2003_ent_with_sp1.iso|609118208|3F14B15455A62A1D5A58DC2691BAF467|/">sc_ws_2003_ent_with_sp1.iso</a></p></li><li><p>Windows Server 2003 Enterprise Edition with Service Pack 1- VL<br><a href="ed2k://|file|sc_ws_2003_ent_with_sp1_vl.iso|609118208|86829ECBFC1875C90B77480CB59F8C8C|/">sc_ws_2003_ent_with_sp1_vl.iso</a></p></li></ul><h3 id="RTM-3"><a href="#RTM-3" class="headerlink" title="RTM"></a>RTM</h3><ul><li><p>Windows Server 2003 Standard Edition<br><a href="ed2k://|file|sc_windows_server_2003_standard.iso|592508928|654DA132E149906049F51A1E0FC883C7|/">sc_windows_server_2003_standard.iso</a></p></li><li><p>Windows Server 2003 Standard Edition - VL<br><a href="ed2k://|file|sc_windows_server_2003_standard_vl.iso|592508928|4807EEA36FE30EC00D3C1244276A22C4|/">sc_windows_server_2003_standard_vl.iso</a></p></li><li><p>Windows Server 2003 Enterprise Edition<br><a href="ed2k://|file|sc_windows_server_2003_enterprise.iso|593608704|783472AD78E46A0888D72B370230D717|/">sc_windows_server_2003_enterprise.iso</a></p></li><li><p>Windows Server 2003 Enterprise Edition - VL<br><a href="ed2k://|file|sc_windows_server_2003_enterprise_vl.iso|593608704|E0B4A025014F02CA4ABA0CC6D881AB10|/">sc_windows_server_2003_enterprise_vl.iso</a></p></li></ul><hr><h2 id="Windows-XP"><a href="#Windows-XP" class="headerlink" title="Windows XP"></a>Windows XP</h2><h3 id="Service-Pack-3"><a href="#Service-Pack-3" class="headerlink" title="Service Pack 3"></a>Service Pack 3</h3><ul><li><p>Windows XP Home with Service Pack 3 (x86)<br><a href="ed2k://|file|zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_x14-80404.iso|630239232|CD0900AFA058ACB6345761969CBCBFF4|/">zh-hans_windows_xp_home_with_service_pack_3_x86_cd_x14-92408.iso</a></p></li><li><p>Windows XP Professional with Service Pack 3 (x86)<br><a href="ed2k://|file|zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_x14-80404.iso|630239232|CD0900AFA058ACB6345761969CBCBFF4|/">zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_x14-80404.iso</a></p></li><li><p>Windows XP Professional with Service Pack 3 (x86) - VL<br><a href="ed2k://|file|zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_vl_x14-74070.iso|630237184|EC51916C9D9B8B931195EE0D6EE9B40E|/">zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_vl_x14-74070.iso</a></p></li></ul><h3 id="Service-Pack-2-2"><a href="#Service-Pack-2-2" class="headerlink" title="Service Pack 2"></a>Service Pack 2</h3><ul><li><p>Windows XP Home Edition with Service Pack 2<br><a href="ed2k://|file|sc_winxp_home_with_sp2.iso|611358720|B80F4CCF312420015FFD5740057085B0|/">sc_winxp_home_with_sp2.iso</a></p></li><li><p>Windows XP Professional with Service Pack 2<br><a href="ed2k://|file|sc_winxp_pro_with_sp2.iso|629227520|505B810E128351482AF8B83AC4D04FD2|/">sc_winxp_pro_with_sp2.iso</a></p></li><li><p>Windows XP Professional with Service Pack 2 - VL<br><a href="ed2k://|file|sc_win_xp_pro_with_sp2_vl.iso|621346816|6F27DB53806D79FE37A0EDEC04AA9B05|/">sc_win_xp_pro_with_sp2_vl.iso</a></p></li></ul><h3 id="Service-Pack-1a"><a href="#Service-Pack-1a" class="headerlink" title="Service Pack 1a"></a>Service Pack 1a</h3><ul><li>升级包（非系统镜像）<br><a href="ed2k://|file|sc_winxp_sp1.iso|312993792|2711C1C07563C6F4782271ECA771FC90|/">sc_winxp_sp1.iso</a></li></ul><h3 id="RTM-4"><a href="#RTM-4" class="headerlink" title="RTM"></a>RTM</h3><ul><li><p>Windows XP Home Edition<br><a href="ed2k://|file|CN_WINXP_HOME_ISO.img|513515520|58373CA20ABB0438AF5858AEBF22E983|/">CN_WINXP_HOME_ISO.img</a></p></li><li><p>Windows XP Professional<br><a href="ed2k://|file|CN_WINXP_PRO_ISO.img|530186240|7855069CE4216615D761654E2B75A4F7|/">CN_WINXP_PRO_ISO.img</a></p></li></ul><hr><h2 id="Windows-2000"><a href="#Windows-2000" class="headerlink" title="Windows 2000"></a>Windows 2000</h2><ul><li>Windows 2000 Professional with SP4<br><a href="ed2k://|file|ZRMPSEL_CN.iso|402690048|00D1BDA0F057EDB8DA0B29CF5E188788|/">ZRMPSEL_CN.iso</a></li></ul><hr><h2 id="Windows-ME"><a href="#Windows-ME" class="headerlink" title="Windows ME"></a>Windows ME</h2><ul><li>Windows Millennium Edition<br><a href="ed2k://|file|SC_WINME.exe|174098008|EEBAABADCD0162DA9F66F68E91B1B92A|/">SC_WINME.exe</a></li></ul><hr><h2 id="Windows-98"><a href="#Windows-98" class="headerlink" title="Windows 98"></a>Windows 98</h2><ul><li>Windows 98 Second Edition<br><a href="ed2k://|file|SC_WIN98SE.exe|278540368|939909E688963174901F822123E55F7E|/">SC_WIN98SE.exe</a></li></ul><hr><h2 id="Windows-NT"><a href="#Windows-NT" class="headerlink" title="Windows NT"></a>Windows NT</h2><ul><li>Windows NT Server 4.0<br><a href="ed2k://|file|sc_winnt_4.0_svr.iso|676548608|3BCB905EB3A6ED9AB685B5701BF94A29|/">sc_winnt_4.0_svr.iso</a></li></ul><hr><h2 id="Windows-3"><a href="#Windows-3" class="headerlink" title="Windows 3.*"></a>Windows 3.*</h2><ul><li><p>Windows 3.2.144<br><a href="ed2k://|file|SC_Windows32_144.exe|12835440|782F5AF8A1405D518C181F057FCC4287|/">SC_Windows32_144.exe</a></p></li><li><p>Windows 3.2.12<br><a href="ed2k://|file|SC_Windows32_12.exe|12832984|A76EB68E35CD62F8B40ECD3E6F5E213F|/">SC_Windows32_12.exe</a></p></li><li><p>Windows 3.1<br><a href="ed2k://|file|SC_Windows31.exe|8472384|84037137FFF3932707F286EC852F2ABC|/">SC_Windows31.exe</a></p></li></ul><hr><h2 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h2><ul><li>MS-DOS 6.22<br><a href="ed2k://|file|SC_MSDOS622sc.exe|10020288|0B2B0878B8BBD2233D23022EE5339637|/">SC_MSDOS622sc.exe</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinINet 代理设置与注册表位置</title>
      <link href="/2021/08/20/18OY8R7kO/"/>
      <url>/2021/08/20/18OY8R7kO/</url>
      
        <content type="html"><![CDATA[<h2 id="按用户代理时的注册表位置"><a href="#按用户代理时的注册表位置" class="headerlink" title="按用户代理时的注册表位置"></a>按用户代理时的注册表位置</h2><p>Windows系统默认是”按用户代理”的，意味着每个系统账户都有属于自己独立的代理设置。我们可以运行命令<code>Inetcpl.cpl</code>来打开IE选项窗口，在”连接”选项卡中点击”局域网设置”便可以显示代理设置界面，<br>代理设置最终会保存在注册表中。</p><h3 id="自动配置部分"><a href="#自动配置部分" class="headerlink" title="自动配置部分"></a>自动配置部分</h3><p><img src="/images/1629342427593.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings]</span><br><span class="line">&quot;AutoDetect&quot;=dword:00000001</span><br><span class="line">&quot;AutoConfigURL&quot;=&quot;http://localhost/test.pac&quot;</span><br><span class="line">&quot;ProxyEnable&quot;=dword:00000001</span><br><span class="line">&quot;ProxyServer&quot;=&quot;127.0.0.1:7890&quot;</span><br><span class="line">&quot;ProxyOverride&quot;=&quot;&lt;local&gt;&quot;</span><br></pre></td></tr></table></figure><ul><li><p>AutoDetect<br>自动检测设置开关，通过 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor</a> 监测发现，打开选项设置窗口后会将其值同步到<code>DefaultConnectionSettings</code>并删除<code>AutoDetect</code>，看上去是一种”升级”操作，将旧设置迁移至新位置，所以尽量还是以<code>DefaultConnectionSettings</code>为准。</p></li><li><p>AutoConfigURL<br>PAC文件URL。如果没有值或值为空，表示未启用状态，会尝试从<code>DefaultConnectionSettings</code>获取最近一次的值并显示。<br>需要注意的是，PAC 地址应该是一个使用HTTP协议的地址，而不应使用本地文件路径，否则会无法加载，原因见 <a href="https://docs.microsoft.com/en-us/troubleshoot/browsers/cannot-read-pac-file">Windows 10 does not read a PAC file referenced by a file protocol</a>。并且服务器应该为其指定MIME类型为<code>application/x-ns-proxy-autoconfig</code>。</p></li><li><p>ProxyEnable<br>是否启用代理。</p></li><li><p>ProxyServer<br>各协议所使用的代理服务器，用分号分隔。如果不指定具体协议而直接写上服务器与端口号，则表示所有协议使用同一个代理。</p></li><li><p>ProxyOverride<br>禁止使用代理服务器的地址列表，通常指定为本地地址。支持通配符，用分号分隔。它同时也是”对于本地地址不使用代理服务器”选项的开关。</p></li></ul><h3 id="代理服务器部分"><a href="#代理服务器部分" class="headerlink" title="代理服务器部分"></a>代理服务器部分</h3><p><img src="/images/1629343344669.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings]</span><br><span class="line">&quot;ProxyEnable&quot;=dword:00000001</span><br><span class="line">&quot;ProxyServer&quot;=&quot;http=127.0.0.1:7890;https=127.0.0.1:7890;ftp=127.0.0.1:7890;socks=127.0.0.1:7890&quot;</span><br><span class="line">&quot;ProxyOverride&quot;=&quot;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;192.168.*;&lt;local&gt;&quot;</span><br></pre></td></tr></table></figure><ul><li><p>ProxyEnable<br>是否启用代理。</p></li><li><p>ProxyServer<br>各协议所使用的代理服务器，用分号分隔。如果不指定具体协议而直接写上服务器与端口号，则表示所有协议使用同一个代理。</p></li><li><p>ProxyOverride<br>禁止使用代理服务器的地址列表，通常指定为本地地址。支持通配符，用分号分隔。它同时也是”对于本地地址不使用代理服务器”选项的开关。</p></li></ul><p><strong>在IE浏览器中，启动浏览器、开关或关闭代理设置窗口都会将设置同步到<code>DefaultConnectionSettings</code>键值中，读取代理设置时都会以<code>DefaultConnectionSettings</code>中的值为准（缓存代理设置的作用）。</strong><br><strong>而对于非IE浏览器，则以<code>Internet Settings</code>中的设置为准。</strong></p><h2 id="按计算机代理时的注册表位置"><a href="#按计算机代理时的注册表位置" class="headerlink" title="按计算机代理时的注册表位置"></a>按计算机代理时的注册表位置</h2><p>运行命令<code>gpedit.msc</code>打开策略编辑器，依次打开”计算机配置”、”管理模板”、”Windows 组件”、”Internet Explorer”，找到”按计算机(而不是按用户)进行代理”，启用这个选项将会在注册表保存一个值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings]</span><br><span class="line">&quot;ProxySettingsPerUser&quot;=dword:00000000</span><br></pre></td></tr></table></figure><p>值不存在或是非0值，意味着”按用户代理”，否则就是”按计算机代理”。<br>当系统变为”按计算机代理”后，代理设置的注册表根位置将从<code>HKEY_CURRENT_USER</code>变为<code>HKEY_LOCAL_MACHINE</code>。而且必须使用管理员方式运行IE才能成功修改代理设置。<br>**要注意的是，按计算机代理后<code>WinINet</code>不会再读取<code>Internet Settings</code>下的设置了，而是直接读取<code>DefaultConnectionSettings</code>**。</p><h2 id="解密DefaultConnectionSettings"><a href="#解密DefaultConnectionSettings" class="headerlink" title="解密DefaultConnectionSettings"></a>解密DefaultConnectionSettings</h2><p>它是一个未公开的结构体，我们可以在泄露的Windows 2003源码中找到蛛丝马迹，<br>头文件 <a href="https://github.com/9176324/Win2K3/blob/master/NT/inetcore/wininet/dll/proxreg.cxx">proxreg.cxx</a> 中的结构体 <a href="https://github.com/9176324/Win2K3/blob/master/NT/inetcore/wininet/inc/proxreg.h#L69">INTERNET_PROXY_INFO_EX</a> 就是它了，函数 <a href="https://github.com/9176324/Win2K3/blob/master/NT/inetcore/wininet/dll/proxreg.cxx#L889">WriteProxySettings</a> 用于将这个结构体写入注册表，而 <a href="https://github.com/9176324/Win2K3/blob/master/NT/inetcore/wininet/dll/proxreg.cxx#L721#L721">ReadProxySettings</a> 将<code>DefaultConnectionSettings</code>读取到结构体中，这就是一个序列化，反序列化的过程。</p><p>开始的4字节表示结构体大小，同时也用于标识结构体版本，XP到Win10为止仅修改过一次，所以目前只有两种可能的值：0x3C和0x46。<br>根据源码中的定义，IE5和IE6都是0x3C，也就是第一版的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define INTERNET_PROXY_INFO_EX_VERSION      60      // 60 := IE 5.x &amp; 6.0 format</span><br></pre></td></tr></table></figure><p>XP系统自带的是IE6，实际查看一下也确实如此<br><img src="/images/1629429506257.png"><br>从Vista的IE7开始，结构体就升级了，变为了0x46。<br>我编写了一个010 Editor的模板，这样看起来比较直观</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//------------------------------------------------</span><br><span class="line">//--- 010 Editor v9.0 Binary Template</span><br><span class="line">//</span><br><span class="line">//      File: </span><br><span class="line">//   Authors: </span><br><span class="line">//   Version: </span><br><span class="line">//   Purpose: </span><br><span class="line">//  Category: </span><br><span class="line">// File Mask: </span><br><span class="line">//  ID Bytes: </span><br><span class="line">//   History: </span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">enum PROXY_TYPE &#123;</span><br><span class="line">    PROXY_TYPE_DIRECT = 1,</span><br><span class="line">    PROXY_TYPE_PROXY = 2,</span><br><span class="line">    PROXY_TYPE_AUTO_PROXY_URL = 4,</span><br><span class="line">    PROXY_TYPE_AUTO_DETECT = 8</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct INTERNET_PROXY_INFO_EX_1 &#123;</span><br><span class="line">    DWORD dwStructSize &lt;comment=&quot;结构版本&quot;&gt;;;</span><br><span class="line">    DWORD dwCurrentSettingsVersion &lt;comment=&quot;计数器，每次修改会增加&quot;&gt;;</span><br><span class="line">    PROXY_TYPE dwFlags &lt;comment=&quot;代理方式&quot;&gt;;</span><br><span class="line">    DWORD cbProxy &lt;comment=&quot;代理服务器字符串长度&quot;&gt;;</span><br><span class="line">    CHAR szProxy[cbProxy] &lt;comment=&quot;代理服务器地址&quot;&gt;;;</span><br><span class="line">    DWORD cbProxyBypass &lt;comment=&quot;代理忽略列表字符串长度&quot;&gt;;</span><br><span class="line">    CHAR szProxyBypass[cbProxyBypass] &lt;comment=&quot;代理忽略列表&quot;&gt;;</span><br><span class="line">    DWORD cbAutoConfigUrl;</span><br><span class="line">    CHAR szAutoConfigUrl[cbAutoConfigUrl];</span><br><span class="line">    DWORD dwAutoDiscoveryFlags;</span><br><span class="line">    DWORD cbLastKnownGoodAutoConfigUrl;</span><br><span class="line">    CHAR szLastKnownGoodAutoConfigUrl[cbLastKnownGoodAutoConfigUrl];</span><br><span class="line">    FILETIME ftLastKnownDetectTime;</span><br><span class="line">    DWORD dwDetectedInterfaceIpCount;</span><br><span class="line">    DWORD arrDetectedInterfaceIp[dwDetectedInterfaceIpCount];</span><br><span class="line">    DWORD cbAutoconfigSecondaryUrl;</span><br><span class="line">    CHAR szAutoconfigSecondaryUrl[cbAutoconfigSecondaryUrl];</span><br><span class="line">    DWORD dwAutoconfigReloadDelayMins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct INTERNET_PROXY_INFO_EX_2 &#123;</span><br><span class="line">    INTERNET_PROXY_INFO_EX_1 info1;</span><br><span class="line">    DWORD dwUnknown;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">local DWORD dwVersion = ReadUInt();</span><br><span class="line">if (dwVersion == 0x3C) &#123;</span><br><span class="line">    INTERNET_PROXY_INFO_EX_1 info;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    INTERNET_PROXY_INFO_EX_2 info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1629431873468.png"><br>从头部的4字节看，0x46 - 0x3C &#x3D; 0xA，也就是在其dll内部的结构体多了10字节，但是持久化到注册表后只多了4字节。</p><ul><li>dwFlags<br>dwFlags实际上就是常量<code>PROXY_TYPE_DIRECT</code>和其他三个值的组合。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define PROXY_TYPE_DIRECT                               0x00000001   // direct to net</span><br><span class="line">#define PROXY_TYPE_PROXY                                0x00000002   // via named proxy</span><br><span class="line">#define PROXY_TYPE_AUTO_PROXY_URL                       0x00000004   // autoproxy URL</span><br><span class="line">#define PROXY_TYPE_AUTO_DETECT                          0x00000008   // use autoproxy detection</span><br></pre></td></tr></table></figure></li><li>自动配置URL<br>自动代理的URL有两个，一个主一个次，但是我们在IE设置中只能设置一个主要的，次要的URL是怎么配置进去的呢？这就是通过之前的一篇文章 <a href="/post/Rn9thta4F/">IE自动部署工具包IEAK</a> 中介绍过的INS文件写入进去的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[URL]</span><br><span class="line">AutoDetect=1</span><br><span class="line">AutoConfig=1</span><br><span class="line">AutoConfigTime=1</span><br><span class="line">AutoConfigURL=http://localhost/test1.pac</span><br><span class="line">AutoConfigJSURL=http://localhost/test2.pac</span><br></pre></td></tr></table></figure>其中<code>AutoConfigJSURL</code>就是次选代理URL。但是经过测试发现，次选URL永远用不上，当<code>AutoConfigURL</code>无法访问时，网络会产生直连，而没有寻找次选代理URL。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>按用户代理时，<a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 以<code>Internet Settings</code>中的值为准。但IE是个例外，IE以<code>DefaultConnectionSettings</code>中的值为准。</li><li>按计算机代理时，<a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 以<code>DefaultConnectionSettings</code>中的值为准，在<code>Internet Settings</code>下的设置没有任何效果。</li><li>64位系统下，如果用直接修改注册表的方式改代理，要注意注册表<code>WOW6432Node</code>下的位置也要一起改。</li></ol><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://support.microsoft.com/en-us/topic/how-to-disable-automatic-proxy-caching-in-internet-explorer-92735c9c-8a26-d0d8-7f8a-1b46595cbaba">How to disable automatic proxy caching in Internet Explorer</a></p><p><a href="https://stackoverflow.com/questions/4283027/whats-the-format-of-the-defaultconnectionsettings-value-in-the-windows-registry">https://stackoverflow.com/questions/4283027/whats-the-format-of-the-defaultconnectionsettings-value-in-the-windows-registry</a></p><p><a href="https://stackoverflow.com/questions/1674119/what-key-in-windows-registry-disables-ie-connection-parameter-automatically-det">https://stackoverflow.com/questions/1674119/what-key-in-windows-registry-disables-ie-connection-parameter-automatically-det</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> WinINet </tag>
            
            <tag> IE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinINet的代理策略</title>
      <link href="/2021/08/19/WinINet-proxy/"/>
      <url>/2021/08/19/WinINet-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是系统代理"><a href="#什么是系统代理" class="headerlink" title="什么是系统代理"></a>什么是系统代理</h2><p>我们在网上冲浪时，无时无刻都在使用着基于HTTP协议的应用程序，使用最多的就是浏览器了。<br>面向开发者而言，微软提供了 <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp">WinHTTP</a> 两套网络API。<a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 是 <a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp">WinHTTP</a> 的超集。<br>我们在桌面上使用的应用程序几乎都是用的 <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a>，而 <a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp">WinHTTP</a> 通常用于一些无GUI的服务程序中。<br>关于 <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp">WinHTTP</a> 的差别可以查看官方手册 <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/wininet-vs-winhttp">WinINet vs. WinHTTP</a>。<br>本文所讨论的是 <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinINet</a> 的代理机制。</p><h2 id="WinINet的代理策略"><a href="#WinINet的代理策略" class="headerlink" title="WinINet的代理策略"></a>WinINet的代理策略</h2><p>API函数 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenw">InternetOpenW</a> 决定了程序如何使用代理，重点在第2个参数<code>AccessType</code>，解释如下：<br><code>INTERNET_OPEN_TYPE_DIRECT</code>：直连，不走代理。<br><code>INTERNET_OPEN_TYPE_PRECONFIG</code>：从注册表获取代理设置并使用。<br><code>INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY</code>：从注册表获取代理设置并使用，但不使用”自动配置”代理设置。<br><code>INTERNET_OPEN_TYPE_PROXY</code>：绕过注册表的代理设置，直连代理服务器，代理服务器由第3个参数指定。<br>第1个和第4个参数很好理解，说下第2个和第3个参数，WinINet的代理机制分两种，一种是<code>自动配置</code>，另一种是<code>代理服务器</code><br><img src="/images/1629336801688.png"><br><code>自动配置</code>基于 <a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">PAC</a> 技术来实现代理。而<code>代理服务器</code>则是比较传统的方式，通过指定地址和协议来代理的，虽然也可以指定黑名单IP禁止代理，但灵活性是不如 <a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">PAC</a> 代理技术的。<br>当程序使用<code>INTERNET_OPEN_TYPE_PRECONFIG</code>作为参数时，表示<strong>优先使用”自动配置”代理，否则使用”代理服务器”的设置</strong>。<br>而当程序使用<code>INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY</code>作为参数时，表示<strong>跳过”自动配置”代理，直接使用”代理服务器”的设置</strong>。<br>最常见的浏览器和绝大多数应用通常是使用<code>INTERNET_OPEN_TYPE_PRECONFIG</code>作为参数，用<code>INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY</code>的情况比较少见。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> WinINet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE自动部署工具包IEAK</title>
      <link href="/2021/08/18/Rn9thta4F/"/>
      <url>/2021/08/18/Rn9thta4F/</url>
      
        <content type="html"><![CDATA[<p>Internet Explorer Administration Kit (IEAK)是一个IE的管理工具包，可自定义配置生成一个IE安装包或仅设置的包，一般是给网管人员部署使用的，可以帮助管理员快速统一部署IE。<br>适用于IE11的工具包下载地址：<a href="https://docs.microsoft.com/zh-cn/internet-explorer/ie11-ieak/ieak-information-and-downloads">https://docs.microsoft.com/zh-cn/internet-explorer/ie11-ieak/ieak-information-and-downloads</a></p><h2 id="INS配置文件"><a href="#INS配置文件" class="headerlink" title="INS配置文件"></a>INS配置文件</h2><p>我们用它配置”链接”相关设置<br><img src="/images/1629300058002.png"><br>最终会生成一个安装包，其中有一个INS文件内容大概是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Branding]</span><br><span class="line">CompanyName=Microsoft Corporation</span><br><span class="line">Wizard_Version=11.00.18362.1</span><br><span class="line">Version=11,00,18362,1</span><br><span class="line">Custom_Key=MICROSO</span><br><span class="line">Global=1</span><br><span class="line">IE4 Welcome Msg=1</span><br><span class="line">Platform=2</span><br><span class="line">GUID=&#123;7211FFE6-C149-11D0-AFF0-00AA003758BB&#125;</span><br><span class="line">Type=0</span><br><span class="line">NoClear=1</span><br><span class="line">[URL]</span><br><span class="line">AutoDetect=0</span><br><span class="line">AutoConfig=1</span><br><span class="line">AutoConfigTime=1</span><br><span class="line">AutoConfigURL=http://localhost/ie.ins</span><br><span class="line">AutoConfigJSURL=http://localhost/test1.pac</span><br><span class="line">[Proxy]</span><br><span class="line">HTTP_Proxy_Server=</span><br><span class="line">FTP_Proxy_Server=</span><br><span class="line">Secure_Proxy_Server=</span><br><span class="line">Socks_Proxy_Server=</span><br><span class="line">Use_Same_Proxy=1</span><br><span class="line">Proxy_Enable=0</span><br><span class="line">Proxy_Override=&quot;&lt;local&gt;&quot;</span><br></pre></td></tr></table></figure><p>一个有效的ins文件必须有<code>[Branding]</code>节，我们也可以不用IEAK生成，而是直接从<code>C:\Program Files\Internet Explorer\SIGNUP\install.ins</code>拷贝一份进行手动修改也是可以的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Branding]</span><br><span class="line">CompanyName=</span><br><span class="line">Wizard_Version=11.00.19041.1</span><br><span class="line">Version=11,00,19041,1</span><br><span class="line">Custom_Key=MICROSO</span><br><span class="line">Global=1</span><br><span class="line">IE4 Welcome Msg=1</span><br><span class="line">Platform=2</span><br><span class="line">GUID=&#123;7211FFE6-C149-11D0-AFF0-00AA003758BB&#125;</span><br><span class="line">Type=0</span><br><span class="line">NoClear=1</span><br><span class="line">NoDial=0</span><br><span class="line">FavoritesDelete=0</span><br><span class="line">FavoritesOnTop=0</span><br><span class="line">User Agent=</span><br><span class="line">[URL]</span><br><span class="line">FirstHomePage=https://www.google.com</span><br></pre></td></tr></table></figure><p>这个例子添加了FirstHomePage字段，首次打开IE就会打开该首页。</p><p>运行部署安装包后会在IE目录下生成一个INS文件，并提示注销登录后生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Internet Explorer\CUSTOM\INSTALL.INS</span><br></pre></td></tr></table></figure><p>注销是为了让设置生效，实际上我们可以使用其他手段立即生效，有两种方法</p><h3 id="重置IE"><a href="#重置IE" class="headerlink" title="重置IE"></a>重置IE</h3><p>配置文件只有在IE初始化时会被访问，我们可以重置IE来让它再次载入配置文件。<br>运行命令<code>RunDll32.exe inetcpl.cpl,ResetIEtoDefaults</code>可以弹出重置对话框，确认重置后IE会依次从以下位置来获取配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Internet Explorer\Custom\install.ins</span><br><span class="line">C:\Program Files\Internet Explorer\Signup\install.ins</span><br></pre></td></tr></table></figure><h3 id="BrandInternetExplorer"><a href="#BrandInternetExplorer" class="headerlink" title="BrandInternetExplorer"></a>BrandInternetExplorer</h3><p><code>iedkcs32.dll</code>有一个导出函数<code>BrandInternetExplorer</code>可以使得IE下次启动时载入指定的INS配置文件。<br><code>rundll32.exe iedkcs32.dll,BrandInternetExplorer /ins:&quot;D:\test.ins&quot;</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpie/8206de0e-2d1e-4a02-977b-b8614c5350d9">INS File Format</a></p><p><a href="https://4sysops.com/archives/internet-explorer-10-administration-part-4-ieak-10/">https://4sysops.com/archives/internet-explorer-10-administration-part-4-ieak-10/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IE </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从磁盘上加载证书文件</title>
      <link href="/2021/08/13/6geICBPwL/"/>
      <url>/2021/08/13/6geICBPwL/</url>
      
        <content type="html"><![CDATA[<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>将证书视为存储库，通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> 打开，枚举出第一个证书即可。<br>一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">decodeObject</span><span class="params">(DWORD dwEncodingType, <span class="type">const</span> PCERT_EXTENSION pExt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T pInfo = <span class="literal">nullptr</span>;</span><br><span class="line">DWORD cbInfo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CryptDecodeObjectEx</span>(dwEncodingType, pExt-&gt;pszObjId, pExt-&gt;Value.pbData, pExt-&gt;Value.cbData, CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG, <span class="literal">nullptr</span>, &amp;pInfo, &amp;cbInfo))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> pInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 证书既是存储库</span></span><br><span class="line">HCERTSTORE hCertStore = <span class="built_in">CertOpenStore</span>(CERT_STORE_PROV_FILENAME_A, dwEncodingType, <span class="literal">NULL</span>, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG, <span class="string">&quot;ca.cer&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hCertStore) &#123;</span><br><span class="line"><span class="comment">// 取出第一个证书</span></span><br><span class="line">PCCERT_CONTEXT pCertContext = <span class="built_in">CertEnumCertificatesInStore</span>(hCertStore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (pCertContext) &#123;</span><br><span class="line"><span class="comment">// 遍历扩展信息</span></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pCertContext-&gt;pCertInfo-&gt;cExtension; ++i) &#123;</span><br><span class="line"><span class="type">const</span> PCERT_EXTENSION pExt = pCertContext-&gt;pCertInfo-&gt;rgExtension + i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pExt-&gt;pszObjId, szOID_KEY_USAGE) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 密钥用法</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> pInfo = <span class="built_in">decodeObject</span>&lt;PCRYPT_BIT_BLOB&gt;(dwEncodingType, pExt);</span><br><span class="line"><span class="built_in">LocalFree</span>(pInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pExt-&gt;pszObjId, szOID_BASIC_CONSTRAINTS2) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 基本约束</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> pInfo = <span class="built_in">decodeObject</span>&lt;PCERT_BASIC_CONSTRAINTS2_INFO&gt;(dwEncodingType, pExt);</span><br><span class="line"><span class="built_in">LocalFree</span>(pInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pExt-&gt;pszObjId, szOID_ENHANCED_KEY_USAGE) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 增强型密钥用法</span></span><br><span class="line"><span class="keyword">auto</span> pInfo = <span class="built_in">decodeObject</span>&lt;PCTL_USAGE&gt;(dwEncodingType, pExt);</span><br><span class="line"><span class="built_in">LocalFree</span>(pInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pExt-&gt;pszObjId, szOID_SUBJECT_ALT_NAME2) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 使用者可选名称</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> pInfo = <span class="built_in">decodeObject</span>&lt;PCERT_ALT_NAME_INFO&gt;(dwEncodingType, pExt);</span><br><span class="line"><span class="built_in">LocalFree</span>(pInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CertCloseStore</span>(hCertStore, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>在 <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptoapi-system-architecture">CryptoAPI</a> 中，一个证书文件用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> 结构描述，所以只要将证书文件转换为 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> 结构即可。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certcreatecertificatecontext">CertCreateCertificateContext</a> 函数可以做到，它从内存中读取证书数据并转换为 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> 结构。<br>但是要注意，这个函数只接受DER编码格式的证书，而我们常用的一般是PEM格式（以BEGIN开头，END结尾，中间是BASE64编码），所以要进行转换。<br>转换可以用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinarya">CryptStringToBinaryA</a> 函数搞定。<br>一个简单的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> DWORD dwEncodingType = X509_ASN_ENCODING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开证书</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;ca.cer&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">nullptr</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">nullptr</span>);</span><br><span class="line">LARGE_INTEGER fileSize;</span><br><span class="line"><span class="built_in">GetFileSizeEx</span>(hFile, &amp;fileSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取证书内容</span></span><br><span class="line">BYTE* buffer = <span class="keyword">new</span> BYTE[fileSize.QuadPart];</span><br><span class="line">DWORD dwWritten;</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, buffer, fileSize.QuadPart, &amp;dwWritten, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PEM转DER</span></span><br><span class="line">BYTE* bin = <span class="keyword">new</span> BYTE[dwWritten];</span><br><span class="line">DWORD flags;</span><br><span class="line">BOOL ok = <span class="built_in">CryptStringToBinaryA</span>((LPCSTR)buffer, dwWritten, CRYPT_STRING_BASE64HEADER, bin, &amp;dwWritten, <span class="literal">NULL</span>, &amp;flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得证书上下文</span></span><br><span class="line">PCCERT_CONTEXT pCert = <span class="built_in">CertCreateCertificateContext</span>(dwEncodingType, bin, dwWritten);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/dd743310(v=vs.85)">Load a Certificate from a File</a></p><p><a href="https://stackoverflow.com/questions/34623247/certcreatecertificatecontext-returns-crypt-e-asn1-badtag-8009310b">CertCreateCertificateContext returns CRYPT_E_ASN1_BADTAG &#x2F; 8009310b</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> CryptoAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持以 SYSTEM 账户执行程序的工具软件</title>
      <link href="/2021/08/12/vsCMLcwdS/"/>
      <url>/2021/08/12/vsCMLcwdS/</url>
      
        <content type="html"><![CDATA[<h2 id="PsExec"><a href="#PsExec" class="headerlink" title="PsExec"></a>PsExec</h2><p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a><br>微软官方出品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -sid regedit.exe</span><br></pre></td></tr></table></figure><p>-s表示以SYSTEM账户运行，-i表示运行在用户桌面而非SYSTEM桌面，-d表示不等待进程结束。其他不常用参数输入-h查看。</p><h2 id="NirCmd"><a href="#NirCmd" class="headerlink" title="NirCmd"></a>NirCmd</h2><p>下载地址：<a href="https://www.nirsoft.net/utils/nircmd.html">https://www.nirsoft.net/utils/nircmd.html</a><br><a href="https://www.nirsoft.net/">NirSoft</a> 出品，算是cmd的加强版，其中一个功能是支持以SYSTEM账户运行程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nircmd.exe elevatecmd runassystem C:\Windows\regedit.exe</span><br></pre></td></tr></table></figure><h2 id="AdvancedRun"><a href="#AdvancedRun" class="headerlink" title="AdvancedRun"></a>AdvancedRun</h2><p>下载地址：<a href="https://www.nirsoft.net/utils/advanced_run.html">https://www.nirsoft.net/utils/advanced_run.html</a><br><a href="https://www.nirsoft.net/">NirSoft</a> 出品，带GUI界面，同时也支持命令行方式启动，支持中文、支持添加右键菜单，启动程序更方便。<br>支持更多的启动参数设置，如启动目录、窗口大小、兼容模式、环境变量等等。<br><img src="/images/1628729493924.png"><br>同时支持以<strong>TrustedInstaller</strong>账户启动</p><h2 id="Process-Hacker"><a href="#Process-Hacker" class="headerlink" title="Process Hacker"></a>Process Hacker</h2><p>下载地址：<a href="https://processhacker.sourceforge.io/">https://processhacker.sourceforge.io</a><br>一个进程管理器工具，类似 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a>，但是功能更强大，比普通的进程管理器多出很多底层级别的操作。以其他账户运行程序是其中一个功能，不过似乎不支持用命令行方式。<br><img src="/images/1628729538434.png"><br>同时支持以<strong>TrustedInstaller</strong>账户启动</p><h2 id="NSudo"><a href="#NSudo" class="headerlink" title="NSudo"></a>NSudo</h2><p>下载地址：<a href="https://github.com/M2Team/NSudo">https://github.com/M2Team/NSudo</a><br>开源工具，有GUI界面，也支持命令行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSudoLC.exe -U:S regedit.exe</span><br></pre></td></tr></table></figure><p>同时支持以<strong>TrustedInstaller</strong>账户启动<br>更多说明可以使用-h参数查看，或访问 <a href="https://nsudo.m2team.org/zh-hans/">https://nsudo.m2team.org/zh-hans/</a></p><h2 id="RunX"><a href="#RunX" class="headerlink" title="RunX"></a>RunX</h2><p>下载地址：<a href="https://www.d7xtech.com/free-software/runx/">https://www.d7xtech.com/free-software/runx/</a><br>执行程序带有数字签名。分两个版本，RunX.exe是GUI版，RunXcmd.exe是命令行版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunXcmd.exe /exec=&quot;C:\Windows\regedit.exe&quot; /account=system</span><br></pre></td></tr></table></figure><p><img src="/images/1628732240937.png"><br>同时支持以<strong>TrustedInstaller</strong>账户启动</p><h2 id="PowerRun"><a href="#PowerRun" class="headerlink" title="PowerRun"></a>PowerRun</h2><p>下载地址：<a href="https://www.sordum.org/9416/powerrun-v1-5-run-with-highest-privileges/">https://www.sordum.org/9416/powerrun-v1-5-run-with-highest-privileges/</a><br>执行程序带有数字签名，支持命令行方式调用。<br>支持以<strong>TrustedInstaller</strong>账户启动</p><h2 id="自定义右键菜单"><a href="#自定义右键菜单" class="headerlink" title="自定义右键菜单"></a>自定义右键菜单</h2><p>上面大部分工具都支持使用命令行，所以我们可以在exe右键菜单中添加一个快速启动的菜单项。<br>比如我用RunX的话，编写一个.reg文件导入即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\exefile\shell\runassystem]</span><br><span class="line">@=&quot;Run as SYSTEM&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\exefile\shell\runassystem\command]</span><br><span class="line">@=&quot;D:\\Tools\\RunXcmd.exe /exec=\&quot;%1\&quot; /account=system&quot;</span><br></pre></td></tr></table></figure><p>这样启动exe就更方便了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.winhelponline.com/blog/run-program-as-system-localsystem-account-windows/">https://www.winhelponline.com/blog/run-program-as-system-localsystem-account-windows/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC的注册表设置</title>
      <link href="/2021/08/11/uac/"/>
      <url>/2021/08/11/uac/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1628674692462.png"><br>UAC相关设置保存在注册表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</span><br></pre></td></tr></table></figure><h2 id="ConsentPromptBehaviorAdmin"><a href="#ConsentPromptBehaviorAdmin" class="headerlink" title="ConsentPromptBehaviorAdmin"></a>ConsentPromptBehaviorAdmin</h2><p>用于控制通知方式，类型为<code>DWORD</code></p><h3 id="0-从不通知"><a href="#0-从不通知" class="headerlink" title="0 &#x3D; 从不通知"></a>0 &#x3D; 从不通知</h3><h3 id="1-要求输入账户密码（发生在-安全桌面）"><a href="#1-要求输入账户密码（发生在-安全桌面）" class="headerlink" title="1 &#x3D; 要求输入账户密码（发生在 安全桌面）"></a>1 &#x3D; 要求输入账户密码（发生在 <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-account-control-switch-to-the-secure-desktop-when-prompting-for-elevation">安全桌面</a>）</h3><p><img src="/images/1628725588340.png"></p><h3 id="2-始终通知（发生在-安全桌面"><a href="#2-始终通知（发生在-安全桌面" class="headerlink" title="2 &#x3D; 始终通知（发生在 安全桌面)"></a>2 &#x3D; 始终通知（发生在 <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-account-control-switch-to-the-secure-desktop-when-prompting-for-elevation">安全桌面</a>)</h3><p><img src="/images/1628725700789.png"></p><h3 id="3-要求输入账户密码（用户桌面）"><a href="#3-要求输入账户密码（用户桌面）" class="headerlink" title="3 &#x3D; 要求输入账户密码（用户桌面）"></a>3 &#x3D; 要求输入账户密码（用户桌面）</h3><h3 id="4-需要用户确认（用户桌面）"><a href="#4-需要用户确认（用户桌面）" class="headerlink" title="4 &#x3D; 需要用户确认（用户桌面）"></a>4 &#x3D; 需要用户确认（用户桌面）</h3><h3 id="5-默认值"><a href="#5-默认值" class="headerlink" title="5 &#x3D; 默认值"></a>5 &#x3D; 默认值</h3><h2 id="PromptOnSecureDesktop"><a href="#PromptOnSecureDesktop" class="headerlink" title="PromptOnSecureDesktop"></a>PromptOnSecureDesktop</h2><p>用于控制是否降低桌面亮度，0为不降低亮度，1为降低亮度。</p><h2 id="EnableLUA"><a href="#EnableLUA" class="headerlink" title="EnableLUA"></a>EnableLUA</h2><p>决定是否启用UAC功能，0为禁用，1为启用。修改后需要重新启动计算机。</p><h2 id="禁用UAC"><a href="#禁用UAC" class="headerlink" title="禁用UAC"></a>禁用UAC</h2><p>重点来了，当<code>ConsentPromptBehaviorAdmin</code>为<code>0</code>时也可以关闭UAC通知，这和用<code>EnableLUA</code>方式关闭是否有区别？<br>答案是<strong>有区别</strong>，当<code>EnableLUA</code>为<code>1</code>的时候表示UAC系统仍然有效，只不过是不再通知用户而已。<br>最直观的就是需要管理员权限运行的程序图标上依然会有小盾牌，哪怕你设置了”从不通知”。<br>而且随Windows启动的需要管理员权限的程序都会失败，只有在彻底关闭UAC时Windows才能拉起需要管理员权限的程序。<br>所以，将<code>EnableLUA</code>设置为<code>0</code>才是真正意义上的关闭。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpsb/341747f5-6b5d-4d30-85fc-fa1cc04038d4">ConsentPromptBehaviorAdmin</a></p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpsb/9ad50fd3-4d8d-4870-9f5b-978ce292b9d8">PromptOnSecureDesktop</a></p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpsb/958053ae-5397-4f96-977f-b7700ee461ec">EnableLUA</a></p><p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-account-control-switch-to-the-secure-desktop-when-prompting-for-elevation">User Account Control: Switch to the secure desktop when prompting for elevation</a></p><p><a href="https://netsecurity.51cto.com/art/201510/495577_2.htm">https://netsecurity.51cto.com/art/201510/495577_2.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程实现挂载ISO镜像文件</title>
      <link href="/2021/08/06/YLuwFEjkM/"/>
      <url>/2021/08/06/YLuwFEjkM/</url>
      
        <content type="html"><![CDATA[<h2 id="Win8平台自带API"><a href="#Win8平台自带API" class="headerlink" title="Win8平台自带API"></a>Win8平台自带API</h2><p>挂载虚拟磁盘文件VHD或ISO镜像文件可以用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-openvirtualdisk">OpenVirtualDisk</a> 相关API。其中ISO文件要求Win8及以上的系统，Win7不支持ISO文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initguid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;virtdisk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;VirtDisk&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hVirtualDisk = <span class="literal">nullptr</span>;</span><br><span class="line">VIRTUAL_STORAGE_TYPE vst;</span><br><span class="line">vst.DeviceId = VIRTUAL_STORAGE_TYPE_DEVICE_ISO;   <span class="comment">// Win7不支持ISO</span></span><br><span class="line">vst.VendorId = VIRTUAL_STORAGE_TYPE_VENDOR_MICROSOFT;</span><br><span class="line"></span><br><span class="line">OPEN_VIRTUAL_DISK_PARAMETERS openParams;</span><br><span class="line">openParams.Version = OPEN_VIRTUAL_DISK_VERSION_1;</span><br><span class="line"></span><br><span class="line">DWORD dwError = <span class="built_in">OpenVirtualDisk</span>(&amp;vst, <span class="string">L&quot;E:\\vs2013.4_ult_chs.iso&quot;</span>, VIRTUAL_DISK_ACCESS_ATTACH_RO, OPEN_VIRTUAL_DISK_FLAG_NONE, &amp;openParams, &amp;hVirtualDisk);</span><br><span class="line"><span class="keyword">if</span> (dwError == ERROR_SUCCESS) &#123;</span><br><span class="line">ATTACH_VIRTUAL_DISK_PARAMETERS attachParameters;</span><br><span class="line">attachParameters.Version = ATTACH_VIRTUAL_DISK_VERSION_1;</span><br><span class="line">dwError = <span class="built_in">AttachVirtualDisk</span>(hVirtualDisk, <span class="literal">nullptr</span>, ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY | ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME, <span class="number">0</span>, &amp;attachParameters, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (dwError == ERROR_SUCCESS) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AttachVirtualDisk error: &quot;</span> &lt;&lt; dwError &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OpenVirtualDisk error: &quot;</span> &lt;&lt; dwError &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法虽然可以挂载了，但是分配的挂载点是随机的，如果要手动指定挂载点则需要额外处理。</p><p>1、在 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-openvirtualdisk">OpenVirtualDisk</a> 的第3个参数带上 VIRTUAL_DISK_ACCESS_GET_INFO，否则后面的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-getvirtualdiskphysicalpath">GetVirtualDiskPhysicalPath</a> 函数会失败。<br>2、在 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-attachvirtualdisk">AttachVirtualDisk</a> 的第3个参数带上 ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER，表示不自动分配分区。<br>3、使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-getvirtualdiskphysicalpath">GetVirtualDiskPhysicalPath</a> 得到设备名称。<br>4、用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a>来枚举所有卷，并用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-querydosdevicew">QueryDosDevice</a> 查询每个卷的设备名，和上一步得到的设备名做比对，从而确认卷名称。<br>5、用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumemountpointw">SetVolumeMountPoint</a> 挂载到指定分区上。</p><p>其中第四步枚举的方法有点愚蠢，更简单的方式是用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPointW</a> 函数代替，它可以直接获取卷名称，参数是设备路径（注意末尾必须是反斜杠）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\.\GLOBALROOT\Device\CDROM0\</span><br></pre></td></tr></table></figure><p>卸载虚拟磁盘用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/virtdisk/nf-virtdisk-detachvirtualdisk">DetachVirtualDisk</a> 函数</p><h2 id="兼容Win7平台方案"><a href="#兼容Win7平台方案" class="headerlink" title="兼容Win7平台方案"></a>兼容Win7平台方案</h2><p>如果要兼容Win7可以考虑使用第三方工具，比如这个 <a href="https://www.osforensics.com/tools/mount-disk-images.html">https://www.osforensics.com/tools/mount-disk-images.html</a><br>提取 OSFMount.com 文件和 OSFMount.sys 文件即可，驱动程序会自动注册进系统<br>只读挂载命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSFMount.com -a -t file -m Z: -o ro -f &quot;D:\vs2013.4_ce_enu.iso&quot;</span><br></pre></td></tr></table></figure><p>卸载命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSFMount.com -D -m Z:</span><br></pre></td></tr></table></figure><p>V2.0.1001版本的驱动在Win7 x64下无法使用，提示无法验证驱动签名。V1.5.1015版本可用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/24396644/programmatically-mount-a-microsoft-virtual-hard-drive-vhd">https://stackoverflow.com/questions/24396644/programmatically-mount-a-microsoft-virtual-hard-drive-vhd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U盘启动盘工具的工作原理</title>
      <link href="/2021/08/03/usb-bootable/"/>
      <url>/2021/08/03/usb-bootable/</url>
      
        <content type="html"><![CDATA[<p>目前市面上所有启动盘制作工具都可以说是套壳工具，核心都是依赖于finst和 <a href="https://www.disktool.cn/">分区助手</a> 或 <a href="https://www.diskgenius.cn/">DiskGenius</a>。</p><h2 id="Legacy引导支持"><a href="#Legacy引导支持" class="headerlink" title="Legacy引导支持"></a>Legacy引导支持</h2><p>fbinst的作用是在U盘上分出一个自创格式的分区，也就是所谓的 <a href="https://baike.baidu.com/item/UD%E5%8C%BA/17608149">UD分区</a>，这个分区不被系统识别，所以有较强的防病毒作用，只能通过fbinst来编辑分区文件。缺点是不支持UEFI引导。<br>fbinst工具有1.6和1.7两个版本，互相不兼容，且只有1.6版本有命令行支持，所以所有启动盘制作工具都是用的1.6版本。</p><p>用命令行来划分UD区，并添加进去一个ISO文件的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:: 在第1块磁盘上，格式化并创建UD区，分配300m空间</span><br><span class="line">fbinst.exe (hd1) format --force --fat32 --align --extended 300m</span><br><span class="line">:: 添加菜单文件</span><br><span class="line">fbinst.exe (hd1) add-menu fb.cfg fb.cfg</span><br><span class="line">:: 添加grldr引导管理器</span><br><span class="line">fbinst.exe (hd1) add grldr grldr -e</span><br><span class="line">:: 添加ISO文件</span><br><span class="line">fbinst.exe (hd1) add wepe.iso wepe.iso -e</span><br></pre></td></tr></table></figure><p>fb.cfg菜单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default 0</span><br><span class="line">timeout 0</span><br><span class="line">menu F1 grldr &quot;grldr&quot;</span><br></pre></td></tr></table></figure><p>软件内置了grldr程序，但不是较新的版本，新的版本可以去 <a href="http://grub4dos.chenall.net/">http://grub4dos.chenall.net/</a> 下载。然后手动添加到UD区并编辑内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map /wepe.iso (0xff)</span><br><span class="line">map --hook</span><br><span class="line">chainloader (0xff)</span><br></pre></td></tr></table></figure><p>然后导出这个编辑过后的grldr即可，以后就可以通过命令行导入了。更多用法可以自行百度，这里不深究。<br>这样，这个U盘就支持Legacy引导了。</p><h2 id="UEFI引导支持"><a href="#UEFI引导支持" class="headerlink" title="UEFI引导支持"></a>UEFI引导支持</h2><p>UEFI引导还需要再划出一个分区，一般是使用 <a href="https://www.disktool.cn/">分区助手</a> 或 <a href="https://www.diskgenius.cn/">DiskGenius</a> 来做。<br>并将支持UEFI引导的ISO文件解压到这个分区中，比如用分区助手大概是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:: 格式化</span><br><span class="line">PartAssist.exe /hd:1 /fmt:0 /fs:fat32</span><br><span class="line">:: 在U盘末尾分出300mb空间</span><br><span class="line">PartAssistexe /hd:1 /resize:0 /reduce-right:300 /align</span><br><span class="line">:: 在刚才的空间上创建一个隐藏分区</span><br><span class="line">PartAssist.exe /hd:1 /cre /pri /size:auto /end /fs:fat16 /hide /align /label:EFI</span><br><span class="line">:: 从EFI文件夹拷贝所有文件到隐藏分区</span><br><span class="line">PartAssist /hd:1 /whide:1 /src:D:\fbinst\EFI</span><br></pre></td></tr></table></figure><p>这样，这个U盘就支持UEFI引导了。</p><h2 id="用户数据区"><a href="#用户数据区" class="headerlink" title="用户数据区"></a>用户数据区</h2><p>用户数据区也就是用户用来存放数据的分区，系统可见，不需要额外操作。<br>经过上面两轮操作后，U盘就有了三个分区：UD分区、EFI分区、用户数据分区。</p><p>最终就实现了市面上U盘制作工具所谓的三分区方案。<br><img src="/images/usb-bootable/1.png"></p><p>系统启动、封装相关技术可以去 <a href="http://wuyou.net/">无忧启动</a> 论坛和 <a href="https://www.itsk.com/">IT天空</a> 网站学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 系统封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE首页读取策略</title>
      <link href="/2021/05/25/lq6QUYTNw/"/>
      <url>/2021/05/25/lq6QUYTNw/</url>
      
        <content type="html"><![CDATA[<h2 id="起始页"><a href="#起始页" class="headerlink" title="起始页"></a>起始页</h2><p>网上有很多话题反映说在IE选项里了设置了新的首页，但是没有任何效果，除去软件劫持等原因以外，这都是对IE的首页读取策略没有搞清楚导致的。</p><p>在很久以前，大概是XP+IE6的时代，设置IE首页只需要设置一个注册表值就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Start Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><p>自从IE8开始，首页的读取策略就变化了，浏览器启动后会<strong>依次访问</strong>以下位置来获取首页地址</p><h3 id="第1个位置"><a href="#第1个位置" class="headerlink" title="第1个位置"></a>第1个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;First Home Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><p>这里的权重最高，但是只会执行一次，浏览器读取后会删掉该值，也可以称为一次性首页。</p><h3 id="第2个位置"><a href="#第2个位置" class="headerlink" title="第2个位置"></a>第2个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;First Home Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><p>与HKCU不同的是，这个值读取后不会自动删除，<strong>所以这里是锁定首页的最佳位置</strong>。</p><h3 id="第3个位置"><a href="#第3个位置" class="headerlink" title="第3个位置"></a>第3个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\EUPP]</span><br><span class="line">&quot;BackupHomePage&quot;=hex:.....</span><br></pre></td></tr></table></figure><p>如其名，这是一个缓存的首页地址，如果缓存地址和第6步中的地址不同，则会从第4步开始依次访问对应注册表位置的值来询问用户是否更改首页<br><img src="/images/1627432328308.png"></p><h3 id="第4个位置"><a href="#第4个位置" class="headerlink" title="第4个位置"></a>第4个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Start Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><h3 id="第5个位置"><a href="#第5个位置" class="headerlink" title="第5个位置"></a>第5个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Start Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><h3 id="第6个位置"><a href="#第6个位置" class="headerlink" title="第6个位置"></a>第6个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Start Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><h3 id="第7个位置"><a href="#第7个位置" class="headerlink" title="第7个位置"></a>第7个位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Start Page&quot;=&quot;www.google.com&quot;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对于锁定首页来说，修改第2个位置就行了，它优先级高，且不出现在IE选项里，普通用户无法通过更改IE设置来还原首页。</p><p>如果你想让IE以选项里的设置为准，只需要删除”BackupHomePage”和”First Home Page”即可，我这里提供一个写好的批处理<br> <figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">set</span> HOMEPAGE=www.google.com</span><br><span class="line">REG DELETE &quot;HKCU\SOFTWARE\Microsoft\Internet Explorer\EUPP&quot; /v &quot;BackupHomePage&quot; /f</span><br><span class="line">REG DELETE &quot;HKLM\SOFTWARE\Microsoft\Internet Explorer\Main&quot; /v &quot;<span class="built_in">Start</span> Page&quot; /f</span><br><span class="line">REG DELETE &quot;HKCU\SOFTWARE\Policies\Microsoft\Internet Explorer\Main&quot; /v &quot;<span class="built_in">Start</span> Page&quot; /f</span><br><span class="line">REG DELETE &quot;HKLM\SOFTWARE\Policies\Microsoft\Internet Explorer\Main&quot; /v &quot;<span class="built_in">Start</span> Page&quot; /f</span><br><span class="line">REG DELETE &quot;HKCU\SOFTWARE\Microsoft\Internet Explorer\Main&quot; /v &quot;First Home Page&quot; /f</span><br><span class="line">REG DELETE &quot;HKLM\SOFTWARE\Microsoft\Internet Explorer\Main&quot; /v &quot;First Home Page&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\SOFTWARE\Microsoft\Internet Explorer\Main&quot; /v &quot;<span class="built_in">Start</span> Page&quot; /t REG_SZ /d <span class="variable">%HOMEPAGE%</span> /f</span><br></pre></td></tr></table></figure><br> 第一行修改为自己的网址即可，由于删除了缓存地址，IE会提示设置已损坏，点击更改即可。<br> 使用此脚本重置后就可以在IE选项里修改首页了。<br> <img src="/images/1627432337787.png"></p><hr><h2 id="辅助起始页"><a href="#辅助起始页" class="headerlink" title="辅助起始页"></a>辅助起始页</h2><p>辅助起始页是随着浏览器启动的多开网页地址，和第一首页不冲突，同样的，HKCU比HKLM优先级高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main]</span><br><span class="line">&quot;Secondary Start Pages&quot;=hex(7):68,00,74,00,74,00,70,00,3a,00,2f,00,2f,00,77,00,\</span><br><span class="line">  77,00,77,00,2e,00,71,00,71,00,2e,00,63,00,6f,00,6d,00,2f,00,00,00,68,00,74,\</span><br><span class="line">  00,74,00,70,00,3a,00,2f,00,2f,00,77,00,77,00,77,00,2e,00,31,00,36,00,33,00,\</span><br><span class="line">  2e,00,63,00,6f,00,6d,00,2f,00,00,00,00,00</span><br></pre></td></tr></table></figure><p>因为可以设置多个网址，所以注册表值类型是”REG_MULTI_SZ”。由于该功能使用不多，就不继续深究了。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://bbs.pediy.com/thread-196517.htm">逆向IE11的首页保护算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IE </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程方式制作增量补丁</title>
      <link href="/2020/08/16/PatchAPI/"/>
      <url>/2020/08/16/PatchAPI/</url>
      
        <content type="html"><![CDATA[<p>微软提供了两套API来制作增量补丁，PatchAPI和MSDelta<br>PatchAPI支持XP，效率高但文件会比MSDelta大，属于第一代增量压缩接口，不建议使用。<br>MSDelta不支持XP系统，补丁文件更小，兼容PatchAPI的补丁，微软的补丁包用了此接口。</p><h2 id="PatchAPI"><a href="#PatchAPI" class="headerlink" title="PatchAPI"></a>PatchAPI</h2><p>创建补丁文件通过 <a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#createpatchfileaw">CreatePatchFile</a> 函数，它是高级的API，制作一对一的升级补丁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PatchApi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;mspatchc&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">BOOL bSuccess = ::<span class="built_in">CreatePatchFileA</span>(<span class="string">&quot;D:\\v1.exe&quot;</span>, <span class="string">&quot;D:\\v2.exe&quot;</span>, <span class="string">&quot;D:\\Patch.dat&quot;</span>, PATCH_OPTION_USE_BEST, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>补丁文件由文件头和数据组成，提取文件头可以用 <a href="https://docs.microsoft.com/en-us/windows/win32/devnotes/patchapi-extractpatchheadertofile">ExtractPatchHeaderToFile</a> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL bSuccess = <span class="built_in">ExtractPatchHeaderToFileA</span>(<span class="string">&quot;D:\\Patch.dat&quot;</span>, <span class="string">&quot;D:\\header.dat&quot;</span>);</span><br></pre></td></tr></table></figure><p>文件头数据由”PA19”标记开始<br><img src="/images/1627176446114.png"><br>打补丁通过 <a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#applypatchtofileaw">ApplyPatchToFile</a> 函数，它是由mspatcha.dll提供的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PatchApi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;mspatcha&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">BOOL bSuccess = ::<span class="built_in">ApplyPatchToFileA</span>(<span class="string">&quot;D:\\Patch.dat&quot;</span>, <span class="string">&quot;D:\\v1.exe&quot;</span>, <span class="string">&quot;D:\\v2.exe&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果需要验证补丁而不应用，可以用 <a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#testapplypatchtofileaw">TestApplyPatchToFile</a> 函数。<br>从多个源文件制作补丁可以用 <a href="https://docs.microsoft.com/en-us/windows/win32/devnotes/patchapi-createpatchfileex">CreatePatchFileEx</a> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PatchApi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;mspatchc&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">PATCH_OLD_FILE_INFO_A src[<span class="number">2</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">src[<span class="number">0</span>].OldFileName = <span class="string">&quot;D:\\v1.exe&quot;</span>;</span><br><span class="line">src[<span class="number">1</span>].OldFileName = <span class="string">&quot;D:\\v2.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line">BOOL bSuccess = <span class="built_in">CreatePatchFileExA</span>(_countof(src), src, <span class="string">&quot;D:\\v3.exe&quot;</span>, <span class="string">&quot;D:\\Patch.dat&quot;</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>这样无论是v1还是v2都能升级到v3</p><h2 id="MSDelta"><a href="#MSDelta" class="headerlink" title="MSDelta"></a>MSDelta</h2><p>PatchAPI的升级版本，补丁文件的头为”PA30”。<br>制作补丁使用 <a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#createdeltaaw">CreateDelta</a> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msdelta.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;msdelta&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">BOOL bSuccess = <span class="built_in">CreateDeltaA</span>(DELTA_FILE_TYPE_SET_EXECUTABLES_LATEST, DELTA_FLAG_NONE, DELTA_FLAG_NONE, <span class="string">&quot;D:\\v1.exe&quot;</span>, <span class="string">&quot;D:\\v2.exe&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &#123; <span class="number">0</span> &#125;, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="string">&quot;D:\\Patch.dat&quot;</span>);</span><br></pre></td></tr></table></figure><p>获取增量补丁信息：<a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#getdeltainfoaw">GetDeltaInfo</a><br>应用增量补丁：<a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx#applydeltaaw">ApplyDelta</a><br>从文档上看，并没有提供从多个源文件制作补丁的方法</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://msdn.microsoft.com/en-us/library/bb417345.aspx">Delta Compression Application Programming Interfaces</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/devnotes/patchapi">PatchAPI</a></p><p><a href="https://github.com/hfiref0x/SXSEXP">https://github.com/hfiref0x/SXSEXP</a></p><p><a href="https://forum.xda-developers.com/windows-10-mobile/decompress-manifests-files-winsxs-folder-t3367399">https://forum.xda-developers.com/windows-10-mobile/decompress-manifests-files-winsxs-folder-t3367399</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金山护眼大师实现原理</title>
      <link href="/2020/08/12/Kingsoft-keyeprotect/"/>
      <url>/2020/08/12/Kingsoft-keyeprotect/</url>
      
        <content type="html"><![CDATA[<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p><a href="https://pc.qq.com/detail/19/detail_25499.html">https://pc.qq.com/detail/19/detail_25499.html</a></p><h2 id="软件设置保存在注册表"><a href="#软件设置保存在注册表" class="headerlink" title="软件设置保存在注册表"></a>软件设置保存在注册表</h2><p>HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\khealtheye<br></br></p><h2 id="护眼原理"><a href="#护眼原理" class="headerlink" title="护眼原理"></a>护眼原理</h2><p>原理是利用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdevicegammaramp">SetDeviceGammaRamp</a> 函数设置色温<br>关键位置在keyeprotect.dll文件中，关键函数 sub_100A8C10<br>IDA静态分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __usercall sub_100A8C10@&lt;al&gt;(<span class="type">unsigned</span> __int16 per@&lt;ax&gt;, <span class="type">int</span> context@&lt;ecx&gt;, <span class="type">int</span> healthMode@&lt;edi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 blueStep; <span class="comment">// ST24_2</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 v5; <span class="comment">// ax</span></span><br><span class="line">  <span class="type">double</span> multiplier; <span class="comment">// st7</span></span><br><span class="line">  <span class="type">double</span> v7; <span class="comment">// st6</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 v8; <span class="comment">// ax</span></span><br><span class="line">  <span class="type">int</span> redStep; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">  WORD redStepa; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">  WORD greenStep; <span class="comment">// [esp+12h] [ebp-6h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> ( healthMode )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:                                     <span class="comment">// 智能模式</span></span><br><span class="line">      v3 = per;</span><br><span class="line">      redStep = *(_DWORD *)(context + <span class="number">20</span>);</span><br><span class="line">      blueStep = *(_WORD *)(context + <span class="number">24</span>);</span><br><span class="line">      v5 = (<span class="type">signed</span> <span class="type">int</span>)((<span class="type">double</span>)per * <span class="number">1.28</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:                                     <span class="comment">// 办公模式</span></span><br><span class="line">      v3 = per;</span><br><span class="line">      multiplier = (<span class="type">double</span>)per;</span><br><span class="line">      v7 = <span class="number">0.4</span> * multiplier + <span class="number">88.0</span>;</span><br><span class="line">      v8 = (<span class="type">signed</span> <span class="type">int</span>)v7;</span><br><span class="line">      redStepa = (<span class="type">signed</span> <span class="type">int</span>)v7;</span><br><span class="line">      <span class="keyword">if</span> ( v8 &lt; <span class="number">88u</span> )</span><br><span class="line">        redStepa = <span class="number">88</span>;</span><br><span class="line">      greenStep = (<span class="type">signed</span> <span class="type">int</span>)v7;</span><br><span class="line">      <span class="keyword">if</span> ( v8 &lt; <span class="number">88u</span> )</span><br><span class="line">        greenStep = <span class="number">88</span>;</span><br><span class="line">      <span class="built_in">SetGamma</span>((_DWORD *)context, redStepa, greenStep, (<span class="type">signed</span> <span class="type">int</span>)(multiplier * <span class="number">1.28</span>));</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:                                     <span class="comment">// 影视模式</span></span><br><span class="line">      v3 = per;</span><br><span class="line">      v5 = (<span class="type">signed</span> <span class="type">int</span>)((<span class="type">double</span>)per * <span class="number">1.28</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:                                     <span class="comment">// 游戏模式</span></span><br><span class="line">      v3 = per;</span><br><span class="line">      v5 = (<span class="type">signed</span> <span class="type">int</span>)((<span class="type">double</span>)per * <span class="number">1.28</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOWORD</span>(redStep) = v5;</span><br><span class="line">  <span class="built_in">HIWORD</span>(redStep) = v5;</span><br><span class="line">LABEL_10:</span><br><span class="line">  <span class="built_in">SetGamma</span>((_DWORD *)context, redStep, <span class="built_in">HIWORD</span>(redStep), v5);</span><br><span class="line">LABEL_11:</span><br><span class="line">  <span class="built_in">sub_100A4AE0</span>(healthMode);</span><br><span class="line">  <span class="built_in">sub_100A4AE0</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出设置公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">HealthMode</span></span><br><span class="line">&#123;</span><br><span class="line">Smart,</span><br><span class="line">Office,</span><br><span class="line">Movie,</span><br><span class="line">Game</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetGamma</span><span class="params">(<span class="type">double</span> redStep, <span class="type">double</span> greenStep, <span class="type">double</span> blueStep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> success = <span class="literal">false</span>;</span><br><span class="line">HDC hDevice = ::<span class="built_in">GetDC</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (hDevice)</span><br><span class="line">&#123;</span><br><span class="line">WORD ramp[<span class="number">3</span>][<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> r = i * (redStep + <span class="number">128</span>);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> g = i * (greenStep + <span class="number">128</span>);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> b = i * (blueStep + <span class="number">128</span>);</span><br><span class="line">ramp[<span class="number">0</span>][i] = (WORD)(<span class="built_in">min</span>(<span class="number">0xFFFF</span>, r));</span><br><span class="line">ramp[<span class="number">1</span>][i] = (WORD)(<span class="built_in">min</span>(<span class="number">0xFFFF</span>, g));</span><br><span class="line">ramp[<span class="number">2</span>][i] = (WORD)(<span class="built_in">min</span>(<span class="number">0xFFFF</span>, b));</span><br><span class="line">&#125;</span><br><span class="line">success = ::<span class="built_in">SetDeviceGammaRamp</span>(hDevice, ramp);</span><br><span class="line">::<span class="built_in">ReleaseDC</span>(<span class="literal">nullptr</span>, hDevice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 护眼</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;brightness&quot;&gt;亮度百分比(0 ~ 100)&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;mode&quot;&gt;护眼模式&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EyeProtect</span><span class="params">(<span class="type">double</span> brightness, HealthMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> success = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> multiplier = brightness;</span><br><span class="line"><span class="type">double</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> g = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> b = std::<span class="built_in">round</span>(multiplier * <span class="number">1.28</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> HealthMode::Smart:</span><br><span class="line">r = g = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> HealthMode::Office:</span><br><span class="line">r = g = <span class="built_in">max</span>(<span class="number">88</span>, <span class="number">0.4</span> * multiplier + <span class="number">88.0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> HealthMode::Movie:</span><br><span class="line"><span class="keyword">case</span> HealthMode::Game:</span><br><span class="line">r = g = b;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">success = <span class="built_in">SetGamma</span>(r, g, b);</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何模式下将亮度设置为100都会变为系统默认值，等同于关闭护眼功能。<br>其中影视模式和游戏模式的公式是同一个，效果相同。</p><p>智能模式默认亮度为75%<br>办公模式默认亮度为30%<br>影视模式默认亮度为59%<br>游戏模式默认亮度为78%</p><h2 id="配置文件解密"><a href="#配置文件解密" class="headerlink" title="配置文件解密"></a>配置文件解密</h2><p>data目录下有部分.dat文件，是xml加密后的数据。<br>解密方法就是去掉头4字节，就是字符串”.tmp”，然后把余下的数据与0xD8异或，最后从末尾搜索0xFDFDFDFD，找到并删除其之后的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Decrypt</span><span class="params">(<span class="type">char</span>* pData, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pData[i] ^= <span class="number">0xD8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> dir = fs::<span class="built_in">current_path</span>();</span><br><span class="line"><span class="keyword">auto</span> iter = fs::<span class="built_in">recursive_directory_iterator</span>(dir);</span><br><span class="line"><span class="keyword">auto</span> end = fs::<span class="built_in">recursive_directory_iterator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iter != end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fs::<span class="built_in">is_regular_file</span>(*iter))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> path = iter-&gt;<span class="built_in">path</span>();</span><br><span class="line"><span class="keyword">if</span> (path.<span class="built_in">extension</span>() == <span class="string">&quot;.dat&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(path, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (in.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> size = in.<span class="built_in">tellg</span>();</span><br><span class="line">in.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line"><span class="keyword">auto</span> buf = std::<span class="built_in">make_unique</span>&lt;<span class="type">char</span>[]&gt;(size);</span><br><span class="line"><span class="keyword">auto</span> p = buf.<span class="built_in">get</span>();</span><br><span class="line">in.<span class="built_in">read</span>(p, size);</span><br><span class="line"><span class="keyword">if</span> (_strnicmp(p, <span class="string">&quot;.tmp&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p += <span class="number">4</span>;</span><br><span class="line"><span class="built_in">Decrypt</span>(p, (<span class="type">int</span>)size - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;out.xml&quot;</span>, std::ios::binary | std::ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (out.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; p;</span><br><span class="line">out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">iter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
